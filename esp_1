// =======================================================================================
// WERSJA 20.8 (Refaktoryzacja - Usuniecie logiki Z-N na rzecz sterowania z UI)
//
// ZMIANY:
// -----------------------------------
// [REFAKTORYZACJA] Calkowicie usunieto wewnetrzna logike strojenia Zieglera-Nicholsa.
//                  Robot nie posiada juz stanu AUTO_TUNING. Caly proces jest teraz
//                  sterowany z poziomu panelu w JavaScript, ktory wysyla polecenia
//                  'set_param' i analizuje dane telemetryczne.
//                  Upraszcza to kod robota i odciaza jego procesor.
// =======================================================================================

// --- [DMP] NOWE BIBLIOTEKI DLA MPU6050 I DMP ---
#include "MPU6050_6Axis_MotionApps20.h"

// --- Pozostale biblioteki ---
#include <ArduinoJson.h>
#include <BLE2902.h>
#include <BLEDevice.h>
#include <BLEServer.h>
#include <BLEUtils.h>
#include <EEPROM.h>
#include <Wire.h>
#include <math.h>
#include <rom/crc.h>

#include <atomic>

#include "driver/gpio.hh"
#include "driver/ledc.h"
#include "esp_system.h"
#include "freertos/queue.h"
#include "freertos/semphr.h"

// =========================================================================
// === SEKCJA KONFIGURACYJNA ===
// =========================================================================

// --- Definicje pinow ---
#define MPU_SDA 0
#define MPU_SCL 1
#define MPU_INT_PIN 10
#define MOTOR_L_IN1 2
#define MOTOR_L_IN2 3
#define MOTOR_R_IN1 8
#define MOTOR_R_IN2 9
#define ENCODER_L_A 5
#define ENCODER_L_B 4
#define ENCODER_R_A 20
#define ENCODER_R_B 21

// --- Konfiguracja sprzetowa ---
#define PWM_FREQ 30000
#define PWM_RESOLUTION 10
#define PWM_MAX_VALUE 1023
#define ENCODER_L_INVERTED true
#define ENCODER_R_INVERTED false
#define MOTOR_R_INVERT_LOGIC true
#define ENCODER_DEBOUNCE_MICROS 150
#define MAX_ACCELERATION 50

// --- Konfiguracja kanalow LEDC (PWM) ---
#define LEDC_CHANNEL_L_IN1 2
#define LEDC_CHANNEL_L_IN2 3
#define LEDC_CHANNEL_R_IN1 0
#define LEDC_CHANNEL_R_IN2 1

// --- Konfiguracja BLE ---
#define SERVICE_UUID "4fafc201-1fb5-459e-8fcc-c5c9c331914b"
#define CHARACTERISTIC_UUID_TX "beb5483e-36e1-4688-b7f5-ea07361b26a8"
#define CHARACTERISTIC_UUID_RX "beb5483e-36e1-4688-b7f5-ea07361b26a9"
#define ROBOT_BLE_NAME "RoboBala"
#define BLE_PACKET_MAX_SIZE 512
#define BLE_TX_QUEUE_SIZE 20
#define BLE_TX_DELAY_MS 5
#define BLE_TX_FRAGMENT_DELAY_MS 35

// --- Stale Systemowe i Bezpieczenstwa ---
const unsigned long LOOP_INTERVAL_MICROS = 5000;
const TickType_t LOOP_INTERVAL_TICKS = pdMS_TO_TICKS(5);
#define CRITICAL_ANGLE_LIMIT 60.0f
#define CRITICAL_GYRO_LIMIT 350.0f
const float ZERO_ADJUST_STEP = 0.05f;
const unsigned long JOYSTICK_TIMEOUT = 250;
#define TELEMETRY_INTERVAL_MS 20
#define MAX_JSON_SIZE 3072
#define SMALL_JSON_SIZE 1024
#define LIFT_DETECTION_THRESHOLD_G 0.3f
#define LIFT_DETECTION_DURATION_MS 300
#define ZERO_CALIBRATION_DURATION_MS 10000

// --- Konfiguracja Mutexow i Synchronizacji ---
#define JSON_MUTEX_TIMEOUT_MS 100

// --- [USUNIETO] Konfiguracja Modulu Auto-Strojenia (Ziegler-Nichols) ---
// Ta logika jest teraz po stronie UI

// --- Struktury ---
struct PIDController {
    float Kp = 0.0f, Ki = 0.0f, Kd = 0.0f;
    float integral = 0.0f, prev_input = 0.0f;
    float min_out = 0.0f, max_out = 0.0f, integral_limit = 0.0f;
    float deadband = 0.0f;
    float last_output = 0.0f;
    float derivative_filter_alpha = 1.0f;
    float filtered_derivative = 0.0f;
    bool is_idle = false;

    void configure(float p, float i, float d, float min, float max, float int_limit, float filter_alpha = 1.0f) {
        Kp = p; Ki = i; Kd = d; min_out = min; max_out = max; integral_limit = int_limit; derivative_filter_alpha = filter_alpha;
    }

    void setIdle(bool idle) {
        if (idle && !is_idle) { filtered_derivative = 0.0f; }
        is_idle = idle;
    }

    float compute(float setpoint, float input, float dt) {
        if (dt <= 0) return last_output;
        float error = setpoint - input;
        if (abs(error) < deadband) { error = 0.0f; }
        float p_out = Kp * error;
        float d_out = 0.0f;
        if (!is_idle) {
            float raw_derivative = (input - prev_input) / dt;
            filtered_derivative = (1.0f - derivative_filter_alpha) * filtered_derivative + derivative_filter_alpha * raw_derivative;
            d_out = -Kd * filtered_derivative;
        }
        float i_out = 0.0f;
        if (Ki > 0.00001f) {
            if (!is_idle) {
                integral += error * dt;
                integral = constrain(integral, -integral_limit, integral_limit);
            }
            i_out = Ki * integral;
        } else { integral = 0.0f; }
        float output = p_out + i_out + d_out;
        float constrained_output = constrain(output, min_out, max_out);
        if (Ki > 0.00001f && output != constrained_output && !is_idle) {
            integral += (constrained_output - output) / Ki;
            integral = constrain(integral, -integral_limit, integral_limit);
        }
        prev_input = input; last_output = constrained_output; return last_output;
    }

    void reset() {
        integral = 0.0f; prev_input = 0.0f; last_output = 0.0f; filtered_derivative = 0.0f; is_idle = false;
    }
};

struct ControlFlags {
    bool balancingEnabled = false, emergencyStop = false, directMotorControlActive = false, holdPositionEnabled = false, speedModeEnabled = false;
};

struct TuningParams {
    float Kp_b, Ki_b, Kd_b, balancePidDerivativeFilterAlpha, joystickAngleSensitivity;
    float Kp_s, Ki_s, Kd_s, Kp_p, Ki_p, Kd_p, Kp_r, Kd_r, Kp_h, Ki_h, Kd_h;
    float speedPidDeadband, positionPidDeadband, expoJoystick, maxSpeedJoystick, turnFactor, joystickDeadzone, joystickSensitivity;
    float wheelDiameterCm, trackWidthCm, encoderPPR, maxTargetAngleFromSpeedPID, maxTargetSpeedFromPosPID;
    int minPwmLeftFwd, minPwmLeftBwd, minPwmRightFwd, minPwmRightBwd;
};

struct EncoderState {
    std::atomic<long> position;
    const uint8_t pin_a, pin_b;
    const bool inverted;
    volatile uint8_t prev_state;
    volatile unsigned long last_micros;
};

struct BLEMessage {
    char data[BLE_PACKET_MAX_SIZE];
    size_t length;
    bool isFragment;
};

#define EEPROM_BUFFER_SIZE 5
#define EEPROM_START_ADDRESS 0
#define CONFIG_VERSION "pid-dmp-v19.0"
#define CONFIG_MAGIC_NUMBER 0xCAFED060
#define EEPROM_SIZE (EEPROM_BUFFER_SIZE * sizeof(EEPROMSettings) + sizeof(uint8_t))
uint8_t current_config_index = 0;

struct EEPROMSettings {
    uint32_t magic_number;
    char version[32];
    TuningParams params;
    uint32_t crc;
};

// [ZMIANA] Usunieto stan AUTO_TUNING
enum RobotState { IDLE, BALANCING, HOLDING_POSITION, AUTONOMOUS_MOVE, AUTONOMOUS_ROTATE, AUTONOMOUS_SPEED_RUN, AUTONOMOUS_POSITION_RECOVERY, CALIBRATING_ZERO, GA_TRIAL };
const char* robotStateNames[] = {"IDLE", "BALANSUJE", "TRZYMA_POZYCJE", "RUCH_AUTONOMICZNY", "OBROT_AUTONOMICZNY", "TEST_PREDKOSCI", "TEST_POZYCJI", "KALIBRACJA_PIONU", "TEST_GA"};

// --- Zmienne Globalne ---
ControlFlags controlFlags; TuningParams tuningParams; MPU6050 mpu;
PIDController balancePID, speedPID, positionPID, rotationPID, headingPID;
bool dmpReady = false; uint8_t fifoBuffer[64];
Quaternion q; VectorFloat gravity; VectorInt16 accel; float ypr[3];
volatile bool mpuInterrupt = false; unsigned long liftDetectStartTime = 0, timeOfFall = 0;
RobotState currentState = IDLE; long positionSetpoint = 0;
float targetSpeed = 0.0f; long targetPosition = 0; long initialTestPosition = 0;
long targetRotationDiff = 0; unsigned long positionRecoveryTimeout = 0;
float pitch = 0.0, yaw = 0.0, roll = 0.0, angleOffset = 0.0, rollOffset = 0.0, baseTargetAngleTrim = 0.0;
float actualSpeed = 0.0f, finalTargetAngle = 0.0f, filtered_actual_speed = 0.0f;
const float SPEED_FILTER_ALPHA = 0.4f;
std::atomic<float> joystickX{0.0f}, joystickY{0.0f}; volatile bool joystickActive = false;
unsigned long lastJoystickTime = 0, lastDirectControlTime = 0;
float internal_impulsesPerCm = 0.0f, internal_impulsesPerDegree = 0.0f;
unsigned long zeroCalibStartTime = 0; float zeroCalibPitchSum = 0.0; int zeroCalibSampleCount = 0;
float currentLeftMotorOutput = 0.0f, currentRightMotorOutput = 0.0f;
BLEServer* pServer = NULL; BLECharacteristic* pTxCharacteristic = NULL; volatile bool bleDeviceConnected = false;
EncoderState encoder_L = {{0}, ENCODER_L_A, ENCODER_L_B, ENCODER_L_INVERTED, 0, 0};
EncoderState encoder_R = {{0}, ENCODER_R_A, ENCODER_R_B, ENCODER_R_INVERTED, 0, 0};
QueueHandle_t bleRxQueue = NULL, bleTxQueue = NULL;
StaticJsonDocument<MAX_JSON_SIZE> globalJsonDoc; StaticJsonDocument<SMALL_JSON_SIZE> smallJsonDoc;
SemaphoreHandle_t smallJsonMutex;
volatile float telemetry_pitch=0.0f, telemetry_yaw=0.0f, telemetry_roll=0.0f, telemetry_actual_speed=0.0f, telemetry_balance_output=0.0f, telemetry_target_speed=0.0f;
volatile long telemetry_encoder_left=0, telemetry_encoder_right=0;
std::atomic<unsigned long> telemetry_loop_time_micros{0}; std::atomic<long> globalCurrentPosition{0};
enum TrialType { TRIAL_NONE, TRIAL_BALANCE, TRIAL_SPEED, TRIAL_POSITION, TRIAL_ROTATE };
volatile TrialType currentTrialType = TRIAL_NONE; volatile unsigned long currentTrialId = 0, currentTrialStartMs = 0;
TuningParams safeTuningParams; // Zachowane dla GA
bool isGaSessionActive = false; const int GA_TRIAL_DURATION_MS = 5000; unsigned long gaTrialStartTime = 0;
float ga_itae = 0, ga_max_overshoot = 0, ga_rms_effort = 0; int ga_sample_count = 0;

// --- Prototypy Funkcji ---
void transitionToState(RobotState); void initializeMotorPinsSafe(); void ControlLoopTask(void*);
void TelemetryTask(void*); void CommunicationManagerTask(void*); void BLETransmitTask(void*);
void sendFullConfiguration(); void updateSystemConfiguration(); void recalculateMotionParameters();
bool loadTuningsFromEEPROM(); void saveTuningsToEEPROM(); void loadDefaultSettings();
void stopAllMotors(); void setMotorPower(float, float); void emergencyShutdown(const char*);
void calibrateMPU(); bool calibrateAndApplyOffsets(); void printAndLog(const char*, const char*, ...);
bool sendBleNotificationSafe(const String&); bool sendLargeBleNotificationFragmented(const String&);
void sendAck(const char*, bool, const char*); void send3dTelemetry();
void setMotorPowerRaw(uint8_t, int); int tuneSingleMotor(uint8_t, int, int);
float fmap(float, float, float, float, float); float mapMotorOutput(float, int, int);
static void IRAM_ATTR encoder_isr_handler(void*); void setupEncoders(); void IRAM_ATTR dmpDataReady();
void setupSensors(); float normalizeAngle(float); void resetAllPids();
void checkLiftDetection(const int16_t&, const int16_t&, const int16_t&);
void checkSafetySystems(float); void autoRecovery();
void startGaSession(); void runGaTrial(float, float); void finishGaTrial(); void cancelGaSession();

// --- [USUNIETO] Prototypy dla Z-N ---

struct FragmentingPrint : public Print {
    const size_t CHUNK_PAYLOAD_SIZE = 400; char buffer[512]; size_t current_size = 0; unsigned long message_id; int chunk_index = 0;
    FragmentingPrint() { message_id = millis(); memset(buffer, 0, sizeof(buffer)); }
    size_t write(const uint8_t* buf, size_t size) override {
        for (size_t i = 0; i < size; i++) {
            if (current_size < sizeof(buffer) - 1) { buffer[current_size++] = buf[i]; }
            if (current_size >= CHUNK_PAYLOAD_SIZE) { flush(); }
        } return size;
    }
    size_t write(uint8_t c) override {
        if (current_size < sizeof(buffer) - 1) { buffer[current_size++] = c; }
        if (current_size >= CHUNK_PAYLOAD_SIZE) { flush(); }
        return 1;
    }
    void flush() {
        if (current_size == 0) return;
        if (xSemaphoreTake(smallJsonMutex, pdMS_TO_TICKS(100)) == pdTRUE) {
            smallJsonDoc.clear(); smallJsonDoc["type"] = "chunk_stream"; smallJsonDoc["id"] = message_id; smallJsonDoc["i"] = chunk_index++;
            buffer[current_size] = '\0'; smallJsonDoc["data"] = buffer;
            String chunkBuffer; serializeJson(smallJsonDoc, chunkBuffer); String chunkWithNewline = chunkBuffer + "\n";
            BLEMessage msg; msg.length = chunkWithNewline.length(); strncpy(msg.data, chunkWithNewline.c_str(), sizeof(msg.data) - 1);
            msg.data[sizeof(msg.data) - 1] = '\0'; msg.isFragment = true;
            if (xQueueSend(bleTxQueue, &msg, pdMS_TO_TICKS(10)) != pdTRUE) { Serial.printf("[ERROR] Nie udalo sie zakolejkowac fragmentu %d\n", chunk_index - 1); }
            xSemaphoreGive(smallJsonMutex);
        }
        memset(buffer, 0, sizeof(buffer)); current_size = 0;
    }
    void end() {
        flush();
        if (xSemaphoreTake(smallJsonMutex, pdMS_TO_TICKS(100)) == pdTRUE) {
            smallJsonDoc.clear(); smallJsonDoc["type"] = "chunk_stream"; smallJsonDoc["id"] = message_id; smallJsonDoc["i"] = chunk_index; smallJsonDoc["total"] = chunk_index + 1;
            String finalChunkBuffer; serializeJson(smallJsonDoc, finalChunkBuffer); String chunkWithNewline = finalChunkBuffer + "\n";
            BLEMessage msg; msg.length = chunkWithNewline.length(); strncpy(msg.data, chunkWithNewline.c_str(), sizeof(msg.data) - 1);
            msg.data[sizeof(msg.data) - 1] = '\0'; msg.isFragment = true;
            xQueueSend(bleTxQueue, &msg, pdMS_TO_TICKS(10));
            xSemaphoreGive(smallJsonMutex);
        }
    }
};

void initializeMotorPinsSafe() {
    pinMode(MOTOR_L_IN1, OUTPUT); pinMode(MOTOR_L_IN2, OUTPUT); pinMode(MOTOR_R_IN1, OUTPUT); pinMode(MOTOR_R_IN2, OUTPUT);
    digitalWrite(MOTOR_L_IN1, LOW); digitalWrite(MOTOR_L_IN2, LOW); digitalWrite(MOTOR_R_IN1, LOW); digitalWrite(MOTOR_R_IN2, LOW);
}

void IRAM_ATTR dmpDataReady() { mpuInterrupt = true; }

bool calibrateAndApplyOffsets() {
    printAndLog("info", "Rozpoczynam procedure kalibracji sensorow. Trzymaj robota nieruchomo...");
    mpu.setDMPEnabled(false); mpu.setXAccelOffset(0); mpu.setYAccelOffset(0); mpu.setZAccelOffset(0);
    mpu.setXGyroOffset(0); mpu.setYGyroOffset(0); mpu.setZGyroOffset(0);
    printAndLog("info", "Zbieranie danych... To potrwa kilka sekund.");
    mpu.CalibrateAccel(6); mpu.CalibrateGyro(6); mpu.setDMPEnabled(true);
    printAndLog("info", "Kalibracja zakonczona. Zastosowane offsety:"); mpu.PrintActiveOffsets();
    return true;
}

void calibrateMPU() {
    controlFlags.balancingEnabled = false; stopAllMotors(); vTaskDelay(pdMS_TO_TICKS(100));
    printAndLog("warn", "ROZPOCZETO PELNA KALIBRACJE MPU!");
    if (calibrateAndApplyOffsets()) {
        angleOffset = 0; rollOffset = 0; baseTargetAngleTrim = 0; resetAllPids();
        printAndLog("info", "KALIBRACJA ZAKONCZONA POMYSLNIE. Robot jest gotowy.");
        sendAck("calibrate_mpu", true);
    } else {
        printAndLog("error", "KRYTYCZNY BLAD podczas ponownej kalibracji MPU."); dmpReady = false;
        sendAck("calibrate_mpu", false, "Blad procedury kalibracji");
    }
}

void sendAck(const char* command, bool success, const char* message = nullptr) {
    if (!bleDeviceConnected) return;
    if (xSemaphoreTake(smallJsonMutex, pdMS_TO_TICKS(20)) == pdTRUE) {
        smallJsonDoc.clear(); smallJsonDoc["type"] = "ack"; smallJsonDoc["command"] = command; smallJsonDoc["success"] = success;
        if (message) { smallJsonDoc["message"] = message; }
        String jsonBuffer; serializeJson(smallJsonDoc, jsonBuffer);
        xSemaphoreGive(smallJsonMutex);
        sendBleNotificationSafe(jsonBuffer);
    }
}

float normalizeAngle(float angle) {
    float a = fmod(angle + 180.0, 360.0);
    if (a < 0) a += 360.0;
    return a - 180.0;
}

void resetAllPids() { balancePID.reset(); speedPID.reset(); positionPID.reset(); rotationPID.reset(); headingPID.reset(); }

// --- [USUNIETO] Implementacje funkcji Z-N (start, cancel, finish, handle) ---
// Ta logika zostala przeniesiona do panelu w JavaScript

void startGaSession() {
    if (currentState != BALANCING && currentState != HOLDING_POSITION) {
        printAndLog("warn", "[GA] Nie mozna rozpoczac sesji. Robot musi byc w stanie balansu.");
        return;
    }
    printAndLog("info", "[GA] Rozpoczeto sesje GA dla petli balansu.");
    safeTuningParams = tuningParams;
    isGaSessionActive = true;
    transitionToState(HOLDING_POSITION);
}

void runGaTrial(float kp, float kd) {
    if (!isGaSessionActive)
        return;
    if (currentState != HOLDING_POSITION && currentState != BALANCING) {
        printAndLog("warn", "[GA] Robot nie jest gotowy na probe. Anuluje.");
        cancelGaSession();
        return;
    }
    tuningParams.Kp_b = kp;
    tuningParams.Kd_b = kd;
    updateSystemConfiguration();
    resetAllPids();
    ga_itae = 0;
    ga_max_overshoot = 0;
    ga_rms_effort = 0;
    ga_sample_count = 0;
    transitionToState(GA_TRIAL);
    gaTrialStartTime = millis();
    printAndLog("info", "[GA] Rozpoczeto probe z Kp=%.2f, Kd=%.2f", kp, kd);
}

void finishGaTrial() {
    if (currentState != GA_TRIAL)
        return;
    ga_rms_effort = (ga_sample_count > 0) ? sqrt(ga_rms_effort / ga_sample_count) : 0;
    float score = ga_itae + (ga_max_overshoot * 20.0) + (ga_rms_effort * 0.01);
    printAndLog("info", "[GA] Proba zakonczona. Wynik: %.4f", score);

    if (xSemaphoreTake(smallJsonMutex, pdMS_TO_TICKS(20)) == pdTRUE) {
        smallJsonDoc.clear();
        smallJsonDoc["type"] = "ga_result";
        smallJsonDoc["score"] = score;
        String jsonBuffer;
        serializeJson(smallJsonDoc, jsonBuffer);

        xSemaphoreGive(smallJsonMutex);

        sendBleNotificationSafe(jsonBuffer);
    }

    tuningParams = safeTuningParams;
    updateSystemConfiguration();
    transitionToState(HOLDING_POSITION);
}

void cancelGaSession() {
    if (!isGaSessionActive)
        return;
    isGaSessionActive = false;
    tuningParams = safeTuningParams;
    updateSystemConfiguration();
    transitionToState(HOLDING_POSITION);
    printAndLog("warn", "[GA] Sesja GA anulowana.");
}

void transitionToState(RobotState newState) {
    if (currentState == newState)
        return;

    RobotState oldState = currentState;

    if (newState == HOLDING_POSITION && oldState != AUTONOMOUS_MOVE && oldState != AUTONOMOUS_ROTATE && oldState != AUTONOMOUS_SPEED_RUN && oldState != AUTONOMOUS_POSITION_RECOVERY) {
        positionSetpoint = globalCurrentPosition.load(std::memory_order_relaxed);
        positionPID.reset();
        speedPID.reset();
    } else if (newState == AUTONOMOUS_MOVE || newState == AUTONOMOUS_SPEED_RUN) {
        positionPID.reset();
        speedPID.reset();
    } else if (newState == AUTONOMOUS_ROTATE) {
        rotationPID.reset();
    } else if (newState == IDLE) {
        resetAllPids();
    } else if (newState == BALANCING) {
        if (oldState == AUTONOMOUS_MOVE || oldState == HOLDING_POSITION) {
            speedPID.reset();
        }
    }

    currentState = newState;
}

void ControlLoopTask(void* pvParameters) {
    printAndLog("info", "Zadanie petli sterowania uruchomione.");
    long lastPosition = 0;
    TickType_t xLastWakeTime = xTaskGetTickCount();
    unsigned long last3dTelemetryTime = 0;

    for (;;) {
        unsigned long loopStartTime = micros();
        const float dt = (float)LOOP_INTERVAL_MICROS / 1000000.0f;

        if (dmpReady && !controlFlags.directMotorControlActive) {
            if (mpuInterrupt) {
                mpuInterrupt = false;
                if (mpu.dmpPacketAvailable() && mpu.dmpGetCurrentFIFOPacket(fifoBuffer)) {
                    mpu.dmpGetQuaternion(&q, fifoBuffer);
                    mpu.dmpGetGravity(&gravity, &q);
                    mpu.dmpGetYawPitchRoll(ypr, &q, &gravity);
                    mpu.dmpGetAccel(&accel, fifoBuffer);
                    pitch = ypr[1] * 180 / M_PI;
                    roll = ypr[0] * 180 / M_PI;
                    yaw = ypr[2] * 180 / M_PI;
                } else {
                    mpu.resetFIFO();
                }
            }
        }

        long currentPosL = encoder_L.position.load(std::memory_order_relaxed);
        long currentPosR = encoder_R.position.load(std::memory_order_relaxed);
        long currentPosition = (currentPosL + currentPosR) / 2;
        globalCurrentPosition.store(currentPosition, std::memory_order_relaxed);

        checkLiftDetection(accel.x, accel.y, accel.z);
        checkSafetySystems(mpu.getRotationY() / 131.0);
        autoRecovery();

        if (currentState == GA_TRIAL) {
            if (millis() - gaTrialStartTime >= GA_TRIAL_DURATION_MS) {
                finishGaTrial();
            } else {
                float current_pitch = pitch - angleOffset;
                float current_output = abs(balancePID.last_output);
                ga_itae += abs(current_pitch) * dt;
                if (abs(current_pitch) > ga_max_overshoot) {
                    ga_max_overshoot = abs(current_pitch);
                }
                ga_rms_effort += current_output * current_output;
                ga_sample_count++;
            }
        }

        if (currentState == CALIBRATING_ZERO) {
            if (millis() - zeroCalibStartTime < ZERO_CALIBRATION_DURATION_MS) {
                zeroCalibPitchSum += (pitch - angleOffset);
                zeroCalibSampleCount++;
            } else {
                if (zeroCalibSampleCount > 0) {
                    float avgError = zeroCalibPitchSum / zeroCalibSampleCount;
                    angleOffset += avgError;
                    baseTargetAngleTrim = 0.0;
                    printAndLog("success", "Kalibracja pionu zakonczona. Nowy offset: %.4f", angleOffset);
                    sendAck("calibrate_zero_point", true, "Kalibracja zakonczona");
                } else {
                    printAndLog("error", "Blad kalibracji pionu: brak probek.");
                    sendAck("calibrate_zero_point", false, "Blad: Brak probek");
                }
                transitionToState(HOLDING_POSITION);
            }
        }

        // --- [USUNIETO] Obsluga stanu AUTO_TUNING ---
        
        float raw_speed = (float)(currentPosition - lastPosition) / dt;
        lastPosition = currentPosition;
        filtered_actual_speed = (1.0f - SPEED_FILTER_ALPHA) * filtered_actual_speed + SPEED_FILTER_ALPHA * raw_speed;
        actualSpeed = filtered_actual_speed;
        bool isJoystickTimedOut = (millis() - lastJoystickTime > JOYSTICK_TIMEOUT);
        bool isJoystickMoving = joystickActive && !isJoystickTimedOut;
        float joystickTargetSpeed = 0.0f, joystickTargetAngle = 0.0f, joystickTurnComponent = 0.0f;

        float joyX = joystickX.load(std::memory_order_relaxed);
        float joyY = joystickY.load(std::memory_order_relaxed);

        if (isJoystickMoving) {
            float joyY_d = (abs(joyY) > tuningParams.joystickDeadzone) ? joyY : 0.0f;
            float targetJoyY_expo = (1.0f - tuningParams.expoJoystick) * joyY_d + tuningParams.expoJoystick * pow(joyY_d, 3);
            float finalJoyY = targetJoyY_expo * tuningParams.joystickSensitivity;
            float joyX_d = (abs(joyX) > tuningParams.joystickDeadzone) ? joyX : 0.0f;
            float targetJoyX_expo = (1.0f - tuningParams.expoJoystick) * joyX_d + tuningParams.expoJoystick * pow(joyX_d, 3);
            float finalJoyX = targetJoyX_expo * tuningParams.joystickSensitivity;
            if (controlFlags.speedModeEnabled) {
                joystickTargetSpeed = finalJoyY * tuningParams.maxSpeedJoystick;
            } else {
                joystickTargetAngle = finalJoyY * tuningParams.joystickAngleSensitivity;
            }
            joystickTurnComponent = finalJoyX * (PWM_MAX_VALUE * tuningParams.turnFactor);
        }

        float speedSetpoint = 0.0f, angleContribution = 0.0f;
        float turnComponent = joystickTurnComponent;
        telemetry_target_speed = 0.0f;

        RobotState nextState = currentState;

        if (currentState != CALIBRATING_ZERO && currentState != GA_TRIAL) {
            if (isJoystickMoving) {
                nextState = BALANCING;
                speedSetpoint = joystickTargetSpeed;
                angleContribution = joystickTargetAngle;
            } else {
                switch (currentState) {
                    case IDLE:
                        if (controlFlags.balancingEnabled) {
                            nextState = controlFlags.holdPositionEnabled ? HOLDING_POSITION : BALANCING;
                        }
                        break;
                    case BALANCING:
                        if (controlFlags.holdPositionEnabled) {
                            nextState = HOLDING_POSITION;
                        } else if (!controlFlags.balancingEnabled) {
                            nextState = IDLE;
                        }
                        break;
                    case HOLDING_POSITION:
                        if (!controlFlags.holdPositionEnabled || !controlFlags.balancingEnabled) {
                            nextState = BALANCING;
                        } else {
                            speedSetpoint = positionPID.compute(positionSetpoint, currentPosition, dt);
                        }
                        break;
                    case AUTONOMOUS_MOVE:
                        speedSetpoint = positionPID.compute(targetPosition, currentPosition, dt);
                        if (abs(targetPosition - currentPosition) < positionPID.deadband && abs(actualSpeed) < speedPID.deadband * 2) {
                            nextState = HOLDING_POSITION;
                        }
                        break;
                    case AUTONOMOUS_ROTATE:
                        turnComponent = -rotationPID.compute(targetRotationDiff, (currentPosR - currentPosL), dt);
                        if (abs(targetRotationDiff - (currentPosR - currentPosL)) < 50 && abs(actualSpeed) < speedPID.deadband) {
                            nextState = HOLDING_POSITION;
                        }
                        break;
                    case AUTONOMOUS_SPEED_RUN:
                        speedSetpoint = targetSpeed;
                        if (abs(currentPosition - initialTestPosition) >= abs(targetPosition - initialTestPosition)) {
                            nextState = HOLDING_POSITION;
                        }
                        break;
                    case AUTONOMOUS_POSITION_RECOVERY:
                        speedSetpoint = positionPID.compute(initialTestPosition, currentPosition, dt);
                        if ((millis() > positionRecoveryTimeout) || (abs(initialTestPosition - currentPosition) < positionPID.deadband && abs(actualSpeed) < speedPID.deadband * 2)) {
                            nextState = HOLDING_POSITION;
                        }
                        break;
                }
            }
        }

        if (nextState != currentState) {
            transitionToState(nextState);
        }

        telemetry_target_speed = speedSetpoint;

        bool useSpeedPID = (currentState != BALANCING && currentState != IDLE && currentState != GA_TRIAL) || (currentState == BALANCING && isJoystickMoving && controlFlags.speedModeEnabled);
        if (useSpeedPID) {
            angleContribution += speedPID.compute(speedSetpoint, actualSpeed, dt);
        }
        finalTargetAngle = baseTargetAngleTrim + angleContribution;
        bool shouldBeIdle = (abs(actualSpeed) < speedPID.deadband) && (currentState != AUTONOMOUS_MOVE) && (currentState != AUTONOMOUS_SPEED_RUN);
        balancePID.setIdle(shouldBeIdle);

        if (controlFlags.balancingEnabled && !controlFlags.emergencyStop) {
            float balance_output = balancePID.compute(finalTargetAngle, (pitch - angleOffset), dt);
            telemetry_balance_output = balance_output;
            float powerL = -balance_output + turnComponent;
            float powerR = -balance_output - turnComponent;
            setMotorPower(powerL, powerR);
        } else {
            stopAllMotors();
        }

        telemetry_pitch = pitch - angleOffset;
        telemetry_yaw = normalizeAngle(yaw);
        telemetry_roll = roll - rollOffset;
        telemetry_actual_speed = actualSpeed;
        telemetry_encoder_left = currentPosL;
        telemetry_encoder_right = currentPosR;

        if (millis() - last3dTelemetryTime > 50) {
            send3dTelemetry();
            last3dTelemetryTime = millis();
        }
        telemetry_loop_time_micros.store(micros() - loopStartTime, std::memory_order_relaxed);
        vTaskDelayUntil(&xLastWakeTime, LOOP_INTERVAL_TICKS);
    }
}

void CommunicationManagerTask(void* pvParameters) {
    printAndLog("info", "Manager Komunikacji uruchomiony.");
    static String messageBuffer = "";
    char rxFragment[256];

    for (;;) {
        if (xQueueReceive(bleRxQueue, &rxFragment, pdMS_TO_TICKS(10))) {
            messageBuffer += rxFragment;
            int newlineIndex;
            while ((newlineIndex = messageBuffer.indexOf('\n')) != -1) {
                String completeMessage = messageBuffer.substring(0, newlineIndex);
                messageBuffer.remove(0, newlineIndex + 1);
                if (completeMessage.length() == 0)
                    continue;

                globalJsonDoc.clear();
                DeserializationError error = deserializeJson(globalJsonDoc, completeMessage);
                if (error == DeserializationError::Ok) {
                    JsonObject doc_obj = globalJsonDoc.as<JsonObject>();
                    if (!doc_obj.containsKey("type"))
                        continue;
                    const char* type = doc_obj["type"];

                    if (strcmp(type, "execute_balance_step_response") == 0 && doc_obj.containsKey("angle")) {
                        if (currentState == BALANCING || currentState == HOLDING_POSITION) {
                            baseTargetAngleTrim = doc_obj["angle"];
                            currentTrialId = millis();
                            currentTrialType = TRIAL_BALANCE;
                            currentTrialStartMs = millis();
                            sendAck("execute_balance_step_response", true);
                            vTaskDelay(pdMS_TO_TICKS(3000));
                            baseTargetAngleTrim = 0.0;
                            currentTrialType = TRIAL_NONE;
                        } else {
                            sendAck("execute_balance_step_response", false, "Robot nie balansuje");
                        }
                    } else if (strcmp(type, "execute_position_test_impulse") == 0 && doc_obj.containsKey("impulse_power")) {
                        if (currentState == HOLDING_POSITION) {
                            resetAllPids();
                            int impulse_power = doc_obj["impulse_power"];
                            initialTestPosition = (encoder_L.position.load() + encoder_R.position.load()) / 2;
                            positionSetpoint = initialTestPosition;
                            setMotorPower((float)impulse_power, (float)impulse_power);
                            vTaskDelay(pdMS_TO_TICKS(150));
                            stopAllMotors();
                            positionRecoveryTimeout = millis() + 3000;
                            currentTrialId = millis();
                            currentTrialType = TRIAL_POSITION;
                            currentTrialStartMs = millis();
                            transitionToState(AUTONOMOUS_POSITION_RECOVERY);
                            sendAck("execute_position_test_impulse", true);
                        } else {
                            sendAck("execute_position_test_impulse", false, "Robot nie jest w trybie HOLD_POSITION");
                        }
                    } else if (strcmp(type, "execute_speed_test_run") == 0 && doc_obj.containsKey("distance_cm") && doc_obj.containsKey("speed_cmps")) {
                        if (currentState == HOLDING_POSITION) {
                            resetAllPids();
                            float distance_cm = doc_obj["distance_cm"];
                            float speed_cmps = doc_obj["speed_cmps"];
                            initialTestPosition = (encoder_L.position.load() + encoder_R.position.load()) / 2;
                            targetPosition = initialTestPosition + (long)(distance_cm * internal_impulsesPerCm);
                            targetSpeed = speed_cmps * internal_impulsesPerCm;
                            currentTrialId = millis();
                            currentTrialType = TRIAL_SPEED;
                            currentTrialStartMs = millis();
                            transitionToState(AUTONOMOUS_SPEED_RUN);
                            sendAck("execute_speed_test_run", true);
                        } else {
                            sendAck("execute_speed_test_run", false, "Robot nie jest w trybie HOLD_POSITION");
                        }
                    } else if (strcmp(type, "start_ga_session") == 0) {
                        startGaSession();
                        sendAck("start_ga_session", true);
                    } else if (strcmp(type, "run_ga_trial") == 0 && doc_obj.containsKey("kp") && doc_obj.containsKey("kd")) {
                        runGaTrial(doc_obj["kp"], doc_obj["kd"]);
                    } else if (strcmp(type, "cancel_ga_session") == 0) {
                        cancelGaSession();
                    // --- [USUNIETO] Obsluga komend Z-N ---
                    } else if (strcmp(type, "joystick") == 0) {
                        if (doc_obj.containsKey("x") && doc_obj.containsKey("y")) {
                            joystickX.store(doc_obj["x"], std::memory_order_relaxed);
                            joystickY.store(doc_obj["y"], std::memory_order_relaxed);
                            joystickActive = (abs(joystickX.load(std::memory_order_relaxed)) > 0.01 || abs(joystickY.load(std::memory_order_relaxed)) > 0.01);
                            lastJoystickTime = millis();
                        }
                    } else if (strcmp(type, "speed_mode_toggle") == 0 && doc_obj.containsKey("enabled")) {
                        controlFlags.speedModeEnabled = doc_obj["enabled"];
                        sendAck("speed_mode_toggle", true);
                    } else if (strcmp(type, "hold_position_toggle") == 0 && doc_obj.containsKey("enabled")) {
                        controlFlags.holdPositionEnabled = doc_obj["enabled"];
                        sendAck("hold_position_toggle", true);
                    } else if (strcmp(type, "request_full_config") == 0) {
                        sendFullConfiguration();
                    } else if (strcmp(type, "balance_toggle") == 0 && doc_obj.containsKey("enabled")) {
                        controlFlags.balancingEnabled = doc_obj["enabled"];
                        if (controlFlags.balancingEnabled) {
                            controlFlags.emergencyStop = false;
                            resetAllPids();
                        } else {
                            transitionToState(IDLE);
                            stopAllMotors();
                        }
                        sendAck("balance_toggle", true);
                    } else if (strcmp(type, "execute_move") == 0 && doc_obj.containsKey("distance_cm")) {
                        if (controlFlags.balancingEnabled) {
                            resetAllPids();
                            float distance_cm = doc_obj["distance_cm"];
                            targetPosition = ((encoder_L.position.load() + encoder_R.position.load()) / 2) + (long)(distance_cm * internal_impulsesPerCm);
                            transitionToState(AUTONOMOUS_MOVE);
                            sendAck("execute_move", true);
                        }
                    } else if (strcmp(type, "execute_rotate") == 0 && doc_obj.containsKey("angle_deg")) {
                        if (controlFlags.balancingEnabled) {
                            resetAllPids();
                            float angle_deg = doc_obj["angle_deg"];
                            targetRotationDiff = (encoder_R.position.load() - encoder_L.position.load()) + (long)(angle_deg * internal_impulsesPerDegree);
                            transitionToState(AUTONOMOUS_ROTATE);
                            sendAck("execute_rotate", true);
                        }
                    } else if (strcmp(type, "command_stop") == 0) {
                        if (currentState == AUTONOMOUS_MOVE || currentState == AUTONOMOUS_ROTATE || currentState == AUTONOMOUS_SPEED_RUN || currentState == AUTONOMOUS_POSITION_RECOVERY) {
                            transitionToState(HOLDING_POSITION);
                        }
                        sendAck("command_stop", true);
                    } else if (strcmp(type, "set_param") == 0 && doc_obj.containsKey("key") && doc_obj.containsKey("value")) {
                        const char* key = doc_obj["key"];
                        float value = doc_obj["value"];
                        bool config_updated = false;
                        if (strcmp(key, "kp_b") == 0) {
                            tuningParams.Kp_b = value;
                            config_updated = true;
                        } else if (strcmp(key, "ki_b") == 0) {
                            tuningParams.Ki_b = value;
                            config_updated = true;
                        } else if (strcmp(key, "kd_b") == 0) {
                            tuningParams.Kd_b = value;
                            config_updated = true;
                        } else if (strcmp(key, "balance_pid_derivative_filter_alpha") == 0) {
                            tuningParams.balancePidDerivativeFilterAlpha = value;
                            config_updated = true;
                        } else if (strcmp(key, "joystick_angle_sensitivity") == 0) {
                            tuningParams.joystickAngleSensitivity = value;
                            config_updated = true;
                        } else if (strcmp(key, "kp_s") == 0) {
                            tuningParams.Kp_s = value;
                            config_updated = true;
                        } else if (strcmp(key, "ki_s") == 0) {
                            tuningParams.Ki_s = value;
                            config_updated = true;
                        } else if (strcmp(key, "kd_s") == 0) {
                            tuningParams.Kd_s = value;
                            config_updated = true;
                        } else if (strcmp(key, "kp_p") == 0) {
                            tuningParams.Kp_p = value;
                            config_updated = true;
                        } else if (strcmp(key, "ki_p") == 0) {
                            tuningParams.Ki_p = value;
                            config_updated = true;
                        } else if (strcmp(key, "kd_p") == 0) {
                            tuningParams.Kd_p = value;
                            config_updated = true;
                        } else if (strcmp(key, "kp_r") == 0) {
                            tuningParams.Kp_r = value;
                            config_updated = true;
                        } else if (strcmp(key, "kd_r") == 0) {
                            tuningParams.Kd_r = value;
                            config_updated = true;
                        } else if (strcmp(key, "kp_h") == 0) {
                            tuningParams.Kp_h = value;
                            config_updated = true;
                        } else if (strcmp(key, "ki_h") == 0) {
                            tuningParams.Ki_h = value;
                            config_updated = true;
                        } else if (strcmp(key, "kd_h") == 0) {
                            tuningParams.Kd_h = value;
                            config_updated = true;
                        } else if (strcmp(key, "speed_pid_deadband") == 0) {
                            tuningParams.speedPidDeadband = value;
                            config_updated = true;
                        } else if (strcmp(key, "position_pid_deadband") == 0) {
                            tuningParams.positionPidDeadband = value;
                            config_updated = true;
                        } else if (strcmp(key, "expo_joystick") == 0) {
                            tuningParams.expoJoystick = value;
                            config_updated = true;
                        } else if (strcmp(key, "max_speed_joystick") == 0) {
                            tuningParams.maxSpeedJoystick = value;
                            config_updated = true;
                        } else if (strcmp(key, "turn_factor") == 0) {
                            tuningParams.turnFactor = value;
                            config_updated = true;
                        } else if (strcmp(key, "joystick_deadzone") == 0) {
                            tuningParams.joystickDeadzone = value;
                            config_updated = true;
                        } else if (strcmp(key, "joystick_sensitivity") == 0) {
                            tuningParams.joystickSensitivity = value;
                            config_updated = true;
                        } else if (strcmp(key, "wheel_diameter_cm") == 0) {
                            tuningParams.wheelDiameterCm = value;
                            config_updated = true;
                        } else if (strcmp(key, "track_width_cm") == 0) {
                            tuningParams.trackWidthCm = value;
                            config_updated = true;
                        } else if (strcmp(key, "encoder_ppr") == 0) {
                            tuningParams.encoderPPR = value;
                            config_updated = true;
                        } else if (strcmp(key, "max_target_angle_from_speed_pid") == 0) {
                            tuningParams.maxTargetAngleFromSpeedPID = value;
                            config_updated = true;
                        } else if (strcmp(key, "max_target_speed_from_pos_pid") == 0) {
                            tuningParams.maxTargetSpeedFromPosPID = value;
                            config_updated = true;
                        } else if (strcmp(key, "min_pwm_left_fwd") == 0) {
                            tuningParams.minPwmLeftFwd = (int)value;
                            config_updated = true;
                        } else if (strcmp(key, "min_pwm_left_bwd") == 0) {
                            tuningParams.minPwmLeftBwd = (int)value;
                            config_updated = true;
                        } else if (strcmp(key, "min_pwm_right_fwd") == 0) {
                            tuningParams.minPwmRightFwd = (int)value;
                            config_updated = true;
                        } else if (strcmp(key, "min_pwm_right_bwd") == 0) {
                            tuningParams.minPwmRightBwd = (int)value;
                            config_updated = true;
                        }
                        if (config_updated) {
                            updateSystemConfiguration();
                            sendAck("set_param", true, key);
                        }
                    } else if (strcmp(type, "emergency_stop") == 0) {
                        emergencyShutdown("Przycisk E-STOP z UI");
                        sendAck("emergency_stop", true);
                    } else if (strcmp(type, "save_tunings") == 0) {
                        saveTuningsToEEPROM();
                    } else if (strcmp(type, "calibrate_mpu") == 0) {
                        calibrateMPU();
                    } else if (strcmp(type, "calibrate_zero_point") == 0) {
                        if (currentState == BALANCING || currentState == HOLDING_POSITION) {
                            printAndLog("info", "Rozpoczeto automatyczna kalibracje punktu zero (pionu)...");
                            zeroCalibStartTime = millis();
                            zeroCalibPitchSum = 0.0;
                            zeroCalibSampleCount = 0;
                            transitionToState(CALIBRATING_ZERO);
                            sendAck("calibrate_zero_point", true, "Rozpoczeto kalibracje");
                        } else {
                            sendAck("calibrate_zero_point", false, "Robot nie balansuje");
                        }
                    } else if (strcmp(type, "reset_zero") == 0) {
                        angleOffset = pitch;
                        rollOffset = roll;
                        baseTargetAngleTrim = 0.0;
                        sendAck("reset_zero", true);
                    } else if (strcmp(type, "adjust_zero") == 0) {
                        baseTargetAngleTrim += doc_obj["value"].as<int>() * ZERO_ADJUST_STEP;
                        sendAck("adjust_zero", true);
                    } else if (strcmp(type, "reset_encoders") == 0) {
                        encoder_L.position.store(0);
                        encoder_R.position.store(0);
                        sendAck("reset_encoders", true);
                    } else if (strcmp(type, "manual_tune_motor") == 0) {
                        controlFlags.directMotorControlActive = true;
                        lastDirectControlTime = millis();
                        uint8_t motorIdx = (strcmp(doc_obj["motor"], "left") == 0) ? 0 : 1;
                        int direction = (strcmp(doc_obj["direction"], "fwd") == 0) ? 1 : -1;
                        setMotorPowerRaw(motorIdx, doc_obj["pwm"].as<int>() * direction);
                    } else if (strcmp(type, "manual_tune_stop_all") == 0) {
                        stopAllMotors();
                        controlFlags.directMotorControlActive = false;
                    } else if (strcmp(type, "autotune_single_pwm") == 0) {
                        controlFlags.directMotorControlActive = true;
                        stopAllMotors();
                        vTaskDelay(pdMS_TO_TICKS(100));
                        const char* motor_str = doc_obj["motor"];
                        const char* direction_str = doc_obj["direction"];
                        int start_pwm = doc_obj["start_pwm"];
                        uint8_t motorIdx = (strcmp(motor_str, "left") == 0) ? 0 : 1;
                        int direction = (strcmp(direction_str, "fwd") == 0) ? 1 : -1;
                        int found_pwm = tuneSingleMotor(motorIdx, direction, start_pwm);

                        if (xSemaphoreTake(smallJsonMutex, pdMS_TO_TICKS(20)) == pdTRUE) {
                            smallJsonDoc.clear();
                            smallJsonDoc["type"] = "single_pwm_result";
                            JsonObject params = smallJsonDoc.createNestedObject("params");
                            params["motor"] = motor_str;
                            params["direction"] = direction_str;
                            params["value"] = found_pwm;
                            String jsonBuffer;
                            serializeJson(smallJsonDoc, jsonBuffer);

                            xSemaphoreGive(smallJsonMutex);

                            sendBleNotificationSafe(jsonBuffer);
                        }

                        controlFlags.directMotorControlActive = false;
                    }
                } else {
                    printAndLog("error", "Blad deserializacji JSON w Managerze: %s", completeMessage.c_str());
                }
            }
        }
        if (controlFlags.directMotorControlActive && (millis() - lastDirectControlTime > 2000)) {
            stopAllMotors();
            controlFlags.directMotorControlActive = false;
            printAndLog("warn", "Timeout strojenia recznego. Silniki wylaczone.");
        }
    }
}

void TelemetryTask(void* pvParameters) {
    printAndLog("info", "Zadanie Telemetrii uruchomione.");
    unsigned long lastTelemetrySendTime = 0;
    for (;;) {
        if (millis() - lastTelemetrySendTime >= TELEMETRY_INTERVAL_MS) {
            lastTelemetrySendTime = millis();
            if (bleDeviceConnected) {
                if (xSemaphoreTake(smallJsonMutex, pdMS_TO_TICKS(10)) == pdTRUE) {
                    smallJsonDoc.clear();
                    smallJsonDoc["type"] = "telemetry";
                    smallJsonDoc["pitch"] = telemetry_pitch;
                    smallJsonDoc["yaw"] = telemetry_yaw;
                    smallJsonDoc["roll"] = telemetry_roll;
                    smallJsonDoc["speed"] = telemetry_actual_speed;
                    smallJsonDoc["target_speed"] = telemetry_target_speed;
                    smallJsonDoc["robot_state"] = robotStateNames[currentState];
                    smallJsonDoc["encoder_left"] = telemetry_encoder_left;
                    smallJsonDoc["encoder_right"] = telemetry_encoder_right;
                    smallJsonDoc["output"] = telemetry_balance_output;
                    smallJsonDoc["loop_time"] = telemetry_loop_time_micros.load(std::memory_order_relaxed);
                    JsonObject states = smallJsonDoc.createNestedObject("states");
                    states["balancing"] = controlFlags.balancingEnabled;
                    states["holding_pos"] = controlFlags.holdPositionEnabled;
                    states["speed_mode"] = controlFlags.speedModeEnabled;
                    states["emergency_stop"] = controlFlags.emergencyStop;
                    if (currentTrialType != TRIAL_NONE) {
                        JsonObject tr = smallJsonDoc.createNestedObject("trial");
                        tr["id"] = (uint32_t)currentTrialId;
                        tr["elapsed_ms"] = (uint32_t)(millis() - currentTrialStartMs);
                    }
                    String jsonBuffer;
                    serializeJson(smallJsonDoc, jsonBuffer);

                    xSemaphoreGive(smallJsonMutex);

                    sendBleNotificationSafe(jsonBuffer);
                }
            }
        }
        vTaskDelay(pdMS_TO_TICKS(10));
    }
}

void send3dTelemetry() {
    if (!bleDeviceConnected)
        return;

    if (xSemaphoreTake(smallJsonMutex, pdMS_TO_TICKS(10)) == pdTRUE) {
        smallJsonDoc.clear();
        smallJsonDoc["type"] = "3d_telemetry";
        smallJsonDoc["p"] = telemetry_pitch;
        smallJsonDoc["r"] = telemetry_roll;
        smallJsonDoc["y"] = telemetry_yaw;
        smallJsonDoc["el"] = telemetry_encoder_left;
        smallJsonDoc["er"] = telemetry_encoder_right;
        String buffer;
        serializeJson(smallJsonDoc, buffer);

        xSemaphoreGive(smallJsonMutex);

        sendBleNotificationSafe(buffer);
    }
}

void BLETransmitTask(void* pvParameters) {
    printAndLog("info", "Zadanie transmisji BLE uruchomione.");
    BLEMessage msg;
    for (;;) {
        if (xQueueReceive(bleTxQueue, &msg, portMAX_DELAY)) {
            if (bleDeviceConnected && pTxCharacteristic) {
                pTxCharacteristic->setValue((uint8_t*)msg.data, msg.length);
                pTxCharacteristic->notify();

                if (msg.isFragment) {
                    vTaskDelay(pdMS_TO_TICKS(BLE_TX_FRAGMENT_DELAY_MS));
                } else {
                    vTaskDelay(pdMS_TO_TICKS(BLE_TX_DELAY_MS));
                }
            }
        }
    }
}

class MyRxCallbacks : public BLECharacteristicCallbacks {
    void onWrite(BLECharacteristic* pCharacteristic) {
        std::string rxValue = pCharacteristic->getValue();
        size_t len = rxValue.length();
        if (len > 0 && len < 256) {
            char buffer[256];
            strncpy(buffer, rxValue.c_str(), sizeof(buffer) - 1);
            buffer[sizeof(buffer) - 1] = '\0';
            xQueueSend(bleRxQueue, &buffer, 0);
        }
    }
};

class MyServerCallbacks : public BLEServerCallbacks {
    void onConnect(BLEServer* pServer) {
        bleDeviceConnected = true;
        printAndLog("info", "Klient BLE polaczony.");
    }
    void onDisconnect(BLEServer* pServer) {
        bleDeviceConnected = false;
        vTaskDelay(pdMS_TO_TICKS(100));
        pServer->getAdvertising()->start();
        printAndLog("warn", "Klient BLE rozlaczony.");
    }
};

void setupBLE() {
    BLEDevice::init(ROBOT_BLE_NAME);
    pServer = BLEDevice::createServer();
    pServer->setCallbacks(new MyServerCallbacks());
    BLEService* pService = pServer->createService(SERVICE_UUID);
    pTxCharacteristic = pService->createCharacteristic(CHARACTERISTIC_UUID_TX, BLECharacteristic::PROPERTY_NOTIFY);
    pTxCharacteristic->addDescriptor(new BLE2902());
    BLECharacteristic* pRxCharacteristic = pService->createCharacteristic(CHARACTERISTIC_UUID_RX, BLECharacteristic::PROPERTY_WRITE_NR);
    pRxCharacteristic->setCallbacks(new MyRxCallbacks());
    pService->start();
    BLEAdvertising* pAdvertising = BLEDevice::getAdvertising();
    pAdvertising->addServiceUUID(SERVICE_UUID);
    pServer->getAdvertising()->start();
    printAndLog("info", "Serwer BLE uruchomiony, robot widoczny jako '%s'", ROBOT_BLE_NAME);
}

void printAndLog(const char* level, const char* format, ...) {
    char buffer[256];
    va_list args;
    va_start(args, format);
    vsnprintf(buffer, sizeof(buffer), format, args);
    va_end(args);
    Serial.printf("[%s] %s\n", level, buffer);

    if (!bleDeviceConnected)
        return;

    if (xSemaphoreTake(smallJsonMutex, pdMS_TO_TICKS(20)) == pdTRUE) {
        smallJsonDoc.clear();
        smallJsonDoc["type"] = "log";
        smallJsonDoc["level"] = level;
        smallJsonDoc["message"] = buffer;
        String out;
        serializeJson(smallJsonDoc, out);

        xSemaphoreGive(smallJsonMutex);

        sendBleNotificationSafe(out);
    }
}

bool sendBleNotificationSafe(const String& value) {
    if (!bleDeviceConnected)
        return false;
    String valueWithNewline = value + "\n";

    if (valueWithNewline.length() > BLE_PACKET_MAX_SIZE) {
        return sendLargeBleNotificationFragmented(value);
    }
    BLEMessage msg;
    msg.length = valueWithNewline.length();
    strncpy(msg.data, valueWithNewline.c_str(), sizeof(msg.data) - 1);
    msg.data[sizeof(msg.data) - 1] = '\0';
    msg.isFragment = false; 
    return xQueueSend(bleTxQueue, &msg, 0) == pdTRUE;
}


void sendFullConfiguration() {
    if (!bleDeviceConnected) return;
    
    globalJsonDoc.clear();
    JsonObject doc = globalJsonDoc.to<JsonObject>();
    doc["type"] = "full_config";
    JsonObject states = doc.createNestedObject("states");
    states["balancing"] = controlFlags.balancingEnabled;
    states["holding_pos"] = controlFlags.holdPositionEnabled;
    states["speed_mode"] = controlFlags.speedModeEnabled;
    states["emergency_stop"] = controlFlags.emergencyStop;
    JsonObject params = doc.createNestedObject("params");
    params["wheel_diameter_cm"] = tuningParams.wheelDiameterCm;
    params["track_width_cm"] = tuningParams.trackWidthCm;
    params["encoder_ppr"] = tuningParams.encoderPPR;
    params["joystick_deadzone"] = tuningParams.joystickDeadzone;
    params["turn_factor"] = tuningParams.turnFactor;
    params["expo_joystick"] = tuningParams.expoJoystick;
    params["max_speed_joystick"] = tuningParams.maxSpeedJoystick;
    params["joystick_sensitivity"] = tuningParams.joystickSensitivity;
    params["joystick_angle_sensitivity"] = tuningParams.joystickAngleSensitivity;
    params["min_pwm_left_fwd"] = tuningParams.minPwmLeftFwd;
    params["min_pwm_left_bwd"] = tuningParams.minPwmLeftBwd;
    params["min_pwm_right_fwd"] = tuningParams.minPwmRightFwd;
    params["min_pwm_right_bwd"] = tuningParams.minPwmRightBwd;
    params["kp_b"] = tuningParams.Kp_b;
    params["ki_b"] = tuningParams.Ki_b;
    params["kd_b"] = tuningParams.Kd_b;
    params["balance_pid_derivative_filter_alpha"] = tuningParams.balancePidDerivativeFilterAlpha;
    params["kp_s"] = tuningParams.Kp_s;
    params["ki_s"] = tuningParams.Ki_s;
    params["kd_s"] = tuningParams.Kd_s;
    params["max_target_angle_from_speed_pid"] = tuningParams.maxTargetAngleFromSpeedPID;
    params["speed_pid_deadband"] = tuningParams.speedPidDeadband;
    params["kp_p"] = tuningParams.Kp_p;
    params["ki_p"] = tuningParams.Ki_p;
    params["kd_p"] = tuningParams.Kd_p;
    params["max_target_speed_from_pos_pid"] = tuningParams.maxTargetSpeedFromPosPID;
    params["position_pid_deadband"] = tuningParams.positionPidDeadband;
    params["kp_r"] = tuningParams.Kp_r;
    params["kd_r"] = tuningParams.Kd_r;
    params["kp_h"] = tuningParams.Kp_h;
    params["ki_h"] = tuningParams.Ki_h;
    params["kd_h"] = tuningParams.Kd_h;

    FragmentingPrint fragmenter;
    size_t bytes_written = serializeJson(globalJsonDoc, fragmenter);
    
    if (bytes_written > 0) {
        fragmenter.end();
        printAndLog("info", "Wyslano konfiguracje strumieniowo (%d bajtow).", bytes_written);
    } else {
        printAndLog("error", "Blad serializacji strumieniowej 'full_config'.");
    }
}

bool sendLargeBleNotificationFragmented(const String& value) {
    if (!bleDeviceConnected) return false;

    printAndLog("warn", "[STARY MECHANIZM] Uzyto sendLargeBleNotificationFragmented. Rozwaz migracje na strumien.");

    if (xSemaphoreTake(smallJsonMutex, pdMS_TO_TICKS(100)) == pdTRUE) {
        const size_t CHUNK_PAYLOAD_SIZE = 450;
        unsigned long msgId = millis();
        int totalChunks = ceil((float)value.length() / CHUNK_PAYLOAD_SIZE);
        bool allQueued = true;

        for (int i = 0; i < totalChunks; ++i) {
            int offset = i * CHUNK_PAYLOAD_SIZE;
            String chunkData = value.substring(offset, offset + CHUNK_PAYLOAD_SIZE);

            smallJsonDoc.clear();
            smallJsonDoc["type"] = "chunk";
            smallJsonDoc["id"] = msgId;
            smallJsonDoc["i"] = i;
            smallJsonDoc["total"] = totalChunks;
            smallJsonDoc["data"] = chunkData;

            String chunkBuffer;
            serializeJson(smallJsonDoc, chunkBuffer);
            String chunkWithNewline = chunkBuffer + "\n";

            BLEMessage msg;
            msg.length = chunkWithNewline.length();
            strncpy(msg.data, chunkWithNewline.c_str(), sizeof(msg.data) - 1);
            msg.data[sizeof(msg.data) - 1] = '\0';
            msg.isFragment = true;

            if (xQueueSend(bleTxQueue, &msg, pdMS_TO_TICKS(10)) != pdTRUE) {
                printAndLog("error", "Nie udalo sie zakolejkowac fragmentu %d/%d", i, totalChunks);
                allQueued = false;
                break;
            }
        }
        xSemaphoreGive(smallJsonMutex);
        return allQueued;
    }
    return false;
}

void loadDefaultSettings() {
    printAndLog("warn", "Ladowanie domyslnych ustawien (dmp v19.0).");
    tuningParams = TuningParams();
    tuningParams.Kp_b = 95.0f;
    tuningParams.Ki_b = 0.0f;
    tuningParams.Kd_b = 3.23f;
    tuningParams.balancePidDerivativeFilterAlpha = 1.0f;
    tuningParams.Kp_s = 0.05f;
    tuningParams.Ki_s = 0.0f;
    tuningParams.Kd_s = 0.0f;
    tuningParams.Kp_p = 2.5f;
    tuningParams.Ki_p = 0.0f;
    tuningParams.Kd_p = 1.0f;
    tuningParams.Kp_r = 1.0f;
    tuningParams.Kd_r = 1.0f;
    tuningParams.Kp_h = 0.8f;
    tuningParams.Ki_h = 0.0f;
    tuningParams.Kd_h = 0.1f;
    tuningParams.maxTargetAngleFromSpeedPID = 15.0f;
    tuningParams.speedPidDeadband = 5.0f;
    tuningParams.maxTargetSpeedFromPosPID = 1000.0f;
    tuningParams.positionPidDeadband = 15.0f;
    tuningParams.encoderPPR = 820.0f;
    tuningParams.wheelDiameterCm = 8.0f;
    tuningParams.trackWidthCm = 13.0f;
    tuningParams.minPwmLeftFwd = 640;
    tuningParams.minPwmLeftBwd = 640;
    tuningParams.minPwmRightFwd = 640;
    tuningParams.minPwmRightBwd = 640;
    tuningParams.joystickAngleSensitivity = 10.0f;
    tuningParams.joystickDeadzone = 0.0f;
    tuningParams.turnFactor = 0.25f;
    tuningParams.expoJoystick = 0.0f;
    tuningParams.maxSpeedJoystick = 800.0f;
    tuningParams.joystickSensitivity = 1.0f;
}

void saveTuningsToEEPROM() {
    EEPROMSettings t;
    t.magic_number = CONFIG_MAGIC_NUMBER;
    strncpy(t.version, CONFIG_VERSION, sizeof(t.version) - 1);
    t.version[sizeof(t.version) - 1] = '\0';
    t.params = tuningParams;
    t.crc = crc32_le(0, (const uint8_t*)&t, sizeof(EEPROMSettings) - sizeof(uint32_t));
    uint8_t next_config_index = (current_config_index + 1) % EEPROM_BUFFER_SIZE;
    int address = EEPROM_START_ADDRESS + next_config_index * sizeof(EEPROMSettings);
    EEPROM.put(address, t);
    if (!EEPROM.commit()) {
        printAndLog("error", "KRYTYCZNY BLAD zapisu do EEPROM (krok 1: dane)! Przerwano.");
        sendAck("save_tunings", false, "Blad zapisu danych");
        return;
    }
    current_config_index = next_config_index;
    EEPROM.write(EEPROM_START_ADDRESS + EEPROM_BUFFER_SIZE * sizeof(EEPROMSettings), current_config_index);
    if (EEPROM.commit()) {
        printAndLog("info", "Zapisano pomyslnie ustawienia w EEPROM (slot %d).", current_config_index);
        sendAck("save_tunings", true);
    } else {
        printAndLog("error", "KRYTYCZNY BLAD zapisu do EEPROM (krok 2: indeks)!");
        sendAck("save_tunings", false, "Blad zapisu indeksu");
    }
}

bool loadTuningsFromEEPROM() {
    current_config_index = EEPROM.read(EEPROM_START_ADDRESS + EEPROM_BUFFER_SIZE * sizeof(EEPROMSettings));
    if (current_config_index >= EEPROM_BUFFER_SIZE) {
        current_config_index = 0;
    }

    int latest_valid_index = -1;
    for (int i = 0; i < EEPROM_BUFFER_SIZE; ++i) {
        int index_to_check = (current_config_index - i + EEPROM_BUFFER_SIZE) % EEPROM_BUFFER_SIZE;
        int address = EEPROM_START_ADDRESS + index_to_check * sizeof(EEPROMSettings);
        EEPROMSettings t;
        EEPROM.get(address, t);
        uint32_t calculated_crc = crc32_le(0, (const uint8_t*)&t, sizeof(EEPROMSettings) - sizeof(uint32_t));
        if (t.magic_number == CONFIG_MAGIC_NUMBER && strcmp(t.version, CONFIG_VERSION) == 0 && t.crc == calculated_crc) {
            latest_valid_index = index_to_check;
            tuningParams = t.params;
            break;
        }
    }
    if (latest_valid_index != -1) {
        current_config_index = latest_valid_index;
        printAndLog("info", "Poprawnie wczytano ustawienia z EEPROM (slot %d, v%s).", current_config_index, CONFIG_VERSION);
        return true;
    } else {
        printAndLog("error", "BLAD ODCZYTU EEPROM lub niezgodna wersja. Ladowanie domyslnych.");
        loadDefaultSettings();
        return false;
    }
}

void updateSystemConfiguration() {
    balancePID.configure(tuningParams.Kp_b, tuningParams.Ki_b, tuningParams.Kd_b, -PWM_MAX_VALUE, PWM_MAX_VALUE, 500.0f, tuningParams.balancePidDerivativeFilterAlpha);
    speedPID.configure(tuningParams.Kp_s, tuningParams.Ki_s, tuningParams.Kd_s, -tuningParams.maxTargetAngleFromSpeedPID, tuningParams.maxTargetAngleFromSpeedPID, 10.0f);
    speedPID.deadband = tuningParams.speedPidDeadband;
    positionPID.configure(tuningParams.Kp_p, tuningParams.Ki_p, tuningParams.Kd_p, -tuningParams.maxTargetSpeedFromPosPID, tuningParams.maxTargetSpeedFromPosPID, 500.0f);
    positionPID.deadband = tuningParams.positionPidDeadband;
    rotationPID.configure(tuningParams.Kp_r, 0.0f, tuningParams.Kd_r, -800.0f, 800.0f, 0);
    headingPID.configure(tuningParams.Kp_h, tuningParams.Ki_h, tuningParams.Kd_h, -800.0f, 800.0f, 500.0f);
    recalculateMotionParameters();
}

void recalculateMotionParameters() {
    if (tuningParams.wheelDiameterCm > 0.0f && tuningParams.encoderPPR > 0.0f) {
        internal_impulsesPerCm = tuningParams.encoderPPR / (PI * tuningParams.wheelDiameterCm);
    } else {
        internal_impulsesPerCm = 0.0f;
    }
    if (tuningParams.trackWidthCm > 0.0f && internal_impulsesPerCm > 0.0f) {
        internal_impulsesPerDegree = (PI * tuningParams.trackWidthCm * internal_impulsesPerCm) / 360.0f;
    } else {
        internal_impulsesPerDegree = 0.0f;
    }
}

void emergencyShutdown(const char* reason) {
    if (controlFlags.emergencyStop)
        return;
    controlFlags.emergencyStop = true;
    controlFlags.balancingEnabled = false;
    controlFlags.holdPositionEnabled = false;
    transitionToState(IDLE);
    stopAllMotors();
    resetAllPids();
    timeOfFall = millis();
    printAndLog("error", "E-STOP: %s", reason);
}

void checkLiftDetection(const int16_t& ax, const int16_t& ay, const int16_t& az) {
    if (controlFlags.emergencyStop || !controlFlags.balancingEnabled) {
        liftDetectStartTime = 0;
        return;
    }
    float ax_g = (float)ax / 16384.0f;
    float ay_g = (float)ay / 16384.0f;
    float az_g = (float)az / 16384.0f;
    float magnitude = sqrt(ax_g * ax_g + ay_g * ay_g + az_g * az_g);
    if (magnitude < LIFT_DETECTION_THRESHOLD_G) {
        if (liftDetectStartTime == 0) {
            liftDetectStartTime = millis();
        } else if (millis() - liftDetectStartTime > LIFT_DETECTION_DURATION_MS) {
            emergencyShutdown("Wykryto podniesienie");
            liftDetectStartTime = 0;
        }
    } else {
        liftDetectStartTime = 0;
    }
}

void checkSafetySystems(float gyroRate) {
    if (!controlFlags.emergencyStop) {
        char reasonBuffer[64];
        if (abs(pitch - angleOffset) > CRITICAL_ANGLE_LIMIT) {
            snprintf(reasonBuffer, sizeof(reasonBuffer), "KRYTYCZNY przechyl: %.1f deg", pitch - angleOffset);
            emergencyShutdown(reasonBuffer);
            return;
        }
        if (abs(gyroRate) > CRITICAL_GYRO_LIMIT) {
            snprintf(reasonBuffer, sizeof(reasonBuffer), "KRYTYCZNA pred. katowa: %.1f deg/s", gyroRate);
            emergencyShutdown(reasonBuffer);
        }
    }
}

void autoRecovery() {
    if (!controlFlags.emergencyStop)
        return;
    if (abs(pitch - angleOffset) < 5.0 && millis() - timeOfFall > 3000) {
        printAndLog("info", "Proba odzyskania...");
        controlFlags.emergencyStop = false;
    } else if (abs(pitch - angleOffset) >= 5.0) {
        timeOfFall = millis();
    }
}

void _setSingleMotorPower(uint8_t motor_idx, int power) {
    power = constrain(power, -PWM_MAX_VALUE, PWM_MAX_VALUE);
    bool is_forward = power > 0;
    int abs_power = abs(power);
    uint8_t ch_fwd, ch_bwd;
    if (motor_idx == 0) {
        ch_fwd = LEDC_CHANNEL_L_IN2;
        ch_bwd = LEDC_CHANNEL_L_IN1;
    } else {
        if (MOTOR_R_INVERT_LOGIC) {
            ch_fwd = LEDC_CHANNEL_R_IN1;
            ch_bwd = LEDC_CHANNEL_R_IN2;
        } else {
            ch_fwd = LEDC_CHANNEL_R_IN2;
            ch_bwd = LEDC_CHANNEL_R_IN1;
        }
    }
    if (is_forward) {
        ledcWrite(ch_fwd, abs_power);
        ledcWrite(ch_bwd, 0);
    } else {
        ledcWrite(ch_bwd, abs_power);
        ledcWrite(ch_fwd, 0);
    }
}

float fmap(float x, float in_min, float in_max, float out_min, float out_max) {
    return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

float mapMotorOutput(float power, int minPwmFwd, int minPwmBwd) {
    if (abs(power) < 1.0f) {
        return 0.0f;
    }
    float absPower = abs(power);
    float sign = (power > 0) ? 1.0f : -1.0f;
    float minPwm = (power > 0) ? (float)minPwmFwd : (float)minPwmBwd;
    return sign * fmap(absPower, 1.0f, PWM_MAX_VALUE, minPwm, (float)PWM_MAX_VALUE);
}

void stopAllMotors() {
    _setSingleMotorPower(0, 0);
    _setSingleMotorPower(1, 0);
    currentLeftMotorOutput = 0.0f;
    currentRightMotorOutput = 0.0f;
}

void setMotorPower(float pwm_l, float pwm_r) {
    float l_d = constrain(pwm_l - currentLeftMotorOutput, -MAX_ACCELERATION, MAX_ACCELERATION);
    float r_d = constrain(pwm_r - currentRightMotorOutput, -MAX_ACCELERATION, MAX_ACCELERATION);
    currentLeftMotorOutput += l_d;
    currentRightMotorOutput += r_d;
    _setSingleMotorPower(0, (int)round(mapMotorOutput(currentLeftMotorOutput, tuningParams.minPwmLeftFwd, tuningParams.minPwmLeftBwd)));
    _setSingleMotorPower(1, (int)round(mapMotorOutput(currentRightMotorOutput, tuningParams.minPwmRightFwd, tuningParams.minPwmRightBwd)));
}

void setMotorPowerRaw(uint8_t motor_idx, int power) {
    _setSingleMotorPower(motor_idx, power);
}

int tuneSingleMotor(uint8_t motor_idx, int direction, int start_pwm) {
    const int MAX_TEST_PWM = 800;
    const int PWM_TUNE_MOVEMENT_THRESHOLD = 5;
    const int TEST_DURATION_MS = 50;
    for (int test_pwm = start_pwm; test_pwm < MAX_TEST_PWM; test_pwm += 2) {
        long start_pos_step = (motor_idx == 0) ? encoder_L.position.load(std::memory_order_relaxed) : encoder_R.position.load(std::memory_order_relaxed);
        setMotorPowerRaw(motor_idx, test_pwm * direction);
        vTaskDelay(pdMS_TO_TICKS(TEST_DURATION_MS));
        long current_pos = (motor_idx == 0) ? encoder_L.position.load(std::memory_order_relaxed) : encoder_R.position.load(std::memory_order_relaxed);
        setMotorPowerRaw(motor_idx, 0);
        if (abs(current_pos - start_pos_step) > PWM_TUNE_MOVEMENT_THRESHOLD) {
            vTaskDelay(pdMS_TO_TICKS(100));
            stopAllMotors();
            printAndLog("info", "Auto-strojenie PWM: znaleziono wartosc: %d", test_pwm);
            return test_pwm;
        }
        vTaskDelay(pdMS_TO_TICKS(50));
    }
    stopAllMotors();
    printAndLog("warn", "Auto-strojenie PWM: osiagnieto max wartosc (%d) bez wykrycia ruchu.", MAX_TEST_PWM);
    return MAX_TEST_PWM;
}

static void IRAM_ATTR encoder_isr_handler(void* arg) {
    EncoderState* encoder = (EncoderState*)arg;
    unsigned long now = micros();
    if (now - encoder->last_micros < ENCODER_DEBOUNCE_MICROS) {
        return;
    }
    encoder->last_micros = now;
    uint8_t stateA = gpio_get_level((gpio_num_t)encoder->pin_a);
    uint8_t stateB = gpio_get_level((gpio_num_t)encoder->pin_b);
    uint8_t currentState = (stateA << 1) | stateB;
    uint8_t lastState = encoder->prev_state;
    if (currentState != lastState) {
        if ((lastState == 0b00 && currentState == 0b01) || (lastState == 0b01 && currentState == 0b11) || (lastState == 0b11 && currentState == 0b10) || (lastState == 0b10 && currentState == 0b00)) {
            if (encoder->inverted) {
                encoder->position.fetch_sub(1, std::memory_order_relaxed);
            } else {
                encoder->position.fetch_add(1, std::memory_order_relaxed);
            }
        } else if ((lastState == 0b00 && currentState == 0b10) || (lastState == 0b10 && currentState == 0b11) || (lastState == 0b11 && currentState == 0b01) || (lastState == 0b01 && currentState == 0b00)) {
            if (encoder->inverted) {
                encoder->position.fetch_add(1, std::memory_order_relaxed);
            } else {
                encoder->position.fetch_sub(1, std::memory_order_relaxed);
            }
        }
        encoder->prev_state = currentState;
    }
}

void setupEncoders() {
    gpio_config_t io_conf;
    io_conf.intr_type = GPIO_INTR_ANYEDGE;
    io_conf.pin_bit_mask = (1ULL << ENCODER_L_A) | (1ULL << ENCODER_L_B) | (1ULL << ENCODER_R_A) | (1ULL << ENCODER_R_B);
    io_conf.mode = GPIO_MODE_INPUT;
    io_conf.pull_up_en = GPIO_PULLUP_ENABLE;
    io_conf.pull_down_en = GPIO_PULLDOWN_DISABLE;
    gpio_config(&io_conf);
    gpio_install_isr_service(0);
    gpio_isr_handler_add((gpio_num_t)ENCODER_L_A, encoder_isr_handler, (void*)&encoder_L);
    gpio_isr_handler_add((gpio_num_t)ENCODER_L_B, encoder_isr_handler, (void*)&encoder_L);
    gpio_isr_handler_add((gpio_num_t)ENCODER_R_A, encoder_isr_handler, (void*)&encoder_R);
    gpio_isr_handler_add((gpio_num_t)ENCODER_R_B, encoder_isr_handler, (void*)&encoder_R);
    encoder_L.prev_state = (gpio_get_level((gpio_num_t)ENCODER_L_A) << 1) | gpio_get_level((gpio_num_t)ENCODER_L_B);
    encoder_R.prev_state = (gpio_get_level((gpio_num_t)ENCODER_R_A) << 1) | gpio_get_level((gpio_num_t)ENCODER_R_B);
}

void setupSensors() {
    Wire.begin(MPU_SDA, MPU_SCL);
    Wire.setClock(400000);
    mpu.initialize();
    if (!mpu.testConnection()) {
        printAndLog("error", "BLAD KRYTYCZNY: Nie znaleziono MPU6050! Restart za 5s.");
        delay(5000);
        ESP.restart();
    }
    printAndLog("info", "Inicjalizacja DMP...");
    uint8_t devStatus = mpu.dmpInitialize();
    if (devStatus == 0) {
        mpu.setDMPEnabled(true);
        pinMode(MPU_INT_PIN, INPUT);
        attachInterrupt(digitalPinToInterrupt(MPU_INT_PIN), dmpDataReady, RISING);
        dmpReady = true;
        printAndLog("info", "DMP gotowy do pracy.");
    } else {
        printAndLog("error", "Blad inicjalizacji DMP (kod %d). Sprawdz polaczenia.", devStatus);
        delay(5000);
        ESP.restart();
    }
}

void setup() {
    initializeMotorPinsSafe();
    Serial.begin(115200);
    Serial.println("\n--- ROBOT PID - WERSJA 20.8 ---");
    printAndLog("info", "Piny silnikow zabezpieczone (stan LOW).");

    smallJsonMutex = xSemaphoreCreateMutex();
    if (smallJsonMutex == NULL) {
        Serial.println("[ERROR] Krytyczny blad: Nie udalo sie utworzyc muteksu dla JSON!");
    }

    bleRxQueue = xQueueCreate(10, sizeof(char[256]));
    bleTxQueue = xQueueCreate(BLE_TX_QUEUE_SIZE, sizeof(BLEMessage));
    if (bleRxQueue == NULL || bleTxQueue == NULL) {
        Serial.println("[ERROR] Krytyczny blad: Nie udalo sie utworzyc kolejek BLE!");
        ESP.restart();
    }
    EEPROM.begin(EEPROM_SIZE);
    loadTuningsFromEEPROM();
    updateSystemConfiguration();
    setupBLE();
    setupSensors();
    ledcSetup(LEDC_CHANNEL_L_IN1, PWM_FREQ, PWM_RESOLUTION);
    ledcSetup(LEDC_CHANNEL_L_IN2, PWM_FREQ, PWM_RESOLUTION);
    ledcSetup(LEDC_CHANNEL_R_IN1, PWM_FREQ, PWM_RESOLUTION);
    ledcSetup(LEDC_CHANNEL_R_IN2, PWM_FREQ, PWM_RESOLUTION);
    ledcAttachPin(MOTOR_L_IN1, LEDC_CHANNEL_L_IN1);
    ledcAttachPin(MOTOR_L_IN2, LEDC_CHANNEL_L_IN2);
    ledcAttachPin(MOTOR_R_IN1, LEDC_CHANNEL_R_IN1);
    ledcAttachPin(MOTOR_R_IN2, LEDC_CHANNEL_R_IN2);
    setupEncoders();
    printAndLog("info", "Inicjalizacja sprzetu zakonczona. Tworzenie zadan...");

    xTaskCreate(CommunicationManagerTask, "CommManagerTask", 8192, NULL, 4, NULL);
    xTaskCreate(TelemetryTask, "TelemetryTask", 4096, NULL, 3, NULL);
    xTaskCreate(ControlLoopTask, "ControlTask", 8192, NULL, configMAX_PRIORITIES - 1, NULL);
    xTaskCreate(BLETransmitTask, "BLETxTask", 5120, NULL, 5, NULL);
    printAndLog("info", "System gotowy do pracy.");
}

void loop() {
    vTaskDelay(portMAX_DELAY);
}