<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Robot LQR - Panel Sterowania v43.3 (FINAL-STABLE)</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <!-- ================================================================= -->
    <!-- === POCZATEK BLOKU BIBLIOTEKI BAYES-OPTIMIZER (BEZ ZMIAN) === -->
    <!-- ================================================================= -->
    <script>
        window.bayes = (function() {
            'use strict';
            var classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
            var createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
            var get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
            var inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be a function or null, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; };
            var possibleConstructorReturn = function (self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; };
            var slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
            var Parameter = function () { function Parameter(name, domain) { classCallCheck(this, Parameter); var _domain = slicedToArray(domain, 2), min = _domain[0], max = _domain[1]; if (min > max) { throw new Error('The first value of the domain must be smaller than the second.'); } this.name = name; this.domain = [min, max]; } return Parameter; }();
            var Optimizer$1 = function () { function Optimizer() { classCallCheck(this, Optimizer); } createClass(Optimizer, [{ key: 'ask', value: function ask() { throw new Error('The method \'ask\' must be implemented.'); } }, { key: 'tell', value: function tell() { throw new Error('The method \'tell\' must be implemented.'); } }, { key: 'getBest', value: function getBest(maximize) { var _this = this; return new Promise(function (resolve) { var values = _this.history.map(function (h) { return h.value; }); if (maximize) { var _ret = function () { var max = Math.max.apply(Math, values); resolve(_this.history.find(function (h) { return h.value === max; })); return { v: void 0 }; }(); if (typeof _ret === "object") return _ret.v; } else { var _ret2 = function () { var min = Math.min.apply(Math, values); resolve(_this.history.find(function (h) { return h.value === min; })); return { v: void 0 }; }(); if (typeof _ret2 === "object") return _ret2.v; } }); } }]); return Optimizer; }();
            var RandomOptimizer = function (_Optimizer) { inherits(RandomOptimizer, _Optimizer); function RandomOptimizer(_ref) { var space = _ref.space; classCallCheck(this, RandomOptimizer); var _this2 = possibleConstructorReturn(this, (RandomOptimizer.__proto__ || Object.getPrototypeOf(RandomOptimizer)).call(this)); _this2.space = space.map(function (s) { return new Parameter(s.name, s.domain); }); _this2.history = []; return _this2; } createClass(RandomOptimizer, [{ key: 'ask', value: function ask() { var _this3 = this; return new Promise(function (resolve) { var params = {}; _this3.space.forEach(function (s) { var name = s.name, domain = s.domain; var _domain2 = slicedToArray(domain, 2), min = _domain2[0], max = _domain2[1]; params[name] = min + (max - min) * Math.random(); }); resolve(params); }); } }, { key: 'tell', value: function tell(params, value) { var _this4 = this; return new Promise(function (resolve) { _this4.history.push({ params: params, value: value }); resolve(); }); } }]); return RandomOptimizer; }(Optimizer$1);
            var Optimizer$$1 = RandomOptimizer; var index = { Optimizer: Optimizer$$1 }; return index;
        })();
    </script>
    <!-- =============================================================== -->
    <!-- === KONIEC BLOKU BIBLIOTEKI BAYES-OPTIMIZER === -->
    <!-- =============================================================== -->


    <style>
        body { font-family: Arial, sans-serif; text-align: center; margin: 0; padding: 15px; background-color: #282c34; color: #fff; font-size: 14px; }
        h1 { color: #61dafb; font-size: 1.8em; }
        h2 { color: #61dafb; font-size: 1.4em; margin-top: 0; margin-bottom: 15px; }
        .main-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(340px, 1fr)); gap: 15px; align-items: start; max-width: 1920px; margin: auto; }
        .card { background-color: #3a3f47; border-radius: 8px; padding: 15px; box-shadow: 0 2px 6px rgba(0,0,0,0.2); }
        .info-grid, .status-grid { display: grid; grid-template-columns: auto 1fr; gap: 8px; text-align: left; font-size: 1em; margin-top: 10px; align-items: center;}
        .info-grid strong, .status-grid strong { color: #a2f279; }
        button { background-color: #61dafb; color: #282c34; border: none; padding: 8px 12px; border-radius: 5px; font-weight: bold; cursor: pointer; transition: background-color 0.3s, opacity 0.3s, box-shadow 0.2s; font-size: 0.9em; }
        button:hover { background-color: #a2f279; }
        button:disabled { background-color: #4a4f58; color: #888; cursor: not-allowed; opacity: 0.6; }
        .gamepad-flash { box-shadow: 0 0 10px 3px #a2f279 !important; }
        #emergencyStopBtn { background-color: #ff6347; color: white; width: 100%; margin-top: 15px; }
        .control-row { display: flex; align-items: center; justify-content: space-between; width: 100%; margin-top: 10px; }
        .control-label { font-size: 1.1em; font-weight: bold; }
        .switch { position: relative; display: inline-block; width: 50px; height: 28px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider.round { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ff6347; transition: .4s; border-radius: 28px; }
        .slider.round:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #a2f279; }
        input:checked + .slider:before { transform: translateX(22px); }
        input:disabled + .slider { background-color: #4a4f58; cursor: not-allowed; }
        fieldset { border: 1px solid #4a4f58; border-radius: 8px; margin-top: 15px; padding: 10px 15px; }
        legend { color: #61dafb; font-weight: bold; padding: 0 10px; font-size: 1.1em; }
        #joystickWrapper { position: relative; width: 180px; height: 180px; border-radius: 50%; background-color: #4a4f58; border: 3px solid #61dafb; margin: 15px auto; touch-action: none; }
        #joystickCanvas { width: 100%; height: 100%; display: block; }
        #chart-wrapper { position: relative; height: 320px; border-radius: 8px; overflow: hidden; background-color: #20232a; }
        #log-history { text-align: left; height: 350px; overflow-y: auto; background-color: #20232a; padding: 10px; border-radius: 8px; font-family: monospace; white-space: pre-wrap; }
        .status-indicator { width: 14px; height: 14px; border-radius: 50%; display: inline-block; }
        .status-ok { background-color: #a2f279; }
        .status-warn { background-color: #f7b731; }
        .status-error { background-color: #ff6347; }
        .status-disconnected { background-color: #888; }
        #emergency-banner { display: none; background-color: #ff6347; color: white; padding: 10px; font-weight: bold; position: fixed; top: 0; left: 0; width: 100%; z-index: 1000; }
        .angle-display { display: flex; align-items: center; justify-content: space-between; }
        .angle-indicator-wrapper { position: relative; width: 34px; height: 34px; background-color: #20232a; border-radius: 50%; border: 1px solid #61dafb; }
        .angle-indicator-needle { position: absolute; bottom: 50%; left: calc(50% - 1px); width: 2px; height: 50%; background-color: #ff6347; transform-origin: bottom center; transition: transform 0.1s linear; }
        .chart-controls { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin-top: 10px; font-size: 0.9em; }
        .chart-controls label { color: #fff; }
        .setting-container { display: grid; grid-template-columns: 1fr auto; gap: 10px; align-items: center; margin: 8px 0; }
        .setting-container label { font-size: 1em; font-weight: bold; color: #a2f279; text-align: left; }
        .numeric-input-wrapper { display: flex; align-items: center; flex-shrink: 0; }
        .numeric-input-wrapper button { background-color: #4a4f58; color: #61dafb; padding: 4px 8px; font-size: 1em; line-height: 1; min-width: 30px; }
        .numeric-input-wrapper input[type=number] { width: 90px; text-align: center; font-size: 1em; background-color: #20232a; color: #fff; border: 1px solid #61dafb; border-radius: 5px; margin: 0 4px; padding: 4px; -moz-appearance: textfield; }
        input[type=number]::-webkit-inner-spin-button, input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        .manual-tune-row { background-color: #2a2f35; padding: 10px; border-radius: 6px; margin-bottom: 12px; }
        .pwm-input-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .pwm-input-row label { font-weight: bold; color: #a2f279; }
        .pwm-button-row { display: flex; justify-content: flex-end; gap: 10px; }
        .pwm-button-row button { flex-grow: 1; max-width: 100px; }
        .test-btn { background-color: #a2f279; }
        .stop-btn { background-color: #ff6347; }
        .auto-btn { background-color: #f7b731; }
        .trim-controls { display: flex; justify-content: space-between; align-items: center; margin-top: 10px; }
        .trim-controls span { font-weight: bold; }
        .trim-controls button { min-width: 40px; font-size: 1.2em; }
        .dpad-container { display: grid; grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 1fr 1fr; gap: 5px; max-width: 150px; margin: 15px auto; }
        .dpad-btn { background-color: #61dafb; color: #282c34; border-radius: 5px; font-size: 2em; line-height: 1; padding: 5px; cursor: pointer; border: none; }
        .dpad-btn:hover { background-color: #a2f279; }
        #dpad-up { grid-column: 2; grid-row: 1; }
        #dpad-left { grid-column: 1; grid-row: 2; }
        #dpad-right { grid-column: 3; grid-row: 2; }
        #dpad-down { grid-column: 2; grid-row: 3; }
        #dpad-stop { grid-column: 2; grid-row: 2; background-color: #ff6347; color: white; }
        .dpad-input-group { display: grid; grid-template-columns: 1fr auto; gap: 10px; align-items: center; margin: 10px 0; }
        .dpad-input-group label { text-align: right; font-weight: bold; color: #a2f279; }
        .dpad-input-group input { width: 100%; box-sizing: border-box; }
        .accordion-header { background-color: #4a4f58; color: #61dafb; cursor: pointer; padding: 12px 15px; border: none; text-align: left; outline: none; font-size: 1.1em; font-weight: bold; width: 100%; border-radius: 8px; margin-top: 5px; transition: background-color: 0.3s; position: relative; }
        .accordion-header:hover { background-color: #5a6068; }
        .accordion-header.active { background-color: #61dafb; color: #282c34; border-bottom-left-radius: 0; border-bottom-right-radius: 0;}
        .accordion-header::after { content: '+'; position: absolute; right: 15px; font-size: 1.4em; transition: transform 0.3s; }
        .accordion-header.active::after { content: '-'; }
        .accordion-content { max-height: 0; overflow: hidden; transition: max-height 0.4s ease-out; background-color: #3a3f47; border-bottom-left-radius: 8px; border-bottom-right-radius: 8px;}
        .accordion-content.active { padding: 15px; }
        .pwm-info { background-color: #20232a; padding: 10px; border-radius: 5px; margin-bottom: 15px; border-left: 4px solid #61dafb; }
        .pwm-info strong { color: #a2f279; }
        .parameter-group { background-color: #20232a; padding: 12px; border-radius: 6px; margin-bottom: 12px; }
        .parameter-group h5 { color: #61dafb; margin: 0 0 8px 0; font-size: 1.1em; }
        .help-icon { display: inline-block; width: 16px; height: 16px; border-radius: 50%; background-color: #61dafb; color: #282c34; font-size: 12px; font-weight: bold; text-align: center; line-height: 16px; margin-left: 8px; cursor: pointer; user-select: none; }
        .help-text { background-color: #20232a; color: #fff; border-radius: 6px; padding: 10px; border: 1px solid #61dafb; margin-top: 8px; text-align: left; font-size: 0.9em; line-height: 1.4; width: 100%; box-sizing: border-box; max-height: 0; overflow: hidden; transition: max-height 0.3s ease-out, padding 0.3s ease-out; padding-top: 0; padding-bottom: 0; grid-column: 1 / -1; }
        .help-text.visible { max-height: 200px; padding-top: 10px; padding-bottom: 10px; }
        .sequence-step { display: grid; grid-template-columns: 1fr 100px auto; gap: 10px; align-items: center; background-color: #2a2f35; padding: 8px; border-radius: 6px; margin-bottom: 8px; transition: background-color: 0.3s; }
        .sequence-step.executing { background-color: #a2f279; color: #282c34; }
        .sequence-step.executing select, .sequence-step.executing input { color: #282c34; border-color: #282c34; }
        .sequence-step select, .sequence-step input { width: 100%; background-color: #20232a; color: #fff; border: 1px solid #61dafb; border-radius: 4px; padding: 5px; }
        .sequence-step .remove-step-btn { background-color: #ff6347; padding: 5px 10px; }
        .modal-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); z-index: 2000; display: none; }
        .modal { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: #3a3f47; border-radius: 8px; padding: 20px; z-index: 2001; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto; display: none; }
        .modal h3 { color: #61dafb; margin-top: 0; }
        .modal label { display: block; margin: 10px 0 5px; font-weight: bold; color: #a2f279; }
        .modal input, .modal select { width: 100%; padding: 8px; background-color: #20232a; color: #fff; border: 1px solid #61dafb; border-radius: 5px; box-sizing: border-box; }
        .modal button { margin: 10px 5px 0 0; }
        .close-modal { background-color: #ff6347; }
        #bopt-progress { margin: 15px 0; }
        #bopt-progress-bar { width: 100%; height: 20px; background-color: #4a4f58; border-radius: 10px; overflow: hidden; }
        #bopt-progress-fill { height: 100%; background-color: #a2f279; width: 0%; transition: width 0.3s; }
        .bopt-status { font-weight: bold; margin-top: 10px; }
        .bopt-params-display { background-color: #20232a; padding: 10px; border-radius: 5px; margin-top: 10px; text-align: left; font-family: monospace; }
        #boptBalanceSettings, #boptDriveSettings { display: none; }
        .bopt-mode-toggle { margin: 10px 0; }
        .bopt-mode-toggle input[type=radio] { margin-right: 5px; }
        #loggingControls { margin-top: 15px; }
        #loggingStatus { margin-top: 10px; font-weight: bold; color: #a2f279; }
        .preset-select { width: 100%; padding: 8px; background-color: #20232a; color: #fff; border: 1px solid #61dafb; border-radius: 5px; margin-bottom: 10px; }
        .preset-buttons { display: flex; gap: 10px; justify-content: center; margin-top: 10px; }
        .preset-buttons button { flex: 1; max-width: 120px; }
    </style>
</head>
<body>

    <h1>Robot LQR - Panel Sterowania v43.3 (FINAL-STABLE)</h1>

    <div id="emergency-banner">AWARYJNY STOP! Robot w stanie krytycznym. Naciśnij przycisk stopu!</div>

    <div class="main-grid">
        <!-- Połączenie BLE -->
        <div class="card">
            <h2>Polaczenie BLE</h2>
            <div class="status-grid">
                <span>Status:</span>
                <span id="connectionStatus">Rozlaczony</span>
                <span class="status-indicator status-disconnected" id="connectionIndicator"></span>
            </div>
            <button id="connectBleBtn">Polacz z Robotem</button>
            <button id="disconnectBleBtn" disabled>Rozlacz</button>
        </div>

        <!-- Status Robota -->
        <div class="card">
            <h2>Status Robota</h2>
            <div class="info-grid">
                <strong>Kat Pitch:</strong> <span id="pitchValue">0.0°</span>
                <div class="angle-display">
                    <span>Predkosc:</span> <span id="speedValue">0.0 cm/s</span>
                </div>
                <div class="angle-display">
                    <span>Stan:</span> <span id="robotState">Nieznany</span>
                </div>
                <div class="angle-display">
                    <span>Emergency Stop:</span> <span id="emergencyStopStatus">Nie</span>
                </div>
            </div>
            <button id="emergencyStopBtn">Awaryjny Stop!</button>
        </div>

        <!-- Sterowanie Joystickiem -->
        <div class="card">
            <h2>Sterowanie Joystickiem</h2>
            <div id="joystickWrapper">
                <canvas id="joystickCanvas" width="180" height="180"></canvas>
            </div>
            <div class="control-row">
                <label class="control-label">Wlacz Balansowanie:</label>
                <label class="switch">
                    <input type="checkbox" id="balancingSwitch">
                    <span class="slider round"></span>
                </label>
            </div>
            <fieldset>
                <legend>Ustawienia Joysticka</legend>
                <div class="setting-container">
                    <label>Expo Joysticka:</label>
                    <div class="numeric-input-wrapper">
                        <input type="number" id="expoJoystickInput" value="0.0" step="0.1" min="-1" max="1">
                        <button onclick="decrementInput('expoJoystickInput')">-</button>
                        <button onclick="incrementInput('expoJoystickInput')">+</button>
                    </div>
                </div>
                <div class="setting-container">
                    <label>Maks Predkosc Joysticka:</label>
                    <div class="numeric-input-wrapper">
                        <input type="number" id="maxSpeedJoystickInput" value="800.0" step="10" min="0" max="2000">
                        <button onclick="decrementInput('maxSpeedJoystickInput')">-</button>
                        <button onclick="incrementInput('maxSpeedJoystickInput')">+</button>
                    </div>
                </div>
                <div class="setting-container">
                    <label>Czulosc Kata Joysticka:</label>
                    <div class="numeric-input-wrapper">
                        <input type="number" id="joystickAngleSensitivityInput" value="10.0" step="1" min="1" max="50">
                        <button onclick="decrementInput('joystickAngleSensitivityInput')">-</button>
                        <button onclick="incrementInput('joystickAngleSensitivityInput')">+</button>
                    </div>
                </div>
            </fieldset>
        </div>

        <!-- Grafika -->
        <div class="card">
            <h2>Grafika Telemetrii</h2>
            <div id="chart-wrapper">
                <canvas id="telemetryChart"></canvas>
            </div>
            <div class="chart-controls">
                <label><input type="checkbox" id="showPitchCheckbox" checked> Kat Pitch</label>
                <label><input type="checkbox" id="showSpeedCheckbox" checked> Predkosc</label>
                <label><input type="checkbox" id="showLqrOutputCheckbox" checked> Wyjscie LQR</label>
                <button id="clearChartBtn">Wyczysc Wykres</button>
            </div>
        </div>

        <!-- Logi -->
        <div class="card">
            <h2>Logi Systemu</h2>
            <div id="log-history">Witaj! Czekam na polaczenie z robotem...</div>
            <button id="clearLogsBtn">Wyczysc Logi</button>
        </div>

        <!-- Ustawienia LQR -->
        <div class="card">
            <h2>Ustawienia LQR</h2>
            <div class="parameter-group">
                <h5>Parametry macierzy Q</h5>
                <div class="setting-container">
                    <label>Q1 Kat:</label>
                    <div class="numeric-input-wrapper">
                        <input type="number" id="q1AngleInput" value="100.0" step="10" min="10" max="500">
                        <button onclick="decrementInput('q1AngleInput')">-</button>
                        <button onclick="incrementInput('q1AngleInput')">+</button>
                    </div>
                </div>
                <div class="setting-container">
                    <label>Q2 Predkosc Katowa:</label>
                    <div class="numeric-input-wrapper">
                        <input type="number" id="q2AngularVelInput" value="10.0" step="1" min="1" max="100">
                        <button onclick="decrementInput('q2AngularVelInput')">-</button>
                        <button onclick="incrementInput('q2AngularVelInput')">+</button>
                    </div>
                </div>
                <div class="setting-container">
                    <label>Q3 Pozycja:</label>
                    <div class="numeric-input-wrapper">
                        <input type="number" id="q3PositionInput" value="1.0" step="0.1" min="0.1" max="10">
                        <button onclick="decrementInput('q3PositionInput')">-</button>
                        <button onclick="incrementInput('q3PositionInput')">+</button>
                    </div>
                </div>
                <div class="setting-container">
                    <label>Q4 Predkosc:</label>
                    <div class="numeric-input-wrapper">
                        <input type="number" id="q4VelocityInput" value="5.0" step="0.5" min="0.5" max="50">
                        <button onclick="decrementInput('q4VelocityInput')">-</button>
                        <button onclick="incrementInput('q4VelocityInput')">+</button>
                    </div>
                </div>
            </div>
            <div class="parameter-group">
                <h5>Parametry fizyczne i skalowanie</h5>
                <div class="setting-container">
                    <label>R Sterowanie:</label>
                    <div class="numeric-input-wrapper">
                        <input type="number" id="rControlInput" value="0.1" step="0.01" min="0.01" max="1">
                        <button onclick="decrementInput('rControlInput')">-</button>
                        <button onclick="incrementInput('rControlInput')">+</button>
                    </div>
                </div>
                <div class="setting-container">
                    <label>Skalar Wyjscia LQR:</label>
                    <div class="numeric-input-wrapper">
                        <input type="number" id="lqrOutputScalarInput" value="20.0" step="1" min="5" max="100">
                        <button onclick="decrementInput('lqrOutputScalarInput')">-</button>
                        <button onclick="incrementInput('lqrOutputScalarInput')">+</button>
                    </div>
                </div>
                <div class="setting-container">
                    <label>Srednica Kola (cm):</label>
                    <div class="numeric-input-wrapper">
                        <input type="number" id="wheelDiameterCmInput" value="8.2" step="0.1" min="5" max="20">
                        <button onclick="decrementInput('wheelDiameterCmInput')">-</button>
                        <button onclick="incrementInput('wheelDiameterCmInput')">+</button>
                    </div>
                </div>
                <div class="setting-container">
                    <label>Szerokosc Rozstawu (cm):</label>
                    <div class="numeric-input-wrapper">
                        <input type="number" id="trackWidthCmInput" value="12.5" step="0.1" min="10" max="30">
                        <button onclick="decrementInput('trackWidthCmInput')">-</button>
                        <button onclick="incrementInput('trackWidthCmInput')">+</button>
                    </div>
                </div>
            </div>
            <button id="applyLqrSettingsBtn">Zastosuj Ustawienia LQR</button>
            <button id="saveLqrToEepromBtn">Zapisz do EEPROM</button>
            <button id="loadFromEepromBtn">Wczytaj z EEPROM</button>
        </div>

        <!-- Ustawienia Pozycjonowania -->
        <div class="card">
            <h2>Ustawienia Pozycjonowania</h2>
            <fieldset>
                <legend>Kontrola Pozycji</legend>
                <div class="setting-container">
                    <label>Wzmocnienie Bledu Pozycji:</label>
                    <div class="numeric-input-wrapper">
                        <input type="number" id="positionErrorGainInput" value="2.5" step="0.1" min="0.1" max="10">
                        <button onclick="decrementInput('positionErrorGainInput')">-</button>
                        <button onclick="incrementInput('positionErrorGainInput')">+</button>
                    </div>
                </div>
                <div class="setting-container">
                    <label>Wzmocnienie Tlumiace Pozycji:</label>
                    <div class="numeric-input-wrapper">
                        <input type="number" id="positionDampingGainInput" value="0.5" step="0.1" min="0" max="5">
                        <button onclick="decrementInput('positionDampingGainInput')">-</button>
                        <button onclick="incrementInput('positionDampingGainInput')">+</button>
                    </div>
                </div>
                <div class="setting-container">
                    <label>Wzmocnienie P Predkosci:</label>
                    <div class="numeric-input-wrapper">
                        <input type="number" id="speedPGainInput" value="0.005" step="0.001" min="0" max="0.1">
                        <button onclick="decrementInput('speedPGainInput')">-</button>
                        <button onclick="incrementInput('speedPGainInput')">+</button>
                    </div>
                </div>
                <div class="setting-container">
                    <label>Maks Predkosc z Pozycji:</label>
                    <div class="numeric-input-wrapper">
                        <input type="number" id="maxSpeedFromPositionInput" value="1000.0" step="100" min="100" max="5000">
                        <button onclick="decrementInput('maxSpeedFromPositionInput')">-</button>
                        <button onclick="incrementInput('maxSpeedFromPositionInput')">+</button>
                    </div>
                </div>
                <div class="setting-container">
                    <label>Margina Trzymania Pozycji (impulsy):</label>
                    <div class="numeric-input-wrapper">
                        <input type="number" id="holdPositionMarginInput" value="15" step="1" min="5" max="50">
                        <button onclick="decrementInput('holdPositionMarginInput')">-</button>
                        <button onclick="incrementInput('holdPositionMarginInput')">+</button>
                    </div>
                </div>
            </fieldset>
            <fieldset>
                <legend>Korekcja Naglowka i Roll</legend>
                <div class="setting-container">
                    <label>Czynnik Korekcji Naglowka:</label>
                    <div class="numeric-input-wrapper">
                        <input type="number" id="headingCorrectionFactorInput" value="0.4" step="0.1" min="0" max="2">
                        <button onclick="decrementInput('headingCorrectionFactorInput')">-</button>
                        <button onclick="incrementInput('headingCorrectionFactorInput')">+</button>
                    </div>
                </div>
                <div class="setting-container">
                    <label>Wzmocnienie Korekcji Roll:</label>
                    <div class="numeric-input-wrapper">
                        <input type="number" id="rollCorrectionGainInput" value="0.5" step="0.1" min="0" max="2">
                        <button onclick="decrementInput('rollCorrectionGainInput')">-</button>
                        <button onclick="incrementInput('rollCorrectionGainInput')">+</button>
                    </div>
                </div>
                <div class="setting-container">
                    <label>Czynnik Obrotu P:</label>
                    <div class="numeric-input-wrapper">
                        <input type="number" id="rotationPGainInput" value="1.5" step="0.1" min="0.1" max="5">
                        <button onclick="decrementInput('rotationPGainInput')">-</button>
                        <button onclick="incrementInput('rotationPGainInput')">+</button>
                    </div>
                </div>
            </fieldset>
            <button id="applyPositionSettingsBtn">Zastosuj Ustawienia Pozycjonowania</button>
        </div>

        <!-- Strojenie PWM -->
        <div class="card">
            <h2>Strojenie PWM Silnikow</h2>
            <div class="pwm-info">
                <strong>Uwaga:</strong> Upewnij sie, ze robot jest uniesiony przed testami. Dostosuj minimalne PWM do płynnego startu.
            </div>
            <div class="manual-tune-row" data-motor="left" data-direction="fwd">
                <div class="pwm-input-row">
                    <label>Lewy Silnik - Przod:</label>
                    <input type="number" class="tune-input" value="632" min="0" max="1023">
                </div>
                <div class="pwm-button-row">
                    <button class="test-btn">Test</button>
                    <button class="stop-btn">Stop</button>
                    <button class="auto-btn">Auto</button>
                </div>
            </div>
            <div class="manual-tune-row" data-motor="left" data-direction="bwd">
                <div class="pwm-input-row">
                    <label>Lewy Silnik - Tyl:</label>
                    <input type="number" class="tune-input" value="634" min="0" max="1023">
                </div>
                <div class="pwm-button-row">
                    <button class="test-btn">Test</button>
                    <button class="stop-btn">Stop</button>
                    <button class="auto-btn">Auto</button>
                </div>
            </div>
            <div class="manual-tune-row" data-motor="right" data-direction="fwd">
                <div class="pwm-input-row">
                    <label>Prawy Silnik - Przod:</label>
                    <input type="number" class="tune-input" value="626" min="0" max="1023">
                </div>
                <div class="pwm-button-row">
                    <button class="test-btn">Test</button>
                    <button class="stop-btn">Stop</button>
                    <button class="auto-btn">Auto</button>
                </div>
            </div>
            <div class="manual-tune-row" data-motor="right" data-direction="bwd">
                <div class="pwm-input-row">
                    <label>Prawy Silnik - Tyl:</label>
                    <input type="number" class="tune-input" value="621" min="0" max="1023">
                </div>
                <div class="pwm-button-row">
                    <button class="test-btn">Test</button>
                    <button class="stop-btn">Stop</button>
                    <button class="auto-btn">Auto</button>
                </div>
            </div>
            <div class="setting-container">
                <label>Poczatkowe PWM do Auto-Strojenia:</label>
                <div class="numeric-input-wrapper">
                    <input type="number" id="pwmTuneStartInput" value="500" min="100" max="800">
                </div>
            </div>
            <button id="manualTuneStopAll">Stop Wszystkie Silniki</button>
            <button id="applyPwmSettingsBtn">Zastosuj PWM</button>
        </div>

        <!-- Trymowanie Kata -->
        <div class="card">
            <h2>Trymowanie Kata Bazowego</h2>
            <div class="angle-display">
                <span>Trym Kat:</span> <span id="baseTrimValue">0.0°</span>
            </div>
            <div class="trim-controls">
                <button onclick="adjustBaseTrim(-0.5)">-0.5°</button>
                <button onclick="adjustBaseTrim(-0.1)">-0.1°</button>
                <span>0.0°</span>
                <button onclick="adjustBaseTrim(0.1)">+0.1°</button>
                <button onclick="adjustBaseTrim(0.5)">+0.5°</button>
            </div>
            <button id="resetBaseTrimBtn">Reset Trymu</button>
            <button id="applyBaseTrimBtn">Zastosuj Trym</button>
        </div>

        <!-- D-Pad Sterowanie -->
        <div class="card">
            <h2>D-Pad Sterowanie</h2>
            <div class="dpad-container">
                <button class="dpad-btn" id="dpad-up" data-dpad="up">↑</button>
                <button class="dpad-btn" id="dpad-left" data-dpad="left">←</button>
                <button class="dpad-btn" id="dpad-stop" data-dpad="stop">■</button>
                <button class="dpad-btn" id="dpad-right" data-dpad="right">→</button>
                <button class="dpad-btn" id="dpad-down" data-dpad="down">↓</button>
            </div>
            <div class="dpad-input-group">
                <label>Dystans (cm):</label>
                <input type="number" id="dpadDistInput" value="10" min="1" max="100">
            </div>
            <div class="dpad-input-group">
                <label>Kat Obrotu (stopnie):</label>
                <input type="number" id="dpadAngleInput" value="30" min="1" max="180">
            </div>
        </div>

        <!-- Sekwencja Komend -->
        <button class="accordion-header" onclick="toggleAccordion(this)">Sekwencja Komend</button>
        <div class="accordion-content">
            <div id="sequence-list"></div>
            <button id="add-sequence-step-btn">Dodaj Krok</button>
            <button id="run-sequence-btn">Uruchom Sekwencje</button>
            <button id="stop-sequence-btn" disabled>Zatrzymaj Sekwencje</button>
            <button id="clear-sequence-btn">Wyczysc Sekwencje</button>
        </div>

        <!-- Optymalizacja BOPT -->
        <button class="accordion-header" onclick="toggleAccordion(this)">Optymalizacja BOPT</button>
        <div class="accordion-content">
            <div class="bopt-mode-toggle">
                <label><input type="radio" name="boptMode" value="balance" checked> Tryb Balansowania</label>
                <label><input type="radio" name="boptMode" value="drive"> Tryb Jazdy</label>
            </div>
            <div id="boptBalanceSettings">
                <div class="setting-container">
                    <label>Liczba Iteracji:</label>
                    <input type="number" id="boptIterationsInput" value="10" min="1" max="50">
                </div>
                <div class="setting-container">
                    <label>Moc Impulsu:</label>
                    <input type="number" id="boptImpulsePowerInput" value="120" min="50" max="300">
                </div>
                <label><input type="checkbox" id="boptUseImpulseTest" checked> Uzyj Testu Impulsowego</label>
            </div>
            <div id="boptDriveSettings">
                <div class="setting-container">
                    <label>Liczba Iteracji:</label>
                    <input type="number" id="boptIterationsInputDrive" value="10" min="1" max="50">
                </div>
                <div class="setting-container">
                    <label>Dystans Testu (cm):</label>
                    <input type="number" id="boptDriveDistanceInput" value="20" min="5" max="100">
                </div>
            </div>
            <div id="bopt-progress">
                <div>Postep: <span id="boptIterationCounter">0</span>/<span id="boptTotalIterations">10</span></div>
                <div id="bopt-progress-bar"><div id="bopt-progress-fill"></div></div>
                <div class="bopt-status">Najlepszy Fitness: <span id="boptBestFitnessStatus">N/A</span></div>
                <div id="bopt-current-params-display">Czekam na start...</div>
            </div>
            <button id="startBoptBtn">Uruchom BOPT</button>
            <button id="stopBoptBtn" disabled>Zatrzymaj BOPT</button>
            <div class="preset-buttons">
                <select class="preset-select" id="boptPresetSelect">
                    <option value="">Wybierz Preset</option>
                </select>
                <button id="loadBoptPresetBtn">Zaladz Preset</button>
                <button id="saveBoptPresetBtn">Zapisz Preset</button>
            </div>
        </div>

        <!-- Zbieranie Danych -->
        <button class="accordion-header" onclick="toggleAccordion(this)">Zbieranie Danych Logowania</button>
        <div class="accordion-content">
            <div id="loggingControls">
                <div class="setting-container">
                    <label>Czas Zbierania (s):</label>
                    <input type="number" id="loggingTimeInput" value="30" min="10" max="300">
                </div>
                <button id="startLoggingBtn">Rozpocznij Zbieranie</button>
                <button id="cancelLoggingBtn" style="display:none;">Anuluj Zbieranie</button>
                <div id="loggingStatus">Gotowy do zbierania.</div>
                <button id="downloadCsvBtn" disabled>Pobierz CSV</button>
            </div>
        </div>

        <!-- Mapy Gamepad -->
        <button id="open-gamepad-modal-btn">Konfiguracja Gamepada</button>
    </div>

    <!-- Modal Konfiguracji Gamepada -->
    <div id="gamepad-mapping-modal" class="modal">
        <h3>Mapowanie Przyciskow Gamepada</h3>
        <div id="gamepadMappingList">
            <!-- Dynamicznie generowane -->
        </div>
        <button id="saveGamepadMappingsBtn">Zapisz Mapy</button>
        <button class="close-modal" id="close-modal-btn">Zamknij</button>
    </div>
    <div class="modal-backdrop" onclick="document.getElementById('gamepad-mapping-modal').style.display='none'; document.querySelector('.modal-backdrop').style.display='none';"></div>

    <script>
        // Zmienne globalne
        let bleDevice = null;
        let rxCharacteristic = null;
        let telemetryChart = null;
        let chartData = {
            pitch: { data: [], label: 'Kat Pitch (°)', borderColor: '#61dafb', fill: false },
            speed: { data: [], label: 'Predkosc (cm/s)', borderColor: '#a2f279', fill: false },
            lqrOutput: { data: [], label: 'Wyjscie LQR', borderColor: '#f7b731', fill: false }
        };
        let chartConfig = {
            type: 'line',
            data: { datasets: [chartData.pitch, chartData.speed, chartData.lqrOutput] },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: { x: { display: false }, y: { beginAtZero: false } },
                plugins: { legend: { display: true } }
            }
        };
        let lastKnownRobotState = 'Nieznany';
        let loggedData = [];
        let isSequenceRunning = false;
        let currentSequenceStep = 0;
        const MAX_SEQUENCE_STEPS = 20;
        let gamepadMappings = {};
        const GAMEPAD_MAPPING_KEY = 'robot_gamepad_mappings';
        const CUSTOM_PRESET_PREFIX = 'bopt_preset_';
        let bayesianOptimizer = null;
        let isBoptRunning = false;
        let boptIterationCounter = 0;
        let boptTotalIterations = 10;
        let currentBoptParams = {};
        let lastBestBoptParams = null;
        let resolveTestResultPromise = null;
        let boptMode = 'balance'; // Domyślny tryb

        // Inicjalizacja
        document.addEventListener('DOMContentLoaded', function() {
            initChart();
            setupEventListeners();
            loadGamepadMappings();
            populatePresetSelect();
            setupManualTuneButtons();
            setupSequenceControls();
            setupDpadControls();
            setupGamepadMappingModal();
            initBoptOptimizer();
            setupBoptModeToggle();
        });

        function initChart() {
            const ctx = document.getElementById('telemetryChart').getContext('2d');
            telemetryChart = new Chart(ctx, chartConfig);
        }

        function setupEventListeners() {
            document.getElementById('connectBleBtn').addEventListener('click', connectBle);
            document.getElementById('disconnectBleBtn').addEventListener('click', disconnectBle);
            document.getElementById('emergencyStopBtn').addEventListener('click', sendEmergencyStop);
            document.getElementById('balancingSwitch').addEventListener('change', toggleBalancing);
            document.getElementById('applyLqrSettingsBtn').addEventListener('click', applyLqrSettings);
            document.getElementById('saveLqrToEepromBtn').addEventListener('click', saveToEeprom);
            document.getElementById('loadFromEepromBtn').addEventListener('click', loadFromEeprom);
            document.getElementById('applyPositionSettingsBtn').addEventListener('click', applyPositionSettings);
            document.getElementById('applyPwmSettingsBtn').addEventListener('click', applyPwmSettings);
            document.getElementById('applyBaseTrimBtn').addEventListener('click', applyBaseTrim);
            document.getElementById('resetBaseTrimBtn').addEventListener('click', resetBaseTrim);
            document.getElementById('clearChartBtn').addEventListener('click', clearChart);
            document.getElementById('clearLogsBtn').addEventListener('click', clearLogs);
            document.getElementById('startBoptBtn').addEventListener('click', startBopt);
            document.getElementById('stopBoptBtn').addEventListener('click', () => stopBOPT(true));
            document.getElementById('loadBoptPresetBtn').addEventListener('click', loadBoptPreset);
            document.getElementById('saveBoptPresetBtn').addEventListener('click', saveBoptPreset);
            document.getElementById('startLoggingBtn').addEventListener('click', startLogging);
            document.getElementById('cancelLoggingBtn').addEventListener('click', cancelLogging);
            document.getElementById('downloadCsvBtn').addEventListener('click', downloadCSV);
            document.getElementById('saveGamepadMappingsBtn').addEventListener('click', saveGamepadMappings);
        }

        // Funkcje BLE
        async function connectBle() {
            try {
                const device = await navigator.bluetooth.requestDevice({
                    filters: [{ name: 'RoboBala' }],
                    optionalServices: ['4fafc201-1fb5-459e-8fcc-c5c9c331914b']
                });
                bleDevice = device;
                bleDevice.addEventListener('gattserverdisconnected', onDisconnected);
                const server = await bleDevice.gatt.connect();
                const service = await server.getPrimaryService('4fafc201-1fb5-459e-8fcc-c5c9c331914b');
                rxCharacteristic = await service.getCharacteristic('beb5483e-36e1-4688-b7f5-ea07361b26a9');
                const txCharacteristic = await service.getCharacteristic('beb5483e-36e1-4688-b7f5-ea07361b26a8');
                txCharacteristic.addEventListener('characteristicvaluechanged', handleCharacteristicValueChanged);
                await txCharacteristic.startNotifications();
                updateConnectionStatus(true);
                addLogMessage('[UI] Polaczono z robotem via BLE.', 'success');
                await sendBleMessage({ type: 'load_from_eeprom' });
            } catch (error) {
                addLogMessage('[UI] Blad polaczenia BLE: ' + error.message, 'error');
            }
        }

        function disconnectBle() {
            if (bleDevice && bleDevice.gatt.connected) {
                bleDevice.gatt.disconnect();
            }
            updateConnectionStatus(false);
            addLogMessage('[UI] Rozlaczono z robotem.', 'warn');
        }

        function onDisconnected() {
            updateConnectionStatus(false);
            addLogMessage('[UI] Rozlaczono automatycznie.', 'warn');
        }

        function updateConnectionStatus(connected) {
            document.getElementById('connectionStatus').textContent = connected ? 'Polaczony' : 'Rozlaczony';
            const indicator = document.getElementById('connectionIndicator');
            indicator.className = 'status-indicator ' + (connected ? 'status-ok' : 'status-disconnected');
            document.getElementById('connectBleBtn').disabled = connected;
            document.getElementById('disconnectBleBtn').disabled = !connected;
            setBoptUiLock(!connected);
        }

        function handleCharacteristicValueChanged(event) {
            const value = event.target.value;
            const decoder = new TextDecoder();
            const message = decoder.decode(value.buffer).trim();
            if (message) {
                handleBleMessage(message);
            }
        }

        async function sendBleMessage(message) {
            if (!rxCharacteristic) return;
            const encoder = new TextEncoder();
            const data = encoder.encode(JSON.stringify(message) + '\n');
            await rxCharacteristic.writeValue(data);
        }

        // Obsluga Wiadomosci
        function handleBleMessage(message) {
            try {
                const doc = JSON.parse(message);
                if (doc.type === 'telemetry') {
                    handleTelemetryMessage(doc);
                } else if (doc.type === 'full_config') {
                    loadConfigToUI(doc.params);
                } else if (doc.type === 'log') {
                    addLogMessage(`[Robot] ${doc.message}`, doc.level);
                } else if (doc.type === 'ga_result') {
                    handleBoptResult(doc);
                } else if (doc.type === 'logging_finished') {
                    handleLoggingFinished(doc.points);
                }
            } catch (e) {
                console.error('Blad parsowania wiadomosci:', e);
            }
        }

        function handleTelemetryMessage(doc) {
            updateTelemetry(doc);
            if (doc.robot_state) lastKnownRobotState = doc.robot_state;
            if (doc.emergency_stop !== undefined) {
                document.getElementById('emergencyStopStatus').textContent = doc.emergency_stop ? 'Tak' : 'Nie';
                if (doc.emergency_stop) showEmergencyBanner();
            }
            checkAndExecuteNextSequenceStep(lastKnownRobotState);
        }

        function updateTelemetry(doc) {
            const now = Date.now();
            const pitch = doc.pitch || 0;
            const speed = doc.speed || 0;
            const lqrOutput = doc.lqr_output || 0;

            document.getElementById('pitchValue').textContent = pitch.toFixed(1) + '°';
            document.getElementById('speedValue').textContent = speed.toFixed(1) + ' cm/s';
            document.getElementById('robotState').textContent = doc.robot_state || 'Nieznany';

            if (document.getElementById('showPitchCheckbox').checked) {
                chartData.pitch.data.push({ x: now, y: pitch });
            }
            if (document.getElementById('showSpeedCheckbox').checked) {
                chartData.speed.data.push({ x: now, y: speed });
            }
            if (document.getElementById('showLqrOutputCheckbox').checked) {
                chartData.lqrOutput.data.push({ x: now, y: lqrOutput });
            }

            // Ogranicz dane do ostatnich 1000 punktów
            Object.values(chartData).forEach(dataset => {
                if (dataset.data.length > 1000) {
                    dataset.data.shift();
                }
            });

            telemetryChart.update('none');
        }

        function handleBoptResult(doc) {
            if (resolveTestResultPromise) {
                resolveTestResultPromise({ fitness: doc.fitness, fallen: doc.status === 'fallen' });
                resolveTestResultPromise = null;
            }
        }

        // Funkcje Sterowania
        function sendEmergencyStop() {
            sendBleMessage({ type: 'emergency_stop' });
            hideEmergencyBanner();
            addLogMessage('[UI] Wyslano awaryjny stop.', 'warn');
        }

        function toggleBalancing(checked) {
            const enabled = document.getElementById('balancingSwitch').checked;
            sendBleMessage({ type: 'toggle_balancing', enabled: enabled });
        }

        async function applyLqrSettings() {
            const params = {
                q1_angle: parseFloat(document.getElementById('q1AngleInput').value),
                q2_angular_vel: parseFloat(document.getElementById('q2AngularVelInput').value),
                q3_position: parseFloat(document.getElementById('q3PositionInput').value),
                q4_velocity: parseFloat(document.getElementById('q4VelocityInput').value),
                r_control: parseFloat(document.getElementById('rControlInput').value),
                lqr_output_scalar: parseFloat(document.getElementById('lqrOutputScalarInput').value),
                wheel_diameter_cm: parseFloat(document.getElementById('wheelDiameterCmInput').value),
                track_width_cm: parseFloat(document.getElementById('trackWidthCmInput').value)
            };
            await sendBleMessage({ type: 'lqr_update', params: params });
            addLogMessage('[UI] Zastosowano ustawienia LQR.', 'success');
        }

        async function saveToEeprom() {
            await sendBleMessage({ type: 'save_tunings' });
        }

        async function loadFromEeprom() {
            await sendBleMessage({ type: 'load_from_eeprom' });
        }

        async function applyPositionSettings() {
            const params = {
                position_error_gain: parseFloat(document.getElementById('positionErrorGainInput').value),
                position_d_gain: parseFloat(document.getElementById('positionDampingGainInput').value),
                speed_p_gain: parseFloat(document.getElementById('speedPGainInput').value),
                max_speed_from_pos: parseFloat(document.getElementById('maxSpeedFromPositionInput').value),
                hold_position_margin_pulses: parseInt(document.getElementById('holdPositionMarginInput').value),
                heading_correction_factor: parseFloat(document.getElementById('headingCorrectionFactorInput').value),
                roll_correction_gain: parseFloat(document.getElementById('rollCorrectionGainInput').value),
                rotation_p_gain: parseFloat(document.getElementById('rotationPGainInput').value)
            };
            await sendBleMessage({ type: 'calibration_update', params: params });
            addLogMessage('[UI] Zastosowano ustawienia pozycjonowania.', 'success');
        }

        async function applyPwmSettings() {
            const params = {
                min_pwm_left_fwd: parseInt(document.querySelector('[data-motor="left"][data-direction="fwd"] .tune-input').value),
                min_pwm_left_bwd: parseInt(document.querySelector('[data-motor="left"][data-direction="bwd"] .tune-input').value),
                min_pwm_right_fwd: parseInt(document.querySelector('[data-motor="right"][data-direction="fwd"] .tune-input').value),
                min_pwm_right_bwd: parseInt(document.querySelector('[data-motor="right"][data-direction="bwd"] .tune-input').value)
            };
            await sendBleMessage({ type: 'pwm_update', params: params });
            addLogMessage('[UI] Zastosowano ustawienia PWM.', 'success');
        }

        let baseTargetAngleTrim = 0.0;
        function adjustBaseTrim(delta) {
            baseTargetAngleTrim += delta;
            document.getElementById('baseTrimValue').textContent = baseTargetAngleTrim.toFixed(1) + '°';
        }

        function resetBaseTrim() {
            baseTargetAngleTrim = 0.0;
            document.getElementById('baseTrimValue').textContent = '0.0°';
        }

        async function applyBaseTrim() {
            await sendBleMessage({ type: 'set_base_trim', trim: baseTargetAngleTrim });
            addLogMessage('[UI] Zastosowano trym kata bazowego.', 'success');
        }

        function clearChart() {
            Object.values(chartData).forEach(dataset => dataset.data = []);
            telemetryChart.update('none');
        }

        function clearLogs() {
            document.getElementById('log-history').textContent = '';
        }

        function addLogMessage(message, level = 'info') {
            const logHistory = document.getElementById('log-history');
            const timestamp = new Date().toLocaleTimeString();
            logHistory.textContent += `[${timestamp}] [${level.toUpperCase()}] ${message}\n`;
            logHistory.scrollTop = logHistory.scrollHeight;
            if (level === 'error') {
                showEmergencyBanner();
            }
        }

        function showEmergencyBanner() {
            document.getElementById('emergency-banner').style.display = 'block';
        }

        function hideEmergencyBanner() {
            document.getElementById('emergency-banner').style.display = 'none';
        }

        // Joystick
        const canvas = document.getElementById('joystickCanvas');
        const ctx = canvas.getContext('2d');
        let joystickCenterX = canvas.width / 2;
        let joystickCenterY = canvas.height / 2;
        let joystickRadius = 80;
        let knobRadius = 20;
        let joystickX = 0;
        let joystickY = 0;
        let isDragging = false;

        function drawJoystick() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.beginPath();
            ctx.arc(joystickCenterX, joystickCenterY, joystickRadius, 0, 2 * Math.PI);
            ctx.fillStyle = '#4a4f58';
            ctx.fill();
            ctx.strokeStyle = '#61dafb';
            ctx.lineWidth = 3;
            ctx.stroke();

            const knobX = joystickCenterX + joystickX * joystickRadius;
            const knobY = joystickCenterY + joystickY * joystickRadius;
            ctx.beginPath();
            ctx.arc(knobX, knobY, knobRadius, 0, 2 * Math.PI);
            ctx.fillStyle = '#61dafb';
            ctx.fill();
        }

        function updateJoystick(x, y) {
            const dist = Math.sqrt(x * x + y * y);
            if (dist > 1) {
                x /= dist;
                y /= dist;
            }
            joystickX = x;
            joystickY = y;
            drawJoystick();
            if (bleDevice) {
                sendBleMessage({ type: 'joystick_input', x: x, y: y });
            }
        }

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left - joystickCenterX) / joystickRadius;
            const y = (e.clientY - rect.top - joystickCenterY) / joystickRadius;
            const dist = Math.sqrt(x * x + y * y);
            if (dist <= 1) {
                isDragging = true;
                updateJoystick(x, y);
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left - joystickCenterX) / joystickRadius;
            const y = (e.clientY - rect.top - joystickCenterY) / joystickRadius;
            updateJoystick(x, y);
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            updateJoystick(0, 0);
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = (touch.clientX - rect.left - joystickCenterX) / joystickRadius;
            const y = (touch.clientY - rect.top - joystickCenterY) / joystickRadius;
            const dist = Math.sqrt(x * x + y * y);
            if (dist <= 1) {
                isDragging = true;
                updateJoystick(x, y);
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!isDragging) return;
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = (touch.clientX - rect.left - joystickCenterX) / joystickRadius;
            const y = (touch.clientY - rect.top - joystickCenterY) / joystickRadius;
            updateJoystick(x, y);
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            isDragging = false;
            updateJoystick(0, 0);
        });

        drawJoystick();

        // Funkcje pomocnicze
        function decrementInput(id) {
            const input = document.getElementById(id);
            input.value = (parseFloat(input.value) - parseFloat(input.step || 1)).toFixed(input.step ? input.step.toString().split('.')[1]?.length || 0 : 0);
        }

        function incrementInput(id) {
            const input = document.getElementById(id);
            input.value = (parseFloat(input.value) + parseFloat(input.step || 1)).toFixed(input.step ? input.step.toString().split('.')[1]?.length || 0 : 0);
        }

        function toggleAccordion(header) {
            const content = header.nextElementSibling;
            const isActive = content.classList.contains('active');
            document.querySelectorAll('.accordion-content').forEach(c => c.classList.remove('active'));
            document.querySelectorAll('.accordion-header').forEach(h => h.classList.remove('active'));
            if (!isActive) {
                content.classList.add('active');
                header.classList.add('active');
            }
            updateAccordionHeight(content);
        }

        function updateAccordionHeight(content) {
            if (content.classList.contains('active')) {
                content.style.maxHeight = content.scrollHeight + 'px';
            } else {
                content.style.maxHeight = '0';
            }
        }

        function loadConfigToUI(params) {
            document.getElementById('q1AngleInput').value = params.q1_angle || 100;
            document.getElementById('q2AngularVelInput').value = params.q2_angular_vel || 10;
            document.getElementById('q3PositionInput').value = params.q3_position || 1;
            document.getElementById('q4VelocityInput').value = params.q4_velocity || 5;
            document.getElementById('rControlInput').value = params.r_control || 0.1;
            document.getElementById('lqrOutputScalarInput').value = params.lqr_output_scalar || 20;
            document.getElementById('wheelDiameterCmInput').value = params.wheel_diameter_cm || 8.2;
            document.getElementById('trackWidthCmInput').value = params.track_width_cm || 12.5;
            document.getElementById('positionErrorGainInput').value = params.position_error_gain || 2.5;
            document.getElementById('positionDampingGainInput').value = params.position_d_gain || 0.5;
            document.getElementById('speedPGainInput').value = params.speed_p_gain || 0.005;
            document.getElementById('maxSpeedFromPositionInput').value = params.max_speed_from_pos || 1000;
            document.getElementById('holdPositionMarginInput').value = params.hold_position_margin_pulses || 15;
            document.getElementById('headingCorrectionFactorInput').value = params.heading_correction_factor || 0.4;
            document.getElementById('rollCorrectionGainInput').value = params.roll_correction_gain || 0.5;
            document.getElementById('rotationPGainInput').value = params.rotation_p_gain || 1.5;
            const leftFwdInput = document.querySelector('[data-motor="left"][data-direction="fwd"] .tune-input');
            const leftBwdInput = document.querySelector('[data-motor="left"][data-direction="bwd"] .tune-input');
            const rightFwdInput = document.querySelector('[data-motor="right"][data-direction="fwd"] .tune-input');
            const rightBwdInput = document.querySelector('[data-motor="right"][data-direction="bwd"] .tune-input');
            if (leftFwdInput) leftFwdInput.value = params.min_pwm_left_fwd || 632;
            if (leftBwdInput) leftBwdInput.value = params.min_pwm_left_bwd || 634;
            if (rightFwdInput) rightFwdInput.value = params.min_pwm_right_fwd || 626;
            if (rightBwdInput) rightBwdInput.value = params.min_pwm_right_bwd || 621;
            baseTargetAngleTrim = params.base_target_angle_trim || 0;
            document.getElementById('baseTrimValue').textContent = baseTargetAngleTrim.toFixed(1) + '°';
            addLogMessage('[UI] Zaladowano konfiguracje z robota.', 'success');
        }

        // BOPT - Poprawiona sekcja (tylko zmiany w logice, bez wpływu na wygląd)
        function initBoptOptimizer() {
            const space = [
                { name: 'q1_angle', domain: [50, 200] },
                { name: 'q2_angular_vel', domain: [5, 50] },
                { name: 'q3_position', domain: [0.5, 5] },
                { name: 'q4_velocity', domain: [1, 20] },
                { name: 'r_control', domain: [0.05, 0.5] },
                { name: 'lqr_output_scalar', domain: [10, 50] },
                { name: 'position_error_gain', domain: [1, 5] },
                { name: 'position_d_gain', domain: [0.1, 1] },
                { name: 'speed_p_gain', domain: [0.001, 0.01] }
            ];
            bayesianOptimizer = new window.bayes.Optimizer({ space: space });
        }

        function setupBoptModeToggle() {
            document.querySelectorAll('input[name="boptMode"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    boptMode = e.target.value;
                    document.getElementById('boptBalanceSettings').style.display = boptMode === 'balance' ? 'block' : 'none';
                    document.getElementById('boptDriveSettings').style.display = boptMode === 'drive' ? 'block' : 'none';
                });
            });
        }

        async function startBopt() {
            if (!bleDevice) {
                addLogMessage('[UI] Najpierw polacz z robotem.', 'error');
                return;
            }
            isBoptRunning = true;
            boptIterationCounter = 0;
            boptTotalIterations = parseInt(document.getElementById(boptMode === 'balance' ? 'boptIterationsInput' : 'boptIterationsInputDrive').value) || 10;
            document.getElementById('boptTotalIterations').textContent = boptTotalIterations;
            setBoptUiLock(true);
            addLogMessage('[UI] Rozpoczynanie optymalizacji BOPT.', 'info');
            await saveSafeParams(); // Zapisz aktualne jako safe
            runNextBoptIteration();
        }

        function runNextBoptIteration() {
            if (!isBoptRunning || boptIterationCounter >= boptTotalIterations) {
                stopBOPT(false);
                return;
            }
            const isInitialTest = boptIterationCounter === 0;
            addLogMessage(`[UI] Przygotowuję iterację ${boptIterationCounter + 1}/${boptTotalIterations}...`, 'info');
            bayesianOptimizer.ask().then(params => {
                currentBoptParams = params;
                updateBoptCurrentParamsDisplay(params);
                setTimeout(() => runBoptTest(isInitialTest), 1000); // Zwiększony timeout do 1000ms dla stabilności BLE
            }).catch(e => {
                addLogMessage('[UI] Blad w ask(): ' + e.message, 'error');
                stopBOPT(true);
            });
        }

        async function runBoptTest(isInitialTest) {
            if (!isBoptRunning) {
                addLogMessage('[UI] Test przerwany.', 'warn');
                return;
            }

            if (!isInitialTest) {
                addLogMessage(`[UI] Uruchamianie testu dla iteracji ${boptIterationCounter + 1}...`, 'info');
            }

            const isBalanceMode = boptMode === 'balance';
            let testCommand;
            
            if (isBalanceMode) {
                await sendBleMessage({ type: 'lqr_update', params: currentBoptParams });
                const useImpulse = document.getElementById('boptUseImpulseTest').checked;
                testCommand = useImpulse ? {type: 'ga_execute_impulse_and_measure'} : {type: 'ga_run_static_stability_test'};
                await sendBleMessage({ type: 'ga_set_impulse', power: parseFloat(document.getElementById('boptImpulsePowerInput').value) });
            } else {
                await sendBleMessage({ type: 'calibration_update', params: currentBoptParams });
                const distance = parseFloat(document.getElementById('boptDriveDistanceInput').value);
                testCommand = { type: 'run_drive_test', distance_cm: distance };
            }

            await new Promise(r => setTimeout(r, 100));
            await sendBleMessage(testCommand);

            const resultPromise = new Promise(resolve => { resolveTestResultPromise = resolve; });
            const result = await resultPromise; 

            if (!isBoptRunning || !result) {
                addLogMessage('[UI] Test przerwany lub anulowany.', 'warn');
                return;
            }

            addLogMessage(`[UI] Otrzymano wynik (fitness): ${result.fitness.toFixed(4)}`, 'info');
            await bayesianOptimizer.tell(currentBoptParams, result.fitness);
            
            let bestParams = null;
            let bestFitness = null;
            try {
                // POPRAWKA: Zmieniona destrukturyzacja na bezpośredni dostęp do obiektu z getBest()
                const bestObservation = await bayesianOptimizer.getBest();
                bestParams = bestObservation ? bestObservation.params : null;
                bestFitness = bestObservation ? bestObservation.value : null;

                // POPRAWKA: Sprawdź historię, jeśli pusta użyj aktualnego
                if (bayesianOptimizer.history.length === 0) {
                    addLogMessage('[UI] Brak historii – używam aktualnego wyniku.', 'warn');
                    bestParams = currentBoptParams;
                    bestFitness = result.fitness;
                }
            } catch (e) {
                // POPRAWKA: Dodana obsługa błędów w getBest
                console.error('Blad w getBest:', e);
                addLogMessage('[UI] Blad optymalizacji: ' + e.message, 'error');
                stopBOPT(true);
                return;
            }

            lastBestBoptParams = bestParams;

            if (isInitialTest) {
                addLogMessage('[UI] Test zerowy zakończony. Rozpoczynanie głównej pętli optymalizacji.', 'info');
            } else {
                 boptIterationCounter++;
            }
            
            updateBoptProgress(boptIterationCounter, boptTotalIterations, bestFitness, bestParams);
            runNextBoptIteration();
        }

        async function stopBOPT(sendCmd) {
            if (!isBoptRunning) return;
            isBoptRunning = false;
            if(resolveTestResultPromise) resolveTestResultPromise(null);
            setBoptUiLock(false);
            document.getElementById('startBoptBtn').disabled = false;
            document.getElementById('stopBoptBtn').disabled = true;
            document.getElementById('bopt-current-params-display').textContent = 'Anulowano.';

            if (sendCmd) {
                addLogMessage('[UI] Zatrzymywanie optymalizacji i przywracanie stanu...', 'info');
                await sendBleMessage({ type: 'ga_restore_safe_params' });
                await new Promise(r => setTimeout(r, 100));
                await sendBleMessage({ type: 'command_stop' });
                await new Promise(r => setTimeout(r, 100));
                await sendBleMessage({ type: 'load_from_eeprom' });
            }
        }

        function setBoptUiLock(isLocked) {
            document.querySelectorAll('button, input, select').forEach(el => {
                const parentCard = el.closest('.card');
                if (parentCard && parentCard.contains(document.getElementById('startBoptBtn'))) {
                    if (el.id !== 'stopBoptBtn' && el.id !== 'startBoptBtn') el.disabled = isLocked;
                } else {
                    if (el.id !== 'emergencyStopBtn' && el.id !== 'connectBleBtn') {
                        el.disabled = isLocked;
                    }
                }
            });
            document.getElementById('startBoptBtn').disabled = isLocked;
            document.getElementById('stopBoptBtn').disabled = !isLocked;
            document.getElementById('connectBleBtn').disabled = isLocked || !!bleDevice;
        }

        function updateBoptProgress(current, total, fitness, params) {
            const progress = (current / total) * 100;
            document.getElementById('boptIterationCounter').textContent = current;
            document.getElementById('bopt-progress-fill').style.width = progress + '%';
            document.getElementById('boptBestFitnessStatus').textContent = fitness ? fitness.toFixed(4) : 'N/A';
            if (params) {
                updateBoptCurrentParamsDisplay(params);
            }
        }

        function updateBoptCurrentParamsDisplay(params) {
            const display = document.getElementById('bopt-current-params-display');
            display.textContent = Object.entries(params)
                .map(([key, value]) => `${key}: ${value.toFixed(2)}`)
                .join(', ');
        }

        async function saveSafeParams() {
            await sendBleMessage({ type: 'ga_save_safe_params' });
        }

        async function saveBoptPreset() {
            if (!lastBestBoptParams) { addLogMessage('Brak danych do zapisu.', 'warn'); return; }
            const bestFitness = parseFloat(document.getElementById('boptBestFitnessStatus').textContent);
            const presetName = prompt("Podaj nazwę dla presetu:", `BOPT_Fit_${bestFitness.toFixed(4)}`);
            
            if (presetName && presetName.trim() !== "") {
                const isBalanceMode = boptMode === 'balance';
                let presetData = {};
                if (isBalanceMode) {
                    presetData = { q1Angle: lastBestBoptParams.q1_angle, q2AngularVel: lastBestBoptParams.q2_angular_vel, q3Position: lastBestBoptParams.q3_position || parseFloat(document.getElementById('q3PositionInput').value), q4Velocity: lastBestBoptParams.q4_velocity || parseFloat(document.getElementById('q4VelocityInput').value), rControl: lastBestBoptParams.r_control, lqrOutputScalar: lastBestBoptParams.lqr_output_scalar };
                } else {
                    presetData = { q1Angle: parseFloat(document.getElementById('q1AngleInput').value), q2AngularVel: parseFloat(document.getElementById('q2AngularVelInput').value), q3Position: parseFloat(document.getElementById('q3PositionInput').value), q4Velocity: parseFloat(document.getElementById('q4VelocityInput').value), rControl: parseFloat(document.getElementById('rControlInput').value), lqrOutputScalar: parseFloat(document.getElementById('lqrOutputScalarInput').value), positionErrorGain: lastBestBoptParams.position_error_gain, positionDampingGain: lastBestBoptParams.position_d_gain, speedPGain: lastBestBoptParams.speed_p_gain };
                }
                localStorage.setItem(CUSTOM_PRESET_PREFIX + presetName.trim(), JSON.stringify(presetData));
                addLogMessage(`[UI] Zapisano wlasny preset '${presetName.trim()}'.`, 'success');
                populatePresetSelect();
            }
        }

        function populatePresetSelect() {
            const select = document.getElementById('boptPresetSelect');
            select.innerHTML = '<option value="">Wybierz Preset</option>';
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith(CUSTOM_PRESET_PREFIX)) {
                    const option = document.createElement('option');
                    option.value = key;
                    option.textContent = key.replace(CUSTOM_PRESET_PREFIX, '');
                    select.appendChild(option);
                }
            }
        }

        async function loadBoptPreset() {
            const select = document.getElementById('boptPresetSelect');
            const key = select.value;
            if (!key) return;
            const data = JSON.parse(localStorage.getItem(key));
            if (data) {
                document.getElementById('q1AngleInput').value = data.q1Angle;
                document.getElementById('q2AngularVelInput').value = data.q2AngularVel;
                document.getElementById('q3PositionInput').value = data.q3Position;
                document.getElementById('q4VelocityInput').value = data.q4Velocity;
                document.getElementById('rControlInput').value = data.rControl;
                document.getElementById('lqrOutputScalarInput').value = data.lqrOutputScalar;
                if (data.positionErrorGain !== undefined) {
                    document.getElementById('positionErrorGainInput').value = data.positionErrorGain;
                }
                if (data.positionDampingGain !== undefined) {
                    document.getElementById('positionDampingGainInput').value = data.positionDampingGain;
                }
                if (data.speedPGain !== undefined) {
                    document.getElementById('speedPGainInput').value = data.speedPGain;
                }
                addLogMessage(`[UI] Zaladowano preset '${key.replace(CUSTOM_PRESET_PREFIX, '')}'.`, 'success');
            }
        }
        
        let loggingInterval;
        function startLogging() {
            const durationS = parseInt(document.getElementById('loggingTimeInput').value);
            if (isNaN(durationS) || durationS <= 0) {
                addLogMessage('[UI] Podaj poprawny czas zbierania danych.', 'error');
                return;
            }
            sendBleMessage({type: 'start_logging', duration_s: durationS});
            
            document.getElementById('startLoggingBtn').style.display = 'none';
            document.getElementById('cancelLoggingBtn').style.display = 'block';
            document.getElementById('downloadCsvBtn').disabled = true;
            loggedData = [];

            let timeLeft = durationS;
            const statusEl = document.getElementById('loggingStatus');
            statusEl.textContent = `Zbieram dane... (${timeLeft}s)`;
            loggingInterval = setInterval(() => {
                timeLeft--;
                statusEl.textContent = `Zbieram dane... (${timeLeft}s)`;
                if (timeLeft <= 0) clearInterval(loggingInterval);
            }, 1000);
        }
        
        function cancelLogging() {
            sendBleMessage({type: 'stop_logging'});
            clearInterval(loggingInterval);
            document.getElementById('startLoggingBtn').style.display = 'block';
            document.getElementById('cancelLoggingBtn').style.display = 'none';
            document.getElementById('loggingStatus').textContent = 'Anulowano.';
            addLogMessage('[UI] Zbieranie danych anulowane przez uzytkownika.', 'warn');
        }

        function handleLoggingFinished(points) {
            clearInterval(loggingInterval);
            document.getElementById('startLoggingBtn').style.display = 'block';
            document.getElementById('cancelLoggingBtn').style.display = 'none';
            if (points > 0) {
                document.getElementById('loggingStatus').textContent = `Zebrano ${points} punktow. Gotowe do pobrania.`;
                document.getElementById('downloadCsvBtn').disabled = false;
            } else {
                document.getElementById('loggingStatus').textContent = 'Nie zebrano zadnych danych.';
            }
        }

        function downloadCSV() {
            if (loggedData.length === 0) {
                addLogMessage('[UI] Brak danych do wyeksportowania.', 'warn');
                return;
            }
            
            let csvContent = "data:text/csv;charset=utf-8,";
            csvContent += "czas_ms,pitch,predkosc,zadana_predkosc,wyjscie_lqr\n";
            
            loggedData.forEach(rowArray => {
                let row = rowArray.join(",");
                csvContent += row + "\r\n";
            });

            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "dane_robota.csv");
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            addLogMessage('[UI] Wyeksportowano dane do pliku CSV.', 'success');
        }

        function setupManualTuneButtons() { 
            document.querySelectorAll('.manual-tune-row').forEach(row => { 
                const motor = row.dataset.motor; 
                const direction = row.dataset.direction; 
                const input = row.querySelector('.tune-input'); 
                const testBtn = row.querySelector('.test-btn'); 
                const stopBtn = row.querySelector('.stop-btn'); 
                const autoBtn = row.querySelector('.auto-btn'); 
                testBtn.addEventListener('click', () => { 
                    sendBleMessage({ type: 'manual_tune_motor', motor, direction, pwm: parseInt(input.value) }); 
                }); 
                stopBtn.addEventListener('click', () => { 
                    sendBleMessage({ type: 'manual_tune_motor', motor, direction, pwm: 0 }); 
                }); 
                autoBtn.addEventListener('click', (e) => { 
                    if (confirm("UWAGA! Upewnij sie, ze robot jest uniesiony, a kola moga sie swobodnie obracac. Kontynuowac?")) { 
                        const startValue = parseInt(document.getElementById('pwmTuneStartInput').value); 
                        sendBleMessage({ type: 'autotune_single_pwm', motor, direction, start_pwm: startValue }); 
                        e.target.disabled = true; 
                        e.target.textContent = 'Szukanie...'; 
                        addLogMessage(`[UI] Rozpoczynam auto-strojenie dla ${motor} ${direction}...`, 'info'); 
                    } 
                }); 
            }); 
            document.getElementById('manualTuneStopAll').addEventListener('click', () => { 
                sendBleMessage({ type: 'manual_tune_stop_all' }); 
            }); 
        } 

        function setupSequenceControls() { 
            document.getElementById('add-sequence-step-btn').addEventListener('click', addSequenceStep); 
            document.getElementById('run-sequence-btn').addEventListener('click', runSequence); 
            document.getElementById('stop-sequence-btn').addEventListener('click', stopSequenceExecution); 
            document.getElementById('clear-sequence-btn').addEventListener('click', clearSequence); 
        } 

        function addSequenceStep() { 
            const list = document.getElementById('sequence-list'); 
            if (list.children.length >= MAX_SEQUENCE_STEPS) return; 
            const stepDiv = document.createElement('div'); 
            stepDiv.className = 'sequence-step'; 
            stepDiv.innerHTML = ` 
                <select class="sequence-type"> 
                    <option value="move_fwd">Przod (cm)</option><option value="move_bwd">Tyl (cm)</option> 
                    <option value="rotate_r">Obrot Prawo (st.)</option><option value="rotate_l">Obrot Lewo (st.)</option> 
                </select> 
                <input type="number" class="sequence-value" value="10"> 
                <button class="remove-step-btn">&times;</button> 
            `; 
            list.appendChild(stepDiv); 
            updateAccordionHeight(list.closest('.accordion-content')); 
            stepDiv.querySelector('.remove-step-btn').addEventListener('click', () => { 
                stepDiv.remove(); 
                updateAccordionHeight(list.closest('.accordion-content')); 
            }); 
        } 

        function runSequence() { 
            if (isSequenceRunning) return; 
            if (lastKnownRobotState !== 'IDLE' && lastKnownRobotState !== 'HOLDING_POSITION') { 
                addLogMessage(`[UI] Nie mozna rozpoczac sekwencji. Robot w stanie '${lastKnownRobotState}'.`, 'error'); 
                return; 
            } 
            const steps = document.querySelectorAll('.sequence-step'); 
            if (steps.length === 0) return; 
            isSequenceRunning = true; 
            currentSequenceStep = 0; 
            updateSequenceUI(); 
            addLogMessage(`[UI] Rozpoczeto sekwencje z ${steps.length} krokow.`, 'info'); 
            executeNextSequenceStep(); 
        } 

        function stopSequenceExecution() { 
            if (!isSequenceRunning) return; 
            isSequenceRunning = false; 
            sendBleMessage({ type: 'command_stop' }); 
            updateSequenceUI(); 
            addLogMessage('[UI] Sekwencja zatrzymana.', 'warn'); 
        } 

        function clearSequence() { 
            if (isSequenceRunning) stopSequenceExecution(); 
            const list = document.getElementById('sequence-list'); 
            list.innerHTML = ''; 
            updateAccordionHeight(list.closest('.accordion-content')); 
        } 

        function updateSequenceUI() { 
            document.querySelectorAll('.sequence-step').forEach((step, index) => { 
                step.classList.toggle('executing', isSequenceRunning && index === currentSequenceStep); 
            }); 
            document.getElementById('run-sequence-btn').disabled = isSequenceRunning; 
            document.getElementById('add-sequence-step-btn').disabled = isSequenceRunning; 
            document.getElementById('clear-sequence-btn').disabled = isSequenceRunning; 
            document.getElementById('stop-sequence-btn').disabled = !isSequenceRunning; 
        } 

        function checkAndExecuteNextSequenceStep(previousState) { 
            if (!isSequenceRunning) return; 
            const isRobotIdle = lastKnownRobotState.includes('IDLE') || lastKnownRobotState.includes('HOLDING') || lastKnownRobotState.includes('GA_READY'); 
            const wasRobotWorking = previousState.includes('MOVE') || previousState.includes('ROTATE'); 
            if (isRobotIdle && wasRobotWorking) { 
                addLogMessage(`[UI] Krok ${currentSequenceStep + 1} zakonczony.`, 'info'); 
                currentSequenceStep++; 
                executeNextSequenceStep(); 
            } 
        } 

        function executeNextSequenceStep() { 
            const steps = document.querySelectorAll('.sequence-step'); 
            if (!isSequenceRunning || currentSequenceStep >= steps.length) { 
                if (isSequenceRunning) { 
                    isSequenceRunning = false; 
                    addLogMessage('[UI] Sekwencja ukonczona.', 'info'); 
                } 
                updateSequenceUI(); 
                return; 
            } 
            updateSequenceUI(); 
            const stepNode = steps[currentSequenceStep]; 
            const type = stepNode.querySelector('.sequence-type').value; 
            const value = parseFloat(stepNode.querySelector('.sequence-value').value); 
            let command = {}; 
            switch (type) { 
                case 'move_fwd': 
                    command = { type: 'execute_move', distance_cm: value }; 
                    break; 
                case 'move_bwd': 
                    command = { type: 'execute_move', distance_cm: -value }; 
                    break; 
                case 'rotate_r': 
                    command = { type: 'execute_rotate', angle_deg: value }; 
                    break; 
                case 'rotate_l': 
                    command = { type: 'execute_rotate', angle_deg: -value }; 
                    break; 
            } 
            addLogMessage(`[UI] Wysylanie kroku ${currentSequenceStep + 1}/${steps.length}: ${command.type}(${value}).`, 'info'); 
            sendBleMessage(command); 
        } 

        function setupDpadControls() { 
            document.querySelectorAll('.dpad-btn').forEach(btn => { 
                btn.addEventListener('click', (e) => { 
                    const action = e.currentTarget.dataset.dpad; 
                    if (action === 'up') 
                        sendBleMessage({ type: 'execute_move', distance_cm: parseFloat(document.getElementById('dpadDistInput').value) }); 
                    else if (action === 'down') 
                        sendBleMessage({ type: 'execute_move', distance_cm: -parseFloat(document.getElementById('dpadDistInput').value) }); 
                    else if (action === 'left') 
                        sendBleMessage({ type: 'execute_rotate', angle_deg: -parseFloat(document.getElementById('dpadAngleInput').value) }); 
                    else if (action === 'right') 
                        sendBleMessage({ type: 'execute_rotate', angle_deg: parseFloat(document.getElementById('dpadAngleInput').value) }); 
                    else if (action === 'stop') 
                        sendBleMessage({ type: 'command_stop' }); 
                }); 
            }); 
        } 

        function setupGamepadMappingModal() { 
            document.getElementById('open-gamepad-modal-btn').addEventListener('click', () => { 
                document.getElementById('gamepad-mapping-modal').style.display = 'block'; 
                document.querySelector('.modal-backdrop').style.display = 'block'; 
                updateGamepadMappingList(); 
            }); 
            document.getElementById('close-modal-btn').addEventListener('click', () => { 
                document.getElementById('gamepad-mapping-modal').style.display = 'none'; 
                document.querySelector('.modal-backdrop').style.display = 'none'; 
            }); 
        } 

        function updateGamepadMappingList() {
            const list = document.getElementById('gamepadMappingList');
            list.innerHTML = '';
            Object.entries(gamepadMappings).forEach(([action, button]) => {
                const div = document.createElement('div');
                div.innerHTML = `
                    <label>${action}:</label>
                    <select onchange="updateGamepadMapping('${action}', this.value)">
                        <option value="">Brak</option>
                        <option value="0" ${button === '0' ? 'selected' : ''}>Przycisk A</option>
                        <option value="1" ${button === '1' ? 'selected' : ''}>Przycisk B</option>
                        <!-- Dodaj więcej opcji -->
                    </select>
                `;
                list.appendChild(div);
            });
        }

        function updateGamepadMapping(action, button) {
            gamepadMappings[action] = button;
        }

        function flashElement(element) { 
            if (!element) return; 
            const target = element.tagName === 'INPUT' ? element.closest('.switch') || element.closest('.control-row') || element : element; 
            target.classList.add('gamepad-flash'); 
            setTimeout(() => target.classList.remove('gamepad-flash'), 300); 
        } 

        function loadGamepadMappings() { 
            const saved = localStorage.getItem(GAMEPAD_MAPPING_KEY); 
            gamepadMappings = saved ? JSON.parse(saved) : {}; 
        } 

        function saveGamepadMappings() { 
            localStorage.setItem(GAMEPAD_MAPPING_KEY, JSON.stringify(gamepadMappings)); 
            document.getElementById('gamepad-mapping-modal').style.display = 'none'; 
            document.querySelector('.modal-backdrop').style.display = 'none'; 
            addLogMessage('[UI] Zapisano mapy gamepada.', 'success'); 
        }

        // Obsługa Gamepada
        window.addEventListener('gamepadconnected', (e) => {
            addLogMessage(`[UI] Podłączono gamepad: ${e.gamepad.id}`, 'info');
            requestAnimationFrame(updateGamepadStatus);
        });

        function updateGamepadStatus() {
            const gamepads = navigator.getGamepads();
            if (gamepads[0]) {
                const gp = gamepads[0];
                // Mapuj przyciski i osie według gamepadMappings
                // Przykładowo: jeśli gamepadMappings['emergency'] = '0', sprawdź gp.buttons[0]
                // Wywołaj odpowiednie funkcje, np. sendEmergencyStop() i flashElement
                // Aktualizuj joystick z osi gp.axes[0], gp.axes[1]
                requestAnimationFrame(updateGamepadStatus);
            }
        }
    </script>

</body>
</html>