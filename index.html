<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>RoboBala</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/ml5@latest/dist/ml5.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; margin: 0; padding: 15px; background-color: #282c34; color: #fff; font-size: 14px; }
        h1 { color: #61dafb; font-size: 1.8em; }
        h2 { color: #61dafb; font-size: 1.4em; margin-top: 0; margin-bottom: 15px; }
        .main-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(340px, 1fr)); gap: 15px; align-items: start; max-width: 1920px; margin: auto; }
        .card { background-color: #3a3f47; border-radius: 8px; padding: 15px; box-shadow: 0 2px 6px rgba(0,0,0,0.2); border: 1px solid #4a4f58; }
        .info-grid, .status-grid { display: grid; grid-template-columns: auto 1fr; gap: 8px; text-align: left; font-size: 1em; margin-top: 10px; align-items: center;}
        .info-grid strong, .status-grid strong { color: #a2f279; }
        button { background-color: #61dafb; color: #282c34; border: none; padding: 8px 12px; border-radius: 5px; font-weight: bold; cursor: pointer; transition: background-color 0.3s, opacity 0.3s, box-shadow 0.2s; font-size: 0.9em; }
        button:hover { background-color: #a2f279; }
        button:disabled { background-color: #4a4f58; color: #888; cursor: not-allowed; opacity: 0.6; }
        .gamepad-flash { box-shadow: 0 0 10px 3px #a2f279 !important; }
        #emergencyStopBtn { background-color: #ff6347; color: white; width: 100%; margin-top: 15px; }
        .control-row { display: flex; align-items: center; justify-content: space-between; width: 100%; margin-top: 10px; }
        .control-label { font-size: 1.1em; font-weight: bold; }
        .switch { position: relative; display: inline-block; width: 50px; height: 28px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider.round { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ff6347; transition: .4s; border-radius: 28px; }
        .slider.round:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #a2f279; }
        input:checked + .slider:before { transform: translateX(22px); }
        input[type="checkbox"].slider-checkbox + .slider { background-color: #4a4f58; }
        input[type="checkbox"].slider-checkbox:checked + .slider { background-color: #a2f279; }
        input:disabled + .slider { background-color: #4a4f58; cursor: not-allowed; }
        fieldset { border: none; border-top: 1px solid #4a4f58; border-radius: 0; margin-top: 15px; padding: 10px 0; background-color: transparent; }
        legend { color: #61dafb; font-weight: bold; padding: 0; font-size: 1.0em; }
        #joystickWrapper { position: relative; width: 180px; height: 180px; border-radius: 50%; background-color: #4a4f58; border: 3px solid #61dafb; margin: 15px auto; touch-action: none; }
        #joystickCanvas { width: 100%; height: 100%; display: block; }
        #chart-wrapper { position: relative; height: 420px; border-radius: 8px; overflow: hidden; background-color: #20232a; }
    #log-history { text-align: left; overflow-y: auto; background-color: #20232a; padding: 10px; border-radius: 8px; font-family: monospace; white-space: pre-wrap; }
        /* Sta≈Ça wysoko≈õƒá otwartego panelu log√≥w + odsuniƒôcie tre≈õci, aby nie zas≈Çaniaƒá przycisk√≥w na dole (tak≈ºe na telefonie) */
        #log-card { --log-card-total: 0px; }
        #log-card.open #log-history { display:block !important; }
        /* Domy≈õlna wysoko≈õƒá zawarto≈õci log√≥w (mobile-first) */
        #log-card.open #log-history { height: 28vh; max-height: 28vh; }
        @media (min-width: 769px) {
            #log-card.open #log-history { height: 22vh; max-height: 22vh; }
        }
        /* Odsuniƒôcie ca≈Çej strony, gdy logi sƒÖ rozwiniƒôte */
        body.logs-open { padding-bottom: calc(var(--log-card-total, 0px) + 8px); }
        .status-indicator { width: 14px; height: 14px; border-radius: 50%; display: inline-block; }
        .status-ok { background-color: #a2f279; }
        .status-warn { background-color: #f7b731; }
        .status-error { background-color: #ff6347; }
        .status-disconnected { background-color: #888; }
        #emergency-banner { display: none; background-color: #ff6347; color: white; padding: 10px; font-weight: bold; position: fixed; top: 0; left: 0; width: 100%; z-index: 1000; }
        .angle-display { display: flex; align-items: center; justify-content: space-between; }
        .angle-indicator-wrapper { position: relative; width: 34px; height: 34px; background-color: #20232a; border-radius: 50%; border: 1px solid #61dafb; }
        .angle-indicator-needle { position: absolute; bottom: 50%; left: calc(50% - 1px); width: 2px; height: 50%; background-color: #ff6347; transform-origin: bottom center; transition: transform 0.1s linear; }
        .chart-controls { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin-top: 10px; font-size: 0.9em; }
        .chart-controls label { color: #fff; }
        .setting-container { display: grid; grid-template-columns: 1fr auto; gap: 10px; align-items: center; margin: 8px 0; }
        .setting-container label { font-size: 1em; font-weight: bold; color: #a2f279; text-align: left; }
        .numeric-input-wrapper { display: flex; align-items: center; flex-shrink: 0; }
        .numeric-input-wrapper button { background-color: #4a4f58; color: #61dafb; padding: 4px 8px; font-size: 1em; line-height: 1; min-width: 30px; }
        .numeric-input-wrapper input[type=number] { width: 90px; text-align: center; font-size: 1em; background-color: #20232a; color: #fff; border: 1px solid #61dafb; border-radius: 5px; margin: 0 4px; padding: 4px; -moz-appearance: textfield; appearance: none; }
        input[type=number]::-webkit-inner-spin-button, input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        .manual-tune-row { background-color: #2a2f35; padding: 10px; border-radius: 6px; margin-bottom: 12px; }
        .pwm-input-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .pwm-input-row label { font-weight: bold; color: #a2f279; }
        .pwm-button-row { display: flex; justify-content: flex-end; gap: 10px; }
        .pwm-button-row button { flex-grow: 1; max-width: 100px; }
        .test-btn { background-color: #a2f279; }
        .stop-btn { background-color: #ff6347; }
        .auto-btn { background-color: #f7b731; }
        .trim-controls { display: flex; justify-content: space-between; align-items: center; margin-top: 10px; }
        .trim-controls span { font-weight: bold; }
        .trim-controls button { min-width: 40px; font-size: 1.2em; }
        .accordion-header { background-color: #4a4f58; color: #61dafb; cursor: pointer; padding: 12px 15px; border: none; text-align: left; outline: none; font-size: 1.1em; font-weight: bold; width: 100%; border-radius: 8px; margin-top: 5px; transition: background-color 0.3s; position: relative; }
        .accordion-header:hover { background-color: #5a6068; }
        .accordion-header.active { background-color: #61dafb; color: #282c34; border-bottom-left-radius: 0; border-bottom-right-radius: 0;}
        .accordion-header::after { content: '+'; position: absolute; right: 15px; font-size: 1.4em; transition: transform 0.3s; }
        .accordion-header.active::after { content: '-'; }
    .accordion-content { max-height: 0; overflow: hidden; transition: max-height 0.4s ease-out, padding 0.2s ease-out; background-color: #3a3f47; border-bottom-left-radius: 8px; border-bottom-right-radius: 8px; padding: 0 15px; }
    .accordion-content.active { padding: 15px; }
    .accordion-content.auto-height { max-height: none !important; overflow: visible; }
    /* Minimal responsive: utrzymanie tabel wynik√≥w przewijalnych i scroll w sekcji ML */
    @media (max-width: 760px) {
        .autotune-results-container { overflow-x: auto; -webkit-overflow-scrolling: touch; }
        .autotune-results-table { min-width: 600px; }
        #ml-preview { font-size: 0.85em; }
    }
        .pwm-info { background-color: #20232a; padding: 10px; border-radius: 5px; margin-bottom: 15px; border-left: 4px solid #61dafb; }
        .pwm-info strong { color: #a2f279; }
        .parameter-group { background-color: transparent; padding: 8px 0; border-radius: 0; margin-bottom: 8px; border-left: 2px solid #61dafb; padding-left: 10px; }
        .parameter-group h5 { color: #61dafb; margin: 0 0 8px 0; font-size: 1.0em; }
        .help-icon { display: inline-block; width: 16px; height: 16px; border-radius: 50%; background-color: #61dafb; color: #282c34; font-size: 12px; font-weight: bold; text-align: center; line-height: 16px; margin-left: 8px; cursor: pointer; user-select: none; }
        .help-text { background-color: #20232a; color: #fff; border-radius: 6px; padding: 10px; border: 1px solid #61dafb; margin-top: 8px; text-align: left; font-size: 0.9em; line-height: 1.4; width: 100%; box-sizing: border-box; max-height: 0; overflow: hidden; transition: max-height 0.3s ease-out, padding 0.3s ease-out; padding-top: 0; padding-bottom: 0; grid-column: 1 / -1; }
        .help-text.visible { max-height: 200px; padding-top: 10px; padding-bottom: 10px; }
        .modal-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); z-index: 2000; display: none; justify-content: center; align-items: center; }
        .modal-content { background-color: #3a3f47; padding: 20px; border-radius: 8px; width: 90%; max-width: 500px; box-shadow: 0 5px 15px rgba(0,0,0,0.5); }
        .mapping-row { display: grid; grid-template-columns: 1fr 100px 100px; gap: 10px; align-items: center; margin-bottom: 10px; }
        .mapping-label { text-align: left; font-weight: bold; }
        .mapping-button { font-size: 0.8em; padding: 6px 8px; }
    /* Ma≈Çe przyciski pomocnicze (u≈ºywane m.in. w sekcji ML) */
    .btn-small { padding: 6px 8px; font-size: 0.85em; }
        .mapping-display { background-color: #20232a; padding: 6px; border-radius: 4px; font-family: monospace; }
        .preset-actions { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px; }
        #applySelectedPresetBtn { background-color: #a2f279; }
        #saveCurrentAsPresetBtn { background-color: #61dafb; }
        .dpad-container { display: grid; grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 1fr 1fr; gap: 5px; max-width: 150px; margin: 15px auto; }
        .dpad-btn { background-color: #61dafb; color: #282c34; border-radius: 5px; font-size: 2em; line-height: 1; padding: 5px; cursor: pointer; border: none; }
        .dpad-btn:hover { background-color: #a2f279; }
        #dpad-up { grid-column: 2; grid-row: 1; }
        #dpad-left { grid-column: 1; grid-row: 2; }
        #dpad-right { grid-column: 3; grid-row: 2; }
        #dpad-down { grid-column: 2; grid-row: 3; }
        #dpad-stop { grid-column: 2; grid-row: 2; background-color: #ff6347; color: white; }
        .dpad-input-group { display: grid; grid-template-columns: 1fr auto; gap: 10px; align-items: center; margin: 10px 0; }
        .dpad-input-group label { text-align: right; font-weight: bold; color: #a2f279; }
        .dpad-input-group input { width: 100%; box-sizing: border-box; background-color: #20232a; color: #fff; border: 1px solid #61dafb; border-radius: 5px; padding: 4px; }
        .sequence-step { display: grid; grid-template-columns: 1fr 1fr auto; gap: 10px; align-items: center; background-color: #2a2f35; padding: 8px; border-radius: 6px; margin-bottom: 8px; transition: background-color 0.3s; }
        .sequence-step.executing { background-color: #a2f279; color: #282c34; }
        .sequence-step.executing select, .sequence-step.executing input { color: #282c34; border-color: #282c34; }
        .sequence-step select, .sequence-step input { width: 100%; background-color: #20232a; color: #fff; border: 1px solid #61dafb; border-radius: 4px; padding: 5px; }
        .sequence-step .remove-step-btn { background-color: #ff6347; padding: 5px 10px; }
        .results-grid { display: grid; grid-template-columns: auto 1fr; gap: 8px 20px; margin-bottom: 15px; text-align: left;}
        .results-grid strong { color: #a2f279; }
        .test-results-panel { display: none; background-color: #20232a; padding: 12px; border-radius: 6px; margin-top: 15px; }
        .test-results-panel h5 { color: #61dafb; margin: 0 0 10px 0; text-align: left; }
        #robot3d-container { width: 100%; height: 400px; border-radius: 8px; overflow: hidden; position: relative; border: 2px solid #61dafb; }
        .robot3d-controls { display: flex; justify-content: space-between; align-items: center; margin-top: 10px; }
        .robot3d-controls button { padding: 8px 16px; background-color: #61dafb; color: #282c34; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        .robot3d-controls button:hover { background-color: #a2f279; }
        .robot3d-info { background-color: #20232a; padding: 10px; border-radius: 6px; margin-top: 10px; }
        .robot3d-metrics { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; text-align: left; }
        .robot3d-metrics strong { color: #a2f279; }

        body.tuning-active .main-grid > .card:not(#autotuning-card):not(#log-card):not(#controls-card) {
            opacity: 0.5;
            pointer-events: none;
            /* Usuniƒôto globalne blokowanie UI */
        }
        body.tuning-active #allSettings .accordion-header,
        body.tuning-active #allSettings .accordion-content,
        body.tuning-active .card:not(#autotuning-card):not(#controls-card):not(#log-card) button:not(#emergencyStopBtn) {
            opacity: 0.5;
            pointer-events: none;
        }
        /* elementy jawnie dozwolone w trybie strojenia */
        body.tuning-active #controls-card,
        body.tuning-active #autotuning-card,
        body.tuning-active #log-card {
            opacity: 1.0;
            pointer-events: auto;
        }
        /* ukrywanie konfiguracji w panelu optymalizacji podczas trwania strojenia */
        body.tuning-active .autotune-config-hide { display: none !important; }
        body.tuning-active #tuning-progress-panel { display: block !important; }
        body.ui-locked #connectBleBtn, body.ui-locked #emergencyStopBtn {
            opacity: 1.0;
            pointer-events: auto;
        }
        
        .dashboard-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; text-align: left;}
        .dashboard-item { background-color: #2a2f35; padding: 10px; border-radius: 6px; border-left: 4px solid #4a4f58; transition: border-color 0.3s; }
        .dashboard-item.warn { border-color: #f7b731; }
        .dashboard-item.error { border-color: #ff6347; }
        .dashboard-item .label { display: block; font-size: 0.85em; color: #a2f279; margin-bottom: 4px; }
        .dashboard-item .value { display: block; font-size: 1.3em; font-weight: bold; color: #61dafb; }
        .historical-metric { font-size: 0.75em; color: #999; margin-top: 2px; }
        .compass-container { position: relative; width: 60px; height: 60px; border-radius: 50%; background-color: #20232a; border: 2px solid #61dafb; margin-top: 5px; }
        .compass-needle { position: absolute; top: 10%; left: calc(50% - 2px); width: 4px; height: 40%; background-color: #ff6347; transform-origin: bottom center; transition: transform 0.2s linear; }
        .compass-cardinal { position: absolute; color: #fff; font-weight: bold; font-size: 0.8em; }
        .n { top: 2px; left: 50%; transform: translateX(-50%); }
        .e { top: 50%; right: 4px; transform: translateY(-50%); }
        .s { bottom: 2px; left: 50%; transform: translateX(-50%); }
        .w { top: 50%; left: 4px; transform: translateY(-50%); }
        
        .chart-toolbar { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin-top: 10px; }
        .chart-toolbar button { padding: 6px 10px; font-size: 0.85em; }
        .chart-cursor-info { display: flex; justify-content: space-around; margin-top: 10px; font-size: 0.9em; flex-wrap: wrap; }
        .chart-cursor-info div { text-align: center; margin: 5px; }
        .chart-cursor-info strong { color: #a2f279; }
        
        .diff-selector-row { display: flex; gap: 10px; margin-bottom: 10px; }
        .diff-selector-row select { flex-grow: 1; padding: 8px; background-color: #20232a; color: #fff; border: 1px solid #61dafb; border-radius: 4px; }
        .diff-results { text-align: left; font-family: monospace; background-color: #20232a; padding: 10px; border-radius: 4px; max-height: 300px; overflow-y: auto; }
        .diff-added { color: #a2f279; }
        .diff-removed { color: #ff6347; text-decoration: line-through; }
        .diff-changed { color: #f7b731; }

        #path-visualization-container { width: 100%; height: 200px; background-color: #20232a; border-radius: 8px; margin-top: 15px; position: relative; overflow: hidden; }
        #pathCanvas { width: 100%; height: 100%; display: block; }
        .path-legend { position: absolute; bottom: 10px; left: 10px; background-color: rgba(0,0,0,0.5); padding: 5px; border-radius: 4px; font-size: 0.8em; }
        .path-legend div { display: flex; align-items: center; margin-bottom: 3px; }
        .path-legend .color-box { width: 12px; height: 12px; margin-right: 5px; border-radius: 2px; }
        .path-legend .planned { background-color: #61dafb; }
        .path-legend .actual { background-color: #a2f279; }
        .sequence-report-panel { background-color: #2a2f35; padding: 15px; border-radius: 6px; margin-top: 15px; display: none; }
        .sequence-report-panel h4 { color: #a2f279; margin-top: 0; margin-bottom: 10px; }
        .sequence-report-metrics { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; }
        .sequence-report-metrics strong { color: #61dafb; }

        .autotune-config-common { background-color: #2a2f35; padding: 15px; border-radius: 6px; margin-bottom: 15px; }
        .autotune-config-common h3 { color: #61dafb; margin-top: 0; margin-bottom: 15px; }
        .autotune-config-common .setting-container { margin-bottom: 10px; }
        .autotune-config-common .setting-container label { color: #a2f279; }
        .autotune-tuning-chart-wrapper { position: relative; height: 250px; border-radius: 8px; overflow: hidden; background-color: #20232a; margin-bottom: 15px; }
        .main-method-tabs { display: flex; margin-bottom: 15px; border-bottom: 2px solid #4a4f58; }
        .method-tab { background-color: #4a4f58; color: #61dafb; border: none; padding: 12px 10px; cursor: pointer; transition: all 0.3s; border-radius: 8px 8px 0 0; font-size: 0.9em; flex-grow: 1;}
        .method-tab.active { background-color: #61dafb; color: #282c34; }
        .method-tab:hover:not(.active) { background-color: #5a6068; }
        .method-tab:disabled { cursor: not-allowed; opacity: 0.5; }
        .method-content { display: none; }
        .method-content.active { display: block; }
        .autotune-main-content { display: none; }
    .autotune-main-content.active { display: block; }
        /* Sta≈Ça wysoko≈õƒá obszaru zak≈Çadek (Konfiguracja/Metody) z przewijaniem, aby wysoko≈õƒá akordeonu by≈Ça stabilna */
        #autotuning-config-panel { /* kontener sekcji tabs */ }
        #autotuning-config-panel .autotune-main-content { 
            height: 360px; 
            overflow: auto; 
            -webkit-overflow-scrolling: touch;
        }
        @media (max-width: 768px) {
            #autotuning-config-panel .autotune-main-content { height: 52vh; }
        }
        /* Drobne wyr√≥wnanie stylu akordeonu 6 do pozosta≈Çych */
        #autotuning-card .accordion-header { width: 100%; display: block; }
        #autotuning-card .accordion-content { box-sizing: border-box; }
        .config-panel { background-color: #2a2f35; border-radius: 6px; padding: 15px; }
        .config-panel h3 { color: #61dafb; margin-top: 0; margin-bottom: 15px; font-size: 1.2em; }
        .config-section { margin-bottom: 20px; }
        .config-section label { display: block; color: #a2f279; font-weight: bold; margin-bottom: 8px; text-align: left;}
        .config-section select { width: 100%; padding: 8px; background-color: #20232a; color: #fff; border: 1px solid #61dafb; border-radius: 4px; }
        .config-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px; }
        .param-group { background-color: #20232a; padding: 12px; border-radius: 6px; text-align: left; }
        .param-group label { display: block; color: #61dafb; font-size: 0.9em; margin-bottom: 5px; }
        .param-group input[type="range"] { width: 100%; }
        .param-group span { display: block; text-align: center; color: #f7b731; font-weight: bold; margin-top: 5px; }
        .tuning-controls { display: flex; gap: 10px; align-items: center; margin-bottom: 20px; }
        .tuning-controls button {flex: 1;}
        .tuning-status { color: #f7b731; font-weight: bold; }
        .status-panel { background-color: #20232a; padding: 12px; border-radius: 6px; margin-bottom: 15px; }
        .progress-bar { width: 100%; height: 8px; background-color: #4a4f58; border-radius: 4px; overflow: hidden; margin-top: 10px; }
        .progress-bar .progress-fill { height: 100%; background-color: #a2f279; transition: width 0.3s ease; }
        .status-info { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px; font-size: 0.9em; }
        .status-info strong {color: #61dafb;}
        .status-info span { color: #f7b731; }
        .results-panel { background-color: #2a2f35; padding: 15px; border-radius: 6px; margin-top: 15px; display: none; }
        .results-panel h4 {color: #a2f279; margin-top:0;}
        .autotune-dashboard { background-color: #20232a; padding: 15px; border-radius: 6px; margin-top: 15px; display: none; }
        .autotune-dashboard h4 { color: #a2f279; margin: 0 0 10px 0;}
        .dashboard-metrics { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; }
        .metric-item { text-align: center; }
        .metric-label { color: #61dafb; font-size: 0.9em; display: block; margin-bottom: 5px; }
        .metric-value { font-size: 1.2em; font-weight: bold; color: #a2f279; }
        .progress-bar.small .progress-fill { background-color: #f7b731; }
        .search-space-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; margin-bottom: 15px; }
        .search-space-param { background-color: #20232a; padding: 8px; border-radius: 4px; text-align: left; }
        .search-space-param label { display: block; color: #61dafb; font-size: 0.85em; margin-bottom: 5px; }
        .search-space-param input[type="number"] { width: 100%; background-color: #3a3f47; color: #fff; border: 1px solid #4a4f58; border-radius: 3px; padding: 3px; font-size: 0.9em; }
        .fitness-function-config { margin-top: 15px; }
        .fitness-weight-item { display: flex; align-items: center; margin-bottom: 8px; }
        .fitness-weight-item label { flex-grow: 1; text-align: left; color: #fff; font-size: 0.9em; }
        .fitness-weight-item input[type="range"] { width: 100px; margin-left: 10px; }
        .fitness-weight-item span { width: 40px; text-align: right; color: #a2f279; font-weight: bold; }
        .autotune-live-status .status-info { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 10px; margin-top: 10px; font-size: 0.9em; }
        .autotune-live-status .status-info strong { color: #a2f279; }
        .autotune-results-container {
            max-height: 400px;
            overflow-y: auto;
            margin-top: 15px;
            border-radius: 6px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }
        .autotune-results-table {
            width: 100%;
            min-width: 600px;
            border-collapse: collapse;
            font-size: 0.9em;
            margin: 0;
            display: none; /* Hide table on mobile by default */
        }
        .autotune-results-table th, .autotune-results-table td {
            border: 1px solid #4a4f58;
            padding: 8px 6px;
            text-align: center;
            white-space: nowrap;
        }
        .autotune-results-table th {
            background-color: #4a4f58;
            color: #61dafb;
            font-weight: bold;
            position: sticky;
            top: 0;
            z-index: 1;
        }
        .autotune-results-table td {
            background-color: #3a3f47;
            color: #fff;
        }
        .autotune-results-table button {
            margin-left: 5px;
            padding: 4px 8px;
            font-size: 0.8em;
        }

        /* NEW: Block/Card format for results - mobile-first design */
        .result-entry {
            background-color: #2a2f35;
            border-left: 4px solid #61dafb;
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 6px;
            transition: border-color 0.3s, background-color 0.3s;
        }
        .result-entry:hover {
            background-color: #3a3f47;
            border-color: #a2f279;
        }
        .result-header {
            font-size: 1.1em;
            color: #61dafb;
            font-weight: bold;
            margin-bottom: 8px;
        }
        .result-params {
            color: #fff;
            margin-bottom: 6px;
            font-size: 0.95em;
        }
        .result-metrics {
            color: #a2f279;
            font-size: 0.9em;
            margin-bottom: 8px;
        }
        .result-entry button {
            padding: 6px 12px;
            font-size: 0.85em;
            margin-right: 5px;
        }

        /* Responsive design for mobile */
        @media (min-width: 769px) {
            /* Show table on larger screens */
            .autotune-results-table {
                display: table;
            }
            .result-entry {
                display: none;
            }
        }
        
        @media (max-width: 768px) {
            /* Hide table on smaller screens, show blocks */
            .autotune-results-table {
                display: none;
            }
            .result-entry {
                display: block;
            }
        }
        .axis-mapping-row {
            display: grid;
            grid-template-columns: 1fr auto auto;
            gap: 10px;
            align-items: center;
            margin-bottom: 8px;
            text-align: left;
        }
        .chart-hints { 
            background-color: #20232a; 
            padding: 8px; 
            border-radius: 4px; 
            margin-bottom: 10px; 
            font-size: 0.85em; 
            border-left: 3px solid #61dafb; 
        }
    /* Sekcje teorii metod autostrojenia */
    .method-theory { background:#20232a; border:1px solid #4a4f58; border-radius:6px; padding:12px; text-align:left; margin-bottom:12px; }
    .method-theory h4 { color:#a2f279; margin:0 0 8px 0; }
    .method-theory ul { margin:6px 0 0 18px; padding:0; }
    .method-theory li { margin:4px 0; }
    /* Modal mapowania modelu 3D */
    .model-mapping-row { display:grid; grid-template-columns: 100px 1fr 1fr; gap:8px; align-items:center; margin-bottom:8px; }
    .model-mapping-row select { width:100%; background:#20232a; color:#fff; border:1px solid #61dafb; border-radius:4px; padding:4px; }
    .model-mapping-row .sign-toggle { display:flex; gap:6px; }
    .sign-toggle button { flex:1; background:#4a4f58; color:#61dafb; }
    .sign-toggle button.active { background:#a2f279; color:#282c34; }
    #model-mapping-current { font-family:monospace; background:#111; border:1px solid #333; padding:8px; border-radius:6px; text-align:left; font-size:0.85em; }

    /* Usuniƒôty nowy blok styl√≥w autotune (powielenie) - powr√≥t do legacy definicji powy≈ºej */
    </style>
</head>
<body class="ui-locked">
    <div id="emergency-banner">ZATRZYMANIE AWARYJNE</div>
    <div id="gamepad-mapping-modal" class="modal-backdrop">
        <div class="modal-content">
            <h2>Mapowanie Przyciskow Gamepada</h2>
            <div id="gamepad-mapping-list"></div>
            <button id="close-modal-btn" style="margin-top: 20px;">Zamknij</button>
        </div>
    </div>
    <div id="calibration-modal" class="modal-backdrop">
        <div class="modal-content">
            <h2>Kalibracja IMU (Czujnik Nachylenia)</h2>
            <p>Aby skalibrowac czujnik IMU, powoli obroc robota we wszystkich kierunkach: do przodu, do tylu, na boki i wokol wlasnej osi pionowej. Wykonaj co najmniej 3 pelne obroty w kazdej plaszczyznie.</p>
            <p><strong>Dla akcelerometru (Accel) wazne:</strong> Trzymaj robota nieruchomo na okolo 10 sekund w kazdej z 6 pozycji (szescian): gora, dol, przednia strona, tylna strona, lewa strona, prawa strona. Powtarzaj obroty i zatrzymania, az progres osiagnie co najmniej 3/4 dla kazdej osi. Obroty powinny byc wolne i plynne.</p>
            <div class="calib-axis" style="display: flex; align-items: center; margin: 10px 0; justify-content: space-between;">
                <span>Sys (System):</span><progress id="calib-sys-bar" value="0" max="3" style="flex: 1; margin: 0 10px;"></progress><span id="calib-sys-text">0</span>/3
            </div>
            <div class="calib-axis" style="display: flex; align-items: center; margin: 10px 0; justify-content: space-between;">
                <span>Accel (Przyspieszenie):</span><progress id="calib-accel-bar" value="0" max="3" style="flex: 1; margin: 0 10px;"></progress><span id="calib-accel-text">0</span>/3
            </div>
            <div class="calib-axis" style="display: flex; align-items: center; margin: 10px 0; justify-content: space-between;">
                <span>Gyro (Obroty):</span><progress id="calib-gyro-bar" value="0" max="3" style="flex: 1; margin: 0 10px;"></progress><span id="calib-gyro-text">0</span>/3
            </div>
            <div class="calib-axis" style="display: flex; align-items: center; margin: 10px 0; justify-content: space-between;">
                <span>Mag (Magnetyczne):</span><progress id="calib-mag-bar" value="0" max="3" style="flex: 1; margin: 0 10px;"></progress><span id="calib-mag-text">0</span>/3
            </div>
            <button id="calib-update-btn" style="width: 48%; margin-right: 4%;">Aktualizuj Status</button>
            <button id="calib-close-btn" style="width: 48%;">Zamknij</button>
        </div>
    </div>

    <h1>Robot PID - Panel Sterowania v21.2</h1>
    <div class="main-grid">
        <div class="card" id="controls-card">
            <h2>Sterowanie</h2>
            <div id="joystickWrapper"><canvas id="joystickCanvas"></canvas></div>
            <div class="control-row"><span class="control-label">Balansowanie</span><label class="switch"><input type="checkbox" id="balanceSwitch"><span class="slider round"></span></label></div>
            <div class="control-row"><span class="control-label">Trzymaj Pozycje</span><label class="switch"><input type="checkbox" id="holdPositionSwitch"><span class="slider round"></span></label></div>
            <div class="control-row"><span class="control-label">Tryb Predkosci</span><label class="switch"><input type="checkbox" id="speedModeSwitch"><span class="slider round"></span></label></div>
            <button id="open-gamepad-modal-btn" style="width: 100%; background-color:#f7b731; margin-top: 15px;">Mapowanie Przyciskow Gamepada</button>
            <button id="resetZeroBtn" style="margin-top:10px; width:100%;">Resetuj Korekte Pionu</button>
            <div class="trim-controls">
                <button id="trimMinus01Btn">-0.1</button>
                <button id="trimMinus001Btn">-0.01</button>
                <span>Korekta Pionu: <span id="trimValueDisplay">0.00</span>¬∞</span>
                <button id="trimPlus001Btn">+0.01</button>
                <button id="trimPlus01Btn">+0.1</button>
            </div>
            <button id="resetRollZeroBtn" style="margin-top:10px; width:100%;">Resetuj Korekte Roll</button>
            <div class="trim-controls">
                <button id="rollTrimMinus01Btn">-0.1</button>
                <button id="rollTrimMinus001Btn">-0.01</button>
                <span>Korekta Roll: <span id="rollTrimValueDisplay">0.00</span>¬∞</span>
                <button id="rollTrimPlus001Btn">+0.01</button>
                <button id="rollTrimPlus01Btn">+0.1</button>
            </div>
            <button id="resetEncodersBtn" style="margin-top:10px; background-color:#f7b731; width: 100%;">Resetuj Enkodery</button>
            <button id="emergencyStopBtn">STOP AWARYJNY</button>
            <button class="accordion-header" onclick="toggleAccordion(this)" style="margin-top: 15px;">Strojenie Joysticka</button>
            <div class="accordion-content">
                <div class="setting-container"><label for="joystickSensitivityInput">Czulosc Globalna (%)<span class="help-icon">?</span></label><div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="joystickSensitivityInput" min="10" max="100" step="5" value="100"><button>+</button></div><div class="help-text">Globalny mno≈ºnik dla wszystkich warto≈õci z joysticka. Ustawienie 100% oznacza pe≈ÇnƒÖ czu≈Ço≈õƒá - robot reaguje maksymalnie na ruchy joysticka. Zmniejsz do 50-70%, je≈õli robot jest zbyt nerwowy lub reaguje zbyt gwa≈Çtownie. Przydatne podczas nauki sterowania lub w ciasnych przestrzeniach. Typowy zakres: 60-100%.</div></div>
                <div class="setting-container"><label for="expoJoystickInput">Expo Joysticka (%)<span class="help-icon">?</span></label><div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="expoJoystickInput" min="0" max="90" step="1" value="0"><button>+</button></div><div class="help-text">Krzywa wyk≈Çadnicza (expo) zmienia charakterystykƒô odpowiedzi joysticka. Przy 0% odpowied≈∫ jest liniowa. Zwiƒôkszenie warto≈õci sprawia, ≈ºe przy ma≈Çych wychyleniach robot reaguje ≈Çagodniej (wiƒôksza precyzja), a przy du≈ºych wychyleniach normalnie. Warto≈õƒá 30-50% zapewnia dobrƒÖ r√≥wnowagƒô miƒôdzy precyzjƒÖ a responsywno≈õciƒÖ. Typowy zakres: 0-50%.</div></div>
                <div class="setting-container"><label for="maxSpeedJoystickInput">Max. predkosc (imp/s)<span class="help-icon">?</span></label><div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="maxSpeedJoystickInput" min="200" max="4000" step="100" value="800"><button>+</button></div><div class="help-text">Maksymalna prƒôdko≈õƒá zadana w trybie prƒôdko≈õci przy pe≈Çnym wychyleniu joysticka do przodu/ty≈Çu. Wy≈ºsza warto≈õƒá = szybszy robot. Dla bezpiecznej nauki zacznij od 500-800 imp/s. Dla sportowej jazdy mo≈ºesz zwiƒôkszyƒá do 1500-2500 imp/s. Uwaga: zbyt wysoka warto≈õƒá mo≈ºe powodowaƒá utratƒô balansu! Typowy zakres: 500-1500 imp/s.</div></div>
                <div class="setting-container"><label for="joystickAngleSensitivityInput">Czulosc Kata (st.)<span class="help-icon">?</span></label><div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="joystickAngleSensitivityInput" min="1" max="30" step="0.5" value="10"><button>+</button></div><div class="help-text">Maksymalny kƒÖt pochylenia zadany w trybie kƒÖta przy pe≈Çnym wychyleniu joysticka. Mniejsza warto≈õƒá (5-8¬∞) = ≈Çagodniejsze przyspieszenie, bardziej przewidywalne zachowanie. Wiƒôksza warto≈õƒá (12-20¬∞) = agresywniejsze przyspieszenie, szybsza reakcja. Rozpocznij od 8-10¬∞ i dostosuj do swoich preferencji. Typowy zakres: 6-15¬∞.</div></div>
                <div class="setting-container"><label for="turnFactorInput">Czulosc Skretu (%)<span class="help-icon">?</span></label><div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="turnFactorInput" min="0" max="100" step="5" value="25"><button>+</button></div><div class="help-text">Kontroluje, jak szybko robot obraca siƒô w miejscu przy wychyleniu joysticka w poziomie. Mniejsza warto≈õƒá (15-25%) = powolne, p≈Çynne skrƒôty. Wiƒôksza warto≈õƒá (40-60%) = szybkie, ostre skrƒôty. Za wysoka warto≈õƒá mo≈ºe powodowaƒá utratƒô balansu podczas obrotu. Typowy zakres: 20-40%.</div></div>
                <div class="setting-container"><label for="joystickDeadzoneInput">Strefa Martwa (%)<span class="help-icon">?</span></label><div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="joystickDeadzoneInput" min="0" max="50" step="1" value="0"><button>+</button></div><div class="help-text">Obszar wok√≥≈Ç ≈õrodka joysticka, w kt√≥rym ruch jest ignorowany. Przydatne, je≈õli joystick "dryfuje" sam z siebie lub chcesz uniknƒÖƒá przypadkowych mikroruch√≥w. Warto≈õƒá 5-10% usuwa drobne dr≈ºenia bez utraty czu≈Ço≈õci. Typowy zakres: 0-15%.</div></div>
            </div>
        </div>
        <div class="card">
            <h2>Dashboard</h2>
            <button id="connectBleBtn" style="width: 100%; margin-bottom: 15px;">POLACZ Z ROBOTEM</button>
            <div style="display: grid; grid-template-columns: 1fr auto; gap: 15px; align-items: start; margin-bottom: 15px;">
                <div class="status-grid">
                    <strong>Polaczenie:</strong> <div><span id="connectionStatus" class="status-indicator status-disconnected"></span> <span id="connectionText">Rozlaczony</span></div>
                    <strong>Gamepad:</strong> <span id="gamepadStatus" style="font-weight:bold; color: #f7b731;">Brak</span>
                    <strong>Tryb Pracy:</strong> <span id="robotStateVal" style="font-weight:bold; color: #61dafb;">IDLE</span>
                </div>
                <div class="compass-container">
                    <div class="compass-needle" id="compassNeedle"></div>
                    <span class="compass-cardinal n">N</span>
                    <span class="compass-cardinal e">E</span>
                    <span class="compass-cardinal s">S</span>
                    <span class="compass-cardinal w">W</span>
                </div>
            </div>
             <div class="dashboard-grid">
                <div class="dashboard-item">
                    <span class="label">Czas Petli</span>
                    <span class="value" id="loopTimeVal">0 &micro;s</span>
                </div>
                <div class="dashboard-item">
                    <span class="label">Czas Petli (≈õrednio)</span>
                    <span class="value" id="loopLoadVal">-- %</span>
                </div>
                <div class="dashboard-item" id="systemHealthItem">
                    <span class="label">System Health</span>
                    <span class="value" id="systemHealthVal">OK</span>
                </div>
                <div class="dashboard-item">
                    <span class="label">Kalibracja IMU</span>
                    <span class="value">Sys: <span id="calibSysVal">-</span></span>
                    <div class="historical-metric">Acc: <span id="calibAccelVal">-</span> Gyro: <span id="calibGyroVal">-</span> Mag: <span id="calibMagVal">-</span></div>
                </div>
                <div class="dashboard-item">
                    <span class="label">Kat (Pitch)</span>
                    <span class="value" id="angleVal">0.0 &deg;</span>
                    <div class="historical-metric">(min: <span id="pitchMin">---</span>, max: <span id="pitchMax">---</span>, avg: <span id="pitchAvg">---</span>)</div>
                </div>
                <div class="dashboard-item">
                    <span class="label">Predkosc</span>
                    <span class="value" id="speedVal">0 imp/s</span>
                    <div class="historical-metric">(min: <span id="speedMin">---</span>, max: <span id="speedMax">---</span>, avg: <span id="speedAvg">---</span>)</div>
                </div>
                <div class="dashboard-item">
                    <span class="label">Kat (Roll)</span>
                    <span class="value" id="rollVal">0.0 &deg;</span>
                </div>
                <div class="dashboard-item">
                    <span class="label">Enkoder L</span>
                    <span class="value" id="encoderLeftVal">0</span>
                </div>
                <div class="dashboard-item">
                    <span class="label">Enkoder P</span>
                    <span class="value" id="encoderRightVal">0</span>
                </div>
                <div class="dashboard-item">
                    <span class="label">Kurs (Yaw)</span>
                    <span class="value" id="yawVal">0.0 ¬∞</span>
                </div>
            </div>
             <fieldset style="margin-top: 15px;">
                <legend>Diagnostyka</legend>
                <div style="display: grid; grid-template-columns: 1fr; gap: 10px;">
                    <button id="calibrateMpuBtn" style="width:100%; background-color:#f7b731;">Asystent Kalibracji IMU</button>
                    <button id="calibrateZeroPointBtn" style="width:100%; background-color:#f7b731;">Znajdz Pion Automatycznie</button>
                    <button id="sensorMappingBtn" style="width:100%; background-color:#f7b731;">Mapowanie czujnika</button>
                    <button id="modelMappingBtn" style="width:100%; background-color:#f7b731;">Mapowanie modelu 3D</button>
                </div>
            </fieldset>
        </div>
        <div class="card">
            <h2>Wizualizacja 3D Robota</h2>
            <div id="robot3d-container"></div>
            <div class="robot3d-controls">
                <button id="reset3dViewBtn">Resetuj Widok</button>
                <button id="toggle3dAnimationBtn">Wl./Wyl. Animacje</button>
                <button id="toggle3dMovementBtn">Start/Stop Ruchu</button>
            </div>
            <div class="robot3d-info">
                <div class="robot3d-metrics">
                    <strong>Przechyl (Pitch):</strong> <span id="robot3d-pitch">0.0¬∞</span>
                    <strong>Przechyl (Roll):</strong> <span id="robot3d-roll">0.0¬∞</span>
                    <strong>Obrot kol:</strong> <span id="robot3d-wheel-speed">0 obr/min</span>
                    <strong>Pozycja X:</strong> <span id="robot3d-position-x">0.0 cm</span>
                    <strong>Pozycja Z:</strong> <span id="robot3d-position-z">0.0 cm</span>
                </div>
            </div>
            <fieldset style="margin-top: 15px;">
                <div class="control-row" style="margin-bottom: 15px;">
                    <span class="control-label">Perspektywa Robota</span>
                    <label class="switch"><input type="checkbox" id="robotPerspectiveCheckbox"><span class="slider round"></span></label>
                </div>
            </fieldset>
        </div>
        <div class="card">
            <h2>Analizator Sygnalow</h2>
            <div class="chart-hints">
                <strong>üí° Wskaz√≥wki:</strong> 
                Ctrl+Scroll dla zoom | Ctrl+PrzeciƒÖgnij dla przewijania | Shift+PrzeciƒÖgnij dla zaznaczenia zakresu
            </div>
            <div id="chart-wrapper">
                <canvas id="signalAnalyzerChart"></canvas>
            </div>
            <div class="chart-toolbar">
                <button id="pauseChartBtn">‚è∏Ô∏è Pauza</button>
                <button id="resumeChartBtn" style="display:none;">‚ñ∂Ô∏è Wznow</button>
                <button id="cursorABBtn">üìè Kursory A/B</button>
                <button id="exportCsvBtn">üìÑ Eksport CSV</button>
                <button id="exportRangeCsvBtn" title="Zaznacz zakres trzymajƒÖc Shift i przeciƒÖgajƒÖc myszkƒÖ">üìä Eksport CSV (Zakres)</button>
                <button id="resetZoomBtn">üîç Reset Widoku</button>
                <button id="exportPngBtn">üñºÔ∏è Eksport PNG</button>
            </div>
            <div class="chart-cursor-info" id="cursorInfo" style="display:none;">
                <div><strong>Kursor A:</strong> X: <span id="cursorAX">---</span>, Y: <span id="cursorAY">---</span></div>
                <div><strong>Kursor B:</strong> X: <span id="cursorBX">---</span>, Y: <span id="cursorBY">---</span></div>
                <div><strong>Œît:</strong> <span id="cursorDeltaT">---</span></div>
                <div><strong>Œîy (Pitch):</strong> <span id="cursorDeltaYPitch">---</span></div>
                <div><strong>Œîy (Speed):</strong> <span id="cursorDeltaYSpeed">---</span></div>
            </div>
            <div class="chart-controls" id="signalChartControls"></div>
        </div>
        <div class="card">
             <button class="accordion-header" onclick="toggleAccordion(this)">Sterowanie Autonomiczne</button>
            <div class="accordion-content">
               <fieldset>
                   <legend>Sterowanie Precyzyjne (D-Pad)</legend>
                   <div class="dpad-input-group"><label for="dpadDistInput">Dystans (cm):</label><input type="number" id="dpadDistInput" value="20"></div>
                   <div class="dpad-input-group"><label for="dpadAngleInput">Kat (st.):</label><input type="number" id="dpadAngleInput" value="90"></div>
                   <div class="dpad-container">
                       <button id="dpad-up" class="dpad-btn" data-dpad="up">&#8593;</button><button id="dpad-left" class="dpad-btn" data-dpad="left">&#8592;</button><button id="dpad-stop" class="dpad-btn" data-dpad="stop">&#215;</button><button id="dpad-right" class="dpad-btn" data-dpad="right">&#8594;</button><button id="dpad-down" class="dpad-btn" data-dpad="down">&#8595;</button>
                   </div>
               </fieldset>
               <fieldset style="margin-top: 15px;">
                   <legend>Kreator Sekwencji Ruchow</legend>
                   <div id="sequence-list"></div>
                   <button id="add-sequence-step-btn" style="width:100%; margin: 10px 0;">Dodaj Krok</button>
                   <div style="display:flex; gap:10px; justify-content:center;">
                       <button id="run-sequence-btn" style="background-color: #a2f279;">Uruchom</button><button id="stop-sequence-btn" style="background-color: #ff6347;" disabled>Zatrzymaj</button><button id="clear-sequence-btn" style="background-color: #f7b731;">Wyczysc</button>
                   </div>
                   <h4 style="color: #61dafb; margin-top: 20px; margin-bottom: 10px;">Wizualizacja Sciezki (2D)</h4>
                   <div id="path-visualization-container">
                       <canvas id="pathCanvas"></canvas>
                       <div class="path-legend">
                           <div><span class="color-box planned"></span> Planowana</div>
                           <div><span class="color-box actual"></span> Rzeczywista</div>
                       </div>
                   </div>
                   <div id="sequence-report-panel" class="sequence-report-panel">
                       <h4>Raport Sekwencji</h4>
                       <div class="sequence-report-metrics" id="sequenceReportMetrics">
                           <div><strong>Sredni Blad Kursu:</strong> <span id="avgHeadingError">---</span></div>
                           <div><strong>Max Blad Kursu:</strong> <span id="maxHeadingError">---</span></div>
                           <div><strong>Pokonany Dystans:</strong> <span id="totalDistanceCovered">---</span></div>
                       </div>
                       <button id="resetSequenceReportBtn" style="width: 100%; margin-top: 15px;">Wyczysc Raport</button>
                   </div>
               </fieldset>
           </div>
        </div>
        <div class="card">
            <h2>Konfiguracja</h2>
            <fieldset>
                <legend>Profile Ustawien (Snapshots)</legend>
                <div class="profile-controls"> <select id="pidPresetSelect" style="width: 100%; padding: 5px;"></select> </div>
                <div class="preset-actions">
                    <button id="applySelectedPresetBtn">Zastosuj</button>
                    <button id="saveCurrentAsPresetBtn">Zapisz jako Nowy</button>
                </div>
                <button id="deleteSelectedPresetBtn" style="width:100%; margin-top: 10px; background-color: #ff6347;">Usun Wybrany</button>
                <!-- Przyciski przeniesione na d√≥≈Ç, pod wszystkimi akordeonami -->
            </fieldset>
            <div id="allSettings">
                <button class="accordion-header" onclick="toggleAccordion(this)">1. Parametry Sprzetowe i Mechaniczne</button>
                <div class="accordion-content">
                    <!-- Usuniƒôto legacy mapowanie osi IMU ‚Äì zastƒÖpione nowym kreatorem 'Mapowanie czujnika' w Dashboard -->
                    <div class="setting-container"> <label for="wheelDiameterInput">Srednica kola (cm)<span class="help-icon">?</span></label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="wheelDiameterInput" min="1" max="30" step="0.1" value="8.2"><button>+</button></div> <div class="help-text">≈örednica ko≈Ça robota w centymetrach. Parametr kluczowy dla obliczania prƒôdko≈õci i pokonanego dystansu. Zmierz dok≈Çadnie ≈õrednicƒô od krawƒôdzi do krawƒôdzi przez ≈õrodek ko≈Ça. Wiƒôksze ko≈Ça = wiƒôksza prƒôdko≈õƒá przy tych samych obrotach silnika. Typowy zakres: 6-12 cm.</div> </div>
                    <div class="setting-container"> <label for="trackWidthInput">Rozstaw kol (cm)<span class="help-icon">?</span></label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="trackWidthInput" min="5" max="50" step="0.1" value="12.5"><button>+</button></div> <div class="help-text">Odleg≈Ço≈õƒá miƒôdzy ≈õrodkami obu k√≥≈Ç (szeroko≈õƒá toru). Wp≈Çywa na obliczenia obrotu - szerszy rozstaw wymaga wiƒôkszej r√≥≈ºnicy prƒôdko≈õci k√≥≈Ç do wykonania tego samego skrƒôtu. Zmierz odleg≈Ço≈õƒá miƒôdzy ≈õrodkami osi k√≥≈Ç. Typowy zakres: 10-20 cm.</div> </div>
                    <div class="setting-container"> <label for="encoderPprInput">Impulsy na obrot (PPR)<span class="help-icon">?</span></label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="encoderPprInput" min="100" max="5000" step="10" value="820"><button>+</button></div> <div class="help-text">Liczba impuls√≥w enkodera na jeden pe≈Çny obr√≥t ko≈Ça. Zale≈ºy od rozdzielczo≈õci enkodera i przek≈Çadni (je≈õli jest). Warto≈õƒá ta wp≈Çywa na dok≈Çadno≈õƒá pomiaru prƒôdko≈õci i pozycji. Wy≈ºsza warto≈õƒá = wiƒôksza precyzja. Sprawd≈∫ specyfikacjƒô swojego enkodera i przek≈Çadni. Typowy zakres: 300-2000 PPR.</div> </div>
                </div>
                <button class="accordion-header" onclick="toggleAccordion(this)">2. Kalibracja PWM Silnikow</button>
                <div class="accordion-content">
                    <div class="pwm-info"> <strong>Info:</strong> Uzyj przycisku <strong>"Auto"</strong>, aby automatycznie znalezc prog startowy silnika, lub <strong>"Testuj"</strong>, aby sprawdzic recznie wpisana wartosc. <strong>Wazne:</strong> Przed testem podnies robota, aby kola mogly sie swobodnie krecic! </div>
                    <div class="setting-container"> <label for="pwmTuneStartInput">Rozpocznij auto-szukanie od PWM</label> <div class="numeric-input-wrapper"> <button id="pwmTuneStartMinus">-</button> <input type="number" id="pwmTuneStartInput" min="1" max="2047" step="1" value="1200"> <button id="pwmTuneStartPlus">+</button> </div> </div> <hr style="border-color: #4a4f58; margin: 15px 0;">
                    <div class="manual-tune-row" data-motor="left" data-direction="fwd"> <div class="pwm-input-row"> <label>Lewy (Przod)</label> <div class="numeric-input-wrapper"><button class="tune-minus">-</button><input type="number" class="config-value tune-input" id="minPwmLeftFwdInput" min="0" max="2047" step="1" value="1200"><button>+</button></div> </div> <div class="pwm-button-row"> <button class="test-btn">Testuj</button><button class="stop-btn">Stop</button><button class="auto-btn">Auto</button></div> </div>
                    <div class="manual-tune-row" data-motor="left" data-direction="bwd"> <div class="pwm-input-row"> <label>Lewy (Tyl)</label> <div class="numeric-input-wrapper"><button class="tune-minus">-</button><input type="number" class="config-value tune-input" id="minPwmLeftBwdInput" min="0" max="2047" step="1" value="1200"><button>+</button></div> </div> <div class="pwm-button-row"> <button class="test-btn">Testuj</button><button class="stop-btn">Stop</button><button class="auto-btn">Auto</button></div> </div>
                    <div class="manual-tune-row" data-motor="right" data-direction="fwd"> <div class="pwm-input-row"> <label>Prawy (Przod)</label> <div class="numeric-input-wrapper"><button class="tune-minus">-</button><input type="number" class="config-value tune-input" id="minPwmRightFwdInput" min="0" max="2047" step="1" value="1200"><button>+</button></div> </div> <div class="pwm-button-row"> <button class="test-btn">Testuj</button><button class="stop-btn">Stop</button><button class="auto-btn">Auto</button></div> </div>
                    <div class="manual-tune-row" data-motor="right" data-direction="bwd"> <div class="pwm-input-row"> <label>Prawy (Tyl)</label> <div class="numeric-input-wrapper"><button class="tune-minus">-</button><input type="number" class="config-value tune-input" id="minPwmRightBwdInput" min="0" max="2047" step="1" value="1200"><button>+</button></div> </div> <div class="pwm-button-row"> <button class="test-btn">Testuj</button><button class="stop-btn">Stop</button><button class="auto-btn">Auto</button></div> </div>
                    <button id="manualTuneStopAll" style="width:100%; margin-top:15px; background-color:#ff6347;">ZATRZYMAJ WSZYSTKIE SILNIKI</button>
                </div>
                <button class="accordion-header" onclick="toggleAccordion(this)">3. PID Balansu (Podstawowy)</button>
                <div class="accordion-content">
                    <div class="setting-container"> <label for="balanceKpInput">Kp - Sila<span class="help-icon">?</span></label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="balanceKpInput" min="0" max="500" step="0.1" value="95"><button>+</button></div> <div class="help-text"><strong>Proporcjonalny (Kp):</strong> Okre≈õla, jak mocno robot reaguje na odchylenie od pionu. Wy≈ºsza warto≈õƒá = sztywniejsze utrzymanie r√≥wnowagi, szybsza reakcja na zak≈Ç√≥cenia. Zbyt wysoka warto≈õƒá powoduje szybkie oscylacje (robot "dr≈ºy"). Zbyt niska = robot reaguje za wolno i mo≈ºe upa≈õƒá. Zacznij od 80-120 i dostosuj stopniowo. Typowy zakres: 60-150.</div> </div>
                    <div class="setting-container"> <label for="balanceKiInput">Ki - Korekta<span class="help-icon">?</span></label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="balanceKiInput" min="0" max="10" step="0.01" value="0.0"><button>+</button></div> <div class="help-text"><strong>Ca≈ÇkujƒÖcy (Ki):</strong> Eliminuje d≈Çugotrwa≈Çy, sta≈Çy b≈ÇƒÖd (np. gdy robot powoli dryfuje w jednym kierunku mimo pionowego stania). Czƒôsto nie jest potrzebny dla balansu - zacznij od 0. Je≈õli robot ma tendencjƒô do dryfowania, zwiƒôkszaj bardzo ostro≈ºnie (np. 0.05-0.2). Zbyt wysoka warto≈õƒá powoduje niestabilno≈õƒá i oscylacje. Typowy zakres: 0-0.5.</div> </div>
                    <div class="setting-container"> <label for="balanceKdInput">Kd - Tlumienie<span class="help-icon">?</span></label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="balanceKdInput" min="0" max="50" step="0.01" value="3.23"><button>+</button></div> <div class="help-text"><strong>R√≥≈ºniczkujƒÖcy (Kd):</strong> Dzia≈Ça jak amortyzator - przeciwdzia≈Ça szybkim zmianom kƒÖta, hamuje oscylacje i wyg≈Çadza ruch. Wy≈ºsza warto≈õƒá = bardziej uspokojony, stabilny robot, ale wolniejsza reakcja. Zbyt wysoka warto≈õƒá powoduje "leniwy" ruch i s≈ÇabƒÖ reakcjƒô na zak≈Ç√≥cenia. Zbyt niska = robot jest nerwowy i dr≈ºy. Typowy zakres: 2-8.</div> </div>
                    <div class="setting-container"> <label for="balanceFilterAlphaInput">Filtr Pochodnej (%)<span class="help-icon">?</span></label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="balanceFilterAlphaInput" min="1" max="100" step="1" value="100"><button>+</button></div> <div class="help-text">Wyg≈Çadza sygna≈Ç r√≥≈ºniczkujƒÖcy (Kd), redukujƒÖc wp≈Çyw szum√≥w z czujnika. 100% = brak filtrowania (pe≈Çna responsywno≈õƒá, ale mo≈ºe byƒá szum). Zmniejsz do 50-80%, je≈õli robot jest nerwowy lub "dr≈ºy" mimo niskiego Kd. Ni≈ºsza warto≈õƒá = p≈Çynniejszy ruch, ale wolniejsza reakcja. Typowy zakres: 70-100%.</div> </div>
                    <div class="setting-container"> <label for="balanceIntegralLimitInput">Limit Integratora<span class="help-icon">?</span></label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="balanceIntegralLimitInput" min="0" max="200" step="1" value="50"><button>+</button></div> <div class="help-text">Maksymalna warto≈õƒá, jakƒÖ mo≈ºe osiƒÖgnƒÖƒá suma ca≈ÇkujƒÖca (Ki). Zapobiega "rozregulowaniu" integratora przy du≈ºych, d≈Çugotrwa≈Çych b≈Çƒôdach. Je≈õli u≈ºywasz Ki, ustaw limit na 30-100. Je≈õli Ki=0, ten parametr nie ma wp≈Çywu. Typowy zakres: 30-100.</div> </div>
                </div>
                <button class="accordion-header" onclick="toggleAccordion(this)">4. PID Kaskadowy (Predkosc/Pozycja)</button>
                <div class="accordion-content">
                    <div class="parameter-group"><h5>PID Predkosci</h5>
                        <div class="setting-container"> <label for="speedKpInput">Kp - Reakcja<span class="help-icon">?</span></label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="speedKpInput" min="0" max="10" step="0.01" value="0.0"><button>+</button></div> <div class="help-text">Kontroluje, jak mocno robot pochyla siƒô, aby osiƒÖgnƒÖƒá zadanƒÖ prƒôdko≈õƒá. Wy≈ºsza warto≈õƒá = szybsze przyspieszanie/zwalnianie, ale mo≈ºe powodowaƒá oscylacje prƒôdko≈õci. Zacznij od ma≈Çych warto≈õci (0.1-0.5) i zwiƒôkszaj stopniowo. Typowy zakres: 0.1-2.0.</div> </div>
                        <div class="setting-container"> <label for="speedKiInput">Ki - Eliminacja bledu<span class="help-icon">?</span></label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="speedKiInput" min="0" max="1" step="0.001" value="0.0"><button>+</button></div> <div class="help-text">Eliminuje sta≈Çy b≈ÇƒÖd prƒôdko≈õci (gdy robot jedzie ciƒÖgle trochƒô wolniej/szybciej ni≈º powinien). Czƒôsto wystarczy 0, ale je≈õli prƒôdko≈õƒá nie osiƒÖga docelowej warto≈õci, dodaj ma≈ÇƒÖ warto≈õƒá Ki (0.01-0.1). Zbyt wysoka warto≈õƒá powoduje oscylacje. Typowy zakres: 0-0.2.</div> </div>
                        <div class="setting-container"> <label for="speedKdInput">Kd - Tlumienie<span class="help-icon">?</span></label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="speedKdInput" min="0" max="5" step="0.001" value="0.0"><button>+</button></div> <div class="help-text">Wyg≈Çadza zmiany prƒôdko≈õci, przeciwdzia≈Ça oscylacjom. Pomaga, gdy robot "skacze" miƒôdzy r√≥≈ºnymi prƒôdko≈õciami. Zacznij od 0, dodaj (0.01-0.1) je≈õli prƒôdko≈õƒá oscyluje. Zbyt wysoka warto≈õƒá spowalnia reakcjƒô na zmiany. Typowy zakres: 0-0.5.</div> </div>
                        <div class="setting-container"> <label for="maxTargetAngleInput">Max. kat z PID Predk. (st.)<span class="help-icon">?</span></label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="maxTargetAngleInput" min="1" max="45" step="0.5" value="15.0"><button>+</button></div> <div class="help-text">Maksymalny kƒÖt, jaki PID prƒôdko≈õci mo≈ºe zadaƒá robotowi, aby osiƒÖgnƒÖƒá docelowƒÖ prƒôdko≈õƒá. Limit bezpiecze≈Ñstwa - zapobiega zbyt du≈ºemu pochyleniu. Wiƒôksza warto≈õƒá = szybsze przyspieszanie, ale wiƒôksze ryzyko upadku. Typowy zakres: 10-20¬∞.</div> </div>
                        <div class="setting-container"> <label for="speedDeadbandInput">Strefa martwa (imp/s)<span class="help-icon">?</span></label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="speedDeadbandInput" min="0" max="50" step="1" value="5"><button>+</button></div> <div class="help-text">Je≈õli rzeczywista prƒôdko≈õƒá r√≥≈ºni siƒô od zadanej o mniej ni≈º ta warto≈õƒá, PID nie reaguje. Zapobiega ciƒÖg≈Çym mikro-korektom przy ma≈Çych b≈Çƒôdach, oszczƒôdza energiƒô i zmniejsza drgania. Typowy zakres: 3-15 imp/s.</div> </div>
                        <div class="setting-container"> <label for="speedIntegralLimitInput">Limit Integratora<span class="help-icon">?</span></label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="speedIntegralLimitInput" min="0" max="100" step="1" value="20"><button>+</button></div> <div class="help-text">Maksymalna warto≈õƒá sumy ca≈ÇkujƒÖcej (Ki). Zapobiega "wind-up" (rozregulowaniu) integratora. Istotne tylko gdy u≈ºywasz Ki > 0. Typowy zakres: 10-50.</div> </div>
                        <div class="setting-container"> <label for="speedFilterAlphaInput">Filtr Pochodnej (%)<span class="help-icon">?</span></label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="speedFilterAlphaInput" min="1" max="100" step="1" value="80"><button>+</button></div> <div class="help-text">Wyg≈Çadza sygna≈Ç r√≥≈ºniczkujƒÖcy (Kd). 100% = brak filtrowania. Zmniejsz, je≈õli Kd wprowadza nerwowo≈õƒá. Typowy zakres: 60-90%.</div> </div>
                    </div>
                     <div class="parameter-group"><h5>PID Pozycji</h5>
                        <div class="setting-container"> <label for="positionKpInput">Kp - Sila powrotu<span class="help-icon">?</span></label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="positionKpInput" min="0" max="20" step="0.1" value="0.0"><button>+</button></div> <div class="help-text">Kontroluje, jak mocno robot dƒÖ≈ºy do powrotu do zadanej pozycji (funkcja "trzymaj pozycjƒô"). Wy≈ºsza warto≈õƒá = silniejsza korekta, szybszy powr√≥t. Zbyt wysoka powoduje oscylacje wok√≥≈Ç pozycji docelowej. Zacznij od 0.5-2.0. Typowy zakres: 0.5-5.0.</div> </div>
                        <div class="setting-container"> <label for="positionKiInput">Ki - Korekta<span class="help-icon">?</span></label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="positionKiInput" min="0" max="1" step="0.001" value="0.0"><button>+</button></div> <div class="help-text">Usuwa sta≈Çe odchylenie od pozycji (gdy robot powoli "dryfuje" mimo w≈ÇƒÖczonej funkcji trzymania pozycji). Czƒôsto nie jest potrzebny. Dodaj ma≈ÇƒÖ warto≈õƒá (0.001-0.01) tylko je≈õli robot systematycznie odje≈ºd≈ºa od pozycji. Typowy zakres: 0-0.05.</div> </div>
                        <div class="setting-container"> <label for="positionKdInput">Kd - Hamowanie<span class="help-icon">?</span></label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="positionKdInput" min="0" max="10" step="0.05" value="0.0"><button>+</button></div> <div class="help-text">Hamuje ruch, gdy robot zbli≈ºa siƒô do pozycji docelowej - zapobiega "przestrzeleniu". Wy≈ºsza warto≈õƒá = p≈Çynniejsze, bardziej kontrolowane zatrzymanie, ale wolniejszy powr√≥t. Zacznij od 0.1-0.5. Typowy zakres: 0.1-2.0.</div> </div>
                        <div class="setting-container"> <label for="maxTargetSpeedInput">Max. predkosc z PID Poz. (imp/s)<span class="help-icon">?</span></label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="maxTargetSpeedInput" min="100" max="4000" step="50" value="1000"><button>+</button></div> <div class="help-text">Maksymalna prƒôdko≈õƒá, jakƒÖ PID pozycji mo≈ºe zadaƒá podczas powrotu do punktu. Limit bezpiecze≈Ñstwa - zapobiega zbyt szybkiemu ruchowi przy du≈ºych odchyleniach. Wy≈ºsza warto≈õƒá = szybszy powr√≥t, ale wiƒôksze ryzyko przesterowania. Typowy zakres: 500-1500 imp/s.</div> </div>
                        <div class="setting-container"> <label for="positionDeadbandInput">Margines bledu (imp.)<span class="help-icon">?</span></label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="positionDeadbandInput" min="0" max="100" step="1" value="15"><button>+</button></div> <div class="help-text">Je≈õli odchylenie od pozycji jest mniejsze ni≈º ta warto≈õƒá (w impulsach enkodera), PID pozycji nie reaguje. Robot "akceptuje" to ma≈Çe odchylenie i nie pr√≥buje go korygowaƒá. Zapobiega ciƒÖg≈Çym mikro-ruchom. Typowy zakres: 10-30 imp.</div> </div>
                        <div class="setting-container"> <label for="positionIntegralLimitInput">Limit Integratora<span class="help-icon">?</span></label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="positionIntegralLimitInput" min="0" max="500" step="10" value="100"><button>+</button></div> <div class="help-text">Maksymalna warto≈õƒá sumy ca≈ÇkujƒÖcej (Ki). Zapobiega "wind-up" integratora. Istotne tylko gdy Ki > 0. Typowy zakres: 50-200.</div> </div>
                        <div class="setting-container"> <label for="positionFilterAlphaInput">Filtr Pochodnej (%)<span class="help-icon">?</span></label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="positionFilterAlphaInput" min="1" max="100" step="1" value="90"><button>+</button></div> <div class="help-text">Wyg≈Çadza sygna≈Ç r√≥≈ºniczkujƒÖcy (Kd). 100% = brak filtrowania. Zmniejsz do 70-90%, je≈õli hamowanie jest "szarpane". Typowy zakres: 70-95%.</div> </div>
                    </div>
                </div>
                <button class="accordion-header" onclick="toggleAccordion(this)">5. PID Obrotu i Kursu</button>
                <div class="accordion-content">
                    <div class="parameter-group"><h5>PID Obrotu (Autonomiczny)</h5>
                        <div class="setting-container"> <label for="rotationKpInput">Kp - Sila obrotu<span class="help-icon">?</span></label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="rotationKpInput" min="0" max="50" step="0.1" value="0.0"><button>+</button></div> <div class="help-text">Kontroluje moc obrotu podczas automatycznego skrƒôtu o zadany kƒÖt. Wy≈ºsza warto≈õƒá = szybszy obr√≥t, ale ryzyko przesterowania (robot obraca siƒô za daleko). Zacznij od ma≈Çych warto≈õci (1-5) i zwiƒôkszaj stopniowo. Typowy zakres: 2-10.</div> </div>
                        <div class="setting-container"> <label for="rotationKdInput">Kd - Tlumienie<span class="help-icon">?</span></label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="rotationKdInput" min="0" max="20" step="0.1" value="0.0"><button>+</button></div> <div class="help-text">Hamuje obr√≥t, gdy robot zbli≈ºa siƒô do docelowego kƒÖta. Zapobiega oscylacjom wok√≥≈Ç pozycji docelowej. Wy≈ºsza warto≈õƒá = p≈Çynniejsze, bardziej kontrolowane zatrzymanie. Zacznij od 0.5-2.0. Typowy zakres: 0.5-5.0.</div> </div>
                    </div>
                    <div class="parameter-group"><h5>PID Utrzymania Kursu (podczas jazdy prosto)</h5>
                        <div class="setting-container"> <label for="headingKpInput">Kp - Sila korekty<span class="help-icon">?</span></label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="headingKpInput" min="0" max="10" step="0.05" value="0.0"><button>+</button></div> <div class="help-text">Kontroluje, jak mocno robot koryguje odchylenie od zadanego kursu podczas jazdy prosto. Wy≈ºsza warto≈õƒá = mocniejsza korekta, robot jedzie bardziej "po linii". Zbyt wysoka mo≈ºe powodowaƒá "zygzakowanie". Zacznij od 0.5-2.0. Typowy zakres: 0.5-5.0.</div> </div>
                        <div class="setting-container"> <label for="headingKiInput">Ki - Precyzja<span class="help-icon">?</span></label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="headingKiInput" min="0" max="1" step="0.005" value="0.0"><button>+</button></div> <div class="help-text">Usuwa systematyczne odchylenie kursu (gdy robot powoli "skrƒôca" w jednƒÖ stronƒô mimo jazdy prosto). Dodaj ma≈ÇƒÖ warto≈õƒá (0.01-0.1) je≈õli robot ma tendencjƒô do odbijania w bok. Typowy zakres: 0-0.2.</div> </div>
                        <div class="setting-container"> <label for="headingKdInput">Kd - Tlumienie<span class="help-icon">?</span></label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="headingKdInput" min="0" max="5" step="0.01" value="0.0"><button>+</button></div> <div class="help-text">Wyg≈Çadza korekty kursu, zapobiega "szarpaniu" przy zmianach kierunku. Przydatne je≈õli robot nerwowo koryguje kurs. Zacznij od 0.05-0.2. Typowy zakres: 0.05-0.5.</div> </div>
                        <div class="setting-container"> <label for="rotationToPwmScaleInput">Skala wyj≈õcia PID -> PWM<span class="help-icon">?</span></label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="rotationToPwmScaleInput" min="0" max="1" step="0.001" value="0.01"><button>+</button></div> <div class="help-text">Konwertuje wyj≈õcie PID obrotu/kursu na komponent skrƒôtu (PWM). Zwiƒôksz je≈õli korekty kierunku sƒÖ za s≈Çabe, zmniejsz je≈õli robot "przeostrza" lub oscyluje. Typowy zakres: 0.005 - 0.05.</div> </div>
                    </div>
                </div>
                
        <!-- NOWY, ZINTEGROWANY PANEL OPTYMALIZACJI - PROSZƒò WSTAW TUTAJ -->
        <div class="card" id="autotuning-card">
            <button class="accordion-header" onclick="toggleAccordion(this)">6. Zaawansowana Optymalizacja PID</button>
            <div class="accordion-content autotune-pane" id="autotuning-card-content">
                <div id="autotuning-config-panel">
                    <!-- G≈Ç√≥wne zak≈Çadki panelu -->
                    <div class="autotune-main-tabs">
                        <button class="autotune-main-tab active" data-tab="config">Konfiguracja Testu</button>
                        <button class="autotune-main-tab" data-tab="methods">Metody Optymalizacji</button>
                    </div>

                    <!-- Zak≈Çadka 1: Konfiguracja -->
                    <div class="autotune-main-content active" data-tab="config">
                        <div class="config-section">
                            <label for="tuning-loop-selector">üéØ Pƒôtla PID do strojenia:</label>
                            <select id="tuning-loop-selector" style="padding: 8px; background-color: #20232a; color: #fff; border: 1px solid #61dafb; border-radius: 4px;">
                                <option value="balance">Pƒôtla Balansu</option>
                                <option value="speed">Pƒôtla Prƒôdko≈õci</option>
                                <option value="position">Pƒôtla Pozycji</option>
                            </select>
                        </div>
                        <div class="config-section">
                            <h4>üîç Przestrze≈Ñ Przeszukiwania</h4>
                            <div class="search-space-grid">
                                <div class="search-space-param"><label for="search-kp-min">Kp Min:</label><input type="number" id="search-kp-min" value="30" step="0.1"></div>
                                <div class="search-space-param"><label for="search-kp-max">Kp Max:</label><input type="number" id="search-kp-max" value="100" step="0.1"></div>
                                <div class="search-space-param"><label for="search-ki-min">Ki Min:</label><input type="number" id="search-ki-min" value="0" step="0.01"></div>
                                <div class="search-space-param"><label for="search-ki-max">Ki Max:</label><input type="number" id="search-ki-max" value="0" step="0.01"></div>
                                <div class="search-space-param"><label for="search-kd-min">Kd Min:</label><input type="number" id="search-kd-min" value="0" step="0.01"></div>
                                <div class="search-space-param"><label for="search-kd-max">Kd Max:</label><input type="number" id="search-kd-max" value="5" step="0.01"></div>
                            </div>
                        </div>
                        <div class="config-section">
                            <h4>üß™ Parametry Testu</h4>
                            <div style="text-align: left; margin-bottom: 10px;"><label><input type="checkbox" id="test-with-impulse" checked> Test z impulsem (skok odpowiedzi)</label></div>
                            <div style="text-align: left;"><label><input type="checkbox" id="include-ki-checkbox"> Uwzglƒôdnij strojenie Ki</label></div>
                        </div>
                    </div>

                    <!-- Zak≈Çadka 2: Metody -->
                    <div class="autotune-main-content" data-tab="methods">
                        <div class="method-tabs">
                            <button class="method-tab active" data-method="ga">üß¨ Algorytm Genetyczny</button>
                            <button class="method-tab" data-method="pso">üåÄ PSO</button>
                            <button class="method-tab" data-method="zn">üìä Ziegler-Nichols</button>
                            <button class="method-tab" data-method="bayesian">üß† Optymalizacja Bayesowska</button>
                        </div>
                        <div class="method-content active" data-method="ga">
                            <div class="method-config">
                                <div><label for="ga-population">Rozmiar populacji:</label><input type="number" id="ga-population" value="10" min="5" max="100"></div>
                                <div><label for="ga-generations">Liczba pokole≈Ñ:</label><input type="number" id="ga-generations" value="10" min="5" max="100"></div>
                                <div><label for="ga-mutation">Wska≈∫nik mutacji (%):</label><input type="number" id="ga-mutation" value="10" min="0" max="100" step="1"></div>
                                <div><label for="ga-crossover">Wska≈∫nik krzy≈ºowania (%):</label><input type="number" id="ga-crossover" value="70" min="0" max="100" step="1"></div>
                                <div style="justify-content: center;"><label><input type="checkbox" id="ga-elitism" checked> Elitaryzm</label></div>
                            </div>
                        </div>
                        <div class="method-content" data-method="pso">
                            <div class="method-config">
                                <div><label for="pso-particles">Liczba czƒÖstek:</label><input type="number" id="pso-particles" value="20" min="10" max="100"></div>
                                <div><label for="pso-iterations">Liczba iteracji:</label><input type="number" id="pso-iterations" value="30" min="10" max="100"></div>
                                <div><label for="pso-inertia">Waga bezw≈Çadno≈õci:</label><input type="number" id="pso-inertia" value="0.7" min="0" max="1" step="0.01"></div>
                                <div><label for="pso-cognitive">Waga poznawcza:</label><input type="number" id="pso-cognitive" value="1.5" min="0" max="3" step="0.1"></div>
                                <div><label for="pso-social">Waga spo≈Çeczna:</label><input type="number" id="pso-social" value="1.5" min="0" max="3" step="0.1"></div>
                            </div>
                        </div>
                        <div class="method-content" data-method="zn">
                             <div class="method-config">
                                <div><label for="zn-amplitude">Amplituda przeka≈∫nika:</label><input type="number" id="zn-amplitude" value="2.0" min="0.5" max="10" step="0.5"></div>
                                <div><label for="zn-min-cycles">Minimalna liczba cykli:</label><input type="number" id="zn-min-cycles" value="3" min="2" max="10"></div>
                            </div>
                        </div>
                        <div class="method-content" data-method="bayesian">
                            <div class="method-config">
                                <div><label for="bayesian-iterations">Liczba iteracji:</label><input type="number" id="bayesian-iterations" value="25" min="10" max="50"></div>
                                <div><label for="bayesian-initial">PoczƒÖtkowe pr√≥bki losowe:</label><input type="number" id="bayesian-initial" value="5" min="3" max="10"></div>
                                <div><label for="bayesian-acquisition">Funkcja akwizycji:</label>
                                    <select id="bayesian-acquisition" style="padding: 8px; background: #20232a; border: 1px solid #61dafb; border-radius: 4px; color: #ffffff;">
                                        <option value="ei">Expected Improvement (EI)</option>
                                        <option value="ucb">Upper Confidence Bound (UCB)</option>
                                        <option value="pi">Probability of Improvement (PI)</option>
                                    </select>
                                </div>
                                <div><label for="bayesian-xi">Parametr eksploracji (Œæ):</label><input type="number" id="bayesian-xi" value="0.01" min="0" max="1" step="0.01"></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Zak≈Çadka 3: Zbi√≥r Danych -->
                    
                </div>

                <!-- Panel Postƒôpu Strojenia (domy≈õlnie ukryty) -->
                <div id="tuning-progress-panel">
                    <h4>üìä Postƒôp Optymalizacji</h4>
                    <div class="progress-info">
                        <p>Status: <span id="tuning-status-text">Oczekuje</span></p>
                        <p>Iteracja: <span id="current-iteration">0</span> / <span id="total-iterations">0</span></p>
                    </div>
                    <div id="fitness-chart-container"><canvas id="fitness-chart"></canvas></div>
                    <div class="current-best">
                        <h4>üèÜ Najlepsze Znalezione Parametry</h4>
                        <div class="current-best-grid">
                            <div><strong>Kp:</strong> <span id="best-kp">---</span></div>
                            <div><strong>Ki:</strong> <span id="best-ki">---</span></div>
                            <div><strong>Kd:</strong> <span id="best-kd">---</span></div>
                            <div style="grid-column: 1 / -1;"><strong>Fitness:</strong> <span id="best-fitness">---</span></div>
                        </div>
                        <button id="apply-best-btn" style="width:100%; margin-top:10px; background-color: #a2f279;" disabled>‚úÖ Zastosuj Najlepsze</button>
                    </div>
                    <div class="recent-results" style="margin-top: 15px; text-align: left;">
                        <h4>üïí Ostatnie 5 pr√≥b</h4>
                        <div id="recent-results-list" style="background:#20232a; border:1px solid #4a4f58; border-radius:6px; padding:8px; font-family: monospace; white-space: pre-wrap; min-height: 40px;">
                            Brak danych.
                        </div>
                        <button id="open-tuning-history-btn" class="btn-small" style="margin-top:10px;">üìú Historia i Eksport</button>
                    </div>
                </div>

                <!-- G≈Ç√≥wne Przyciski SterujƒÖce (widoczne tylko w zak≈Çadce 'Metody Optymalizacji') -->
                <div class="tuning-controls" id="tuning-controls-bar">
                    <button id="start-tuning-btn">üöÄ Rozpocznij Strojenie</button>
                    <button id="pause-tuning-btn" disabled>‚è∏Ô∏è Pauza</button>
                    <button id="resume-tuning-btn" style="display:none;" disabled>‚ñ∂Ô∏è Wzn√≥w</button>
                    <button id="stop-tuning-btn" disabled>‚èπÔ∏è Zatrzymaj</button>
                </div>
            </div>
        </div>
        <div class="button-group" style="display:flex; gap:10px; justify-content:center; margin-top:20px; grid-column: 1 / -1;">
            <button id="loadBtn">Wczytaj z Robota</button>
            <button id="saveBtn">Zapisz na Robocie</button>
        </div>
    <div class="card" id="log-card" style="position: fixed; left: 0; right: 0; bottom: 0; z-index: 3000; margin: 0; border-radius: 0; padding-bottom: 0; box-shadow: 0 -4px 10px rgba(0,0,0,0.35);">
            <div style="display:flex; align-items:center; gap:10px; cursor:pointer;" id="log-toggle-bar" title="Rozwi≈Ñ/Zwi≈Ñ logi">
                <h2 style="margin: 0;">Logi</h2>
                <div style="margin-left:auto; display:flex; align-items:center; gap:10px;">
                    <label style="font-size:0.9em; color:#ccc; display:flex; align-items:center; gap:6px;">Autoscroll <input type="checkbox" id="logsAutoscroll" checked></label>
                    <button id="clearLogsBtn" class="btn-small" style="background:#f7b731;">Wyczy≈õƒá</button>
                </div>
            </div>
            <div id="log-history" style="max-height: 40vh; overflow-y: auto; display: none;"></div>
        </div>
    </div>
    <!-- Nowy modal: Mapowanie czujnika ‚Äì sekwencyjny kreator z auto-wykryciem obrotu > 90¬∞ -->
    
    <!-- Modal: Historia pr√≥b strojenia -->
    <div id="tuning-history-modal" class="modal-backdrop" style="display:none;">
        <div class="modal-content" style="max-width:1000px;">
            <h2>Historia wszystkich pr√≥b</h2>
            <div style="display:flex; gap:8px; margin-bottom:8px;">
                <button id="closeHistoryBtn" style="background:#ff6347;">Zamknij</button>
                <button id="exportHistoryCsvBtn" style="background:#61dafb;">Eksport CSV</button>
                <span id="historyCount" style="margin-left:auto; color:#aaa;"></span>
            </div>
            <div class="autotune-results-container">
                <table class="autotune-results-table" style="display:table;">
                    <thead>
                        <tr><th>#</th><th>Kp</th><th>Ki</th><th>Kd</th><th>Fitness</th><th>ITAE</th><th>Przeregul.</th><th>Akcja</th></tr>
                    </thead>
                    <tbody id="results-table-body"></tbody>
                </table>
            </div>
        </div>
    </div>
    <div id="sensor-mapping-modal" class="modal-backdrop" style="display:none;">
        <div class="modal-content">
            <h2>Mapowanie Czujnika (Orientacja) <span class="help-icon" id="sensorMappingHelp" title="Poka≈º/ukryj szczeg√≥≈ÇowƒÖ pomoc">?</span></h2>
            <div id="sensorMappingHelpText" class="help-text" style="margin-bottom:10px;" aria-hidden="true">
                <strong>Cel:</strong> Dopasowanie fizycznego monta≈ºu IMU do oczekiwanych osi sterowania robota.<br>
                <strong>Kroki:</strong> (1) Pozycja pionowa referencyjna. (2) Obr√≥t poziomy ‚â• 90¬∞. (3) Zapis korekcji.<br>
                <strong>Wp≈Çyw:</strong> Dzia≈Ça na wewnƒôtrzne wektory (akcelerometr/≈ºyroskop) u≈ºywane przez PID. Nie zmienia wizualizacji 3D (oddzielne mapowanie modelu).<br>
                <strong>Wymagane:</strong> Kalibracja IMU (System=3) dla najlepszej dok≈Çadno≈õci.<br>
                <em>Po zapisie sterowanie bƒôdzie korzystaƒá z poprawionych osi automatycznie.</em>
            </div>
            <div id="sensorWizardStepInfo" style="margin:6px 0; font-size:12px; color:#aaa;">Krok <span id="sensorWizardStepNo">1</span>/3</div>
            <div id="sensorWizardText" style="text-align:left; font-size:0.95em; line-height:1.5; background:#101014; border:1px solid #2a2a35; padding:12px; border-radius:8px;">
                <!-- dynamiczna instrukcja -->
            </div>
            <div id="sensorWizardHint" style="margin-top:8px; font-size:0.85em; color:#bbb;">
                <!-- dynamiczne podpowiedzi -->
            </div>
            <div id="sensorWizardProgress" style="margin-top:12px; font-family:monospace; background:#111; border:1px solid #333; border-radius:6px; padding:8px; text-align:left;">
                [ ] Pion | [ ] Rotacja ‚â• 90¬∞ | [ ] Zapis
            </div>
            <div style="display:flex; gap:10px; justify-content:flex-end; margin-top:14px;">
                <button id="sensorWizardCancelBtn" style="background:#ff6347;">Anuluj</button>
                <button id="sensorWizardBackBtn" disabled>Wstecz</button>
                <button id="sensorWizardNextBtn" style="background:#61dafb;">Dalej</button>
            </div>
        </div>
    </div>
    <!-- Modal mapowania modelu 3D -->
    <div id="model-mapping-modal" class="modal-backdrop" style="display:none;">
        <div class="modal-content">
            <h2>Mapowanie Modelu 3D (Wizualizacja) <span class="help-icon" id="modelMappingHelp" title="Poka≈º/ukryj szczeg√≥≈ÇowƒÖ pomoc">?</span></h2>
            <div id="modelMappingHelpText" class="help-text" style="margin-bottom:10px;" aria-hidden="true">
                <strong>Co to robi?</strong> Przekszta≈Çca kƒÖty Euler'a (pochodne z kwaternionu) na osie sceny 3D.<br>
                <strong>Kiedy u≈ºyƒá?</strong> Je≈õli model 3D reaguje w niew≈Ça≈õciwych osiach albo odwrotnie ni≈º oczekujesz.<br>
                <strong>≈πr√≥d≈Ça:</strong> Pitch/Yaw/Roll liczone z kwaternionu (standard ZYX).<br>
                <strong>Znak:</strong> U≈ºyj -1 aby odwr√≥ciƒá kierunek osi bez zmiany logiki sterowania.<br>
                <em>Zmiany nie wp≈ÇywajƒÖ na kontrolƒô robota ‚Äì tylko na wizualizacjƒô.</em>
            </div>
            <p style="text-align:left; font-size:0.85em; line-height:1.4;" title="Tylko wizualizacja, nie sterowanie">Okre≈õl, kt√≥re sk≈Çadowe kƒÖt√≥w Euler'a majƒÖ zasilaƒá osie modelu 3D oraz ich znak.</p>
            <div class="model-mapping-row" title="≈πr√≥d≈Ço oraz znak dla osi Pitch modelu">
                <strong>Pitch:</strong>
                <select id="modelPitchSource" title="Wybierz z kt√≥rej osi Euler bƒôdzie pochodziƒá Pitch modelu">
                    <option value="0">Pitch</option>
                    <option value="1">Yaw</option>
                    <option value="2">Roll</option>
                </select>
                <div class="sign-toggle" id="modelPitchSign" title="Znak osi Pitch">
                    <button data-sign="1" class="active" title="Dodatni kierunek">+1</button>
                    <button data-sign="-1" title="Odwr√≥ƒá kierunek">-1</button>
                </div>
            </div>
            <div class="model-mapping-row" title="≈πr√≥d≈Ço oraz znak dla osi Yaw modelu">
                <strong>Yaw:</strong>
                <select id="modelYawSource" title="Wybierz z kt√≥rej osi Euler bƒôdzie pochodziƒá Yaw modelu">
                    <option value="0">Pitch</option>
                    <option value="1">Yaw</option>
                    <option value="2">Roll</option>
                </select>
                <div class="sign-toggle" id="modelYawSign" title="Znak osi Yaw">
                    <button data-sign="1" class="active" title="Dodatni kierunek">+1</button>
                    <button data-sign="-1" title="Odwr√≥ƒá kierunek">-1</button>
                </div>
            </div>
            <div class="model-mapping-row" title="≈πr√≥d≈Ço oraz znak dla osi Roll modelu">
                <strong>Roll:</strong>
                <select id="modelRollSource" title="Wybierz z kt√≥rej osi Euler bƒôdzie pochodziƒá Roll modelu">
                    <option value="0">Pitch</option>
                    <option value="1">Yaw</option>
                    <option value="2">Roll</option>
                </select>
                <div class="sign-toggle" id="modelRollSign" title="Znak osi Roll">
                    <button data-sign="1" class="active" title="Dodatni kierunek">+1</button>
                    <button data-sign="-1" title="Odwr√≥ƒá kierunek">-1</button>
                </div>
            </div>
            <div id="model-mapping-current" title="Aktualna konfiguracja mapowania">Brak danych mapowania.</div>
            <div style="display:flex; gap:10px; margin-top:12px;">
                <button id="modelMappingLoadBtn" style="flex:1; background:#61dafb;" title="Pobierz aktualne warto≈õci z EEPROM">Wczytaj</button>
                <button id="modelMappingSaveBtn" style="flex:1; background:#a2f279;" title="Zapisz bie≈ºƒÖce ustawienia do EEPROM">Zapisz</button>
                <button id="modelMappingResetBtn" style="flex:1; background:#f7b731;" title="Przywr√≥ƒá warto≈õci domy≈õlne (identity)">Domy≈õlne</button>
            </div>
            <button id="modelMappingCloseBtn" style="width:100%; margin-top:14px; background:#ff6347;" title="Zamknij okno">Zamknij</button>
        </div>
    </div>

<script>
    const AppState = {
        isConnected: false, isSynced: false, isApplyingConfig: false, lastKnownRobotState: 'IDLE',
        isSequenceRunning: false, isTuningActive: false, activeTuningMethod: '', syncTimeout: null,
        isSyncingConfig: false, tempParams: {}, tempTuningParams: {}, tempStates: {}
    };
    let currentSequenceStep = 0; const MAX_SEQUENCE_STEPS = 15;
    
    // === Monta≈º: proste przyciski wysy≈ÇajƒÖce komendy do firmware ===
    function openMountCalibModal(){ document.getElementById('mount-calib-modal').style.display='flex'; }
    function closeMountCalibModal(){ document.getElementById('mount-calib-modal').style.display='none'; }
    // Legacy IMU axis mapping wizard ‚Äì completely removed in Quaternion-First UI
    // (previous functions runWizardStep/processWizardTelemetry/finalizeMapping deleted)

    // REFACTORED: Consolidated parameter mapping - includes ALL configurable parameters
    const parameterMapping = { 
        // PID parameters
    'balanceKpInput': 'kp_b', 'balanceKiInput': 'ki_b', 'balanceKdInput': 'kd_b', 'balanceFilterAlphaInput': 'balance_pid_derivative_filter_alpha', 'balanceIntegralLimitInput': 'balance_pid_integral_limit', 'joystickAngleSensitivityInput': 'joystick_angle_sensitivity', 'speedKpInput': 'kp_s', 'speedKiInput': 'ki_s', 'speedKdInput': 'kd_s', 'speedFilterAlphaInput': 'speed_pid_filter_alpha', 'maxTargetAngleInput': 'max_target_angle_from_speed_pid', 'speedIntegralLimitInput': 'speed_pid_integral_limit', 'speedDeadbandInput': 'speed_pid_deadband', 'positionKpInput': 'kp_p', 'positionKiInput': 'ki_p', 'positionKdInput': 'kd_p', 'positionFilterAlphaInput': 'position_pid_filter_alpha', 'maxTargetSpeedInput': 'max_target_speed_from_pos_pid', 'positionIntegralLimitInput': 'position_pid_integral_limit', 'positionDeadbandInput': 'position_pid_deadband', 'rotationKpInput': 'kp_r', 'rotationKdInput': 'kd_r', 'headingKpInput': 'kp_h', 'headingKiInput': 'ki_h', 'headingKdInput': 'kd_h', 'rotationToPwmScaleInput': 'rotation_to_pwm_scale', 
        // Joystick and mechanical parameters
        'joystickSensitivityInput': 'joystick_sensitivity', 'expoJoystickInput': 'expo_joystick', 'maxSpeedJoystickInput': 'max_speed_joystick', 'turnFactorInput': 'turn_factor', 'joystickDeadzoneInput': 'joystick_deadzone', 'wheelDiameterInput': 'wheel_diameter_cm', 'trackWidthInput': 'track_width_cm', 'encoderPprInput': 'encoder_ppr', 'minPwmLeftFwdInput': 'min_pwm_left_fwd', 'minPwmLeftBwdInput': 'min_pwm_left_bwd', 'minPwmRightFwdInput': 'min_pwm_right_fwd', 'minPwmRightBwdInput': 'min_pwm_right_bwd',
        // Trim parameters
        'trimValueDisplay': 'trim_angle', 'rollTrimValueDisplay': 'roll_trim',
        // Auto-tuning parameters (safety, space, weights, GA, PSO, ZN)
        'safetyMaxAngle': 'safety_max_angle', 'safetyMaxSpeed': 'safety_max_speed', 'safetyMaxPwm': 'safety_max_pwm',
    'ga-kp-min': 'space_kp_min', 'ga-kp-max': 'space_kp_max', 'ga-ki-min': 'space_ki_min', 'ga-ki-max': 'space_ki_max', 'ga-kd-min': 'space_kd_min', 'ga-kd-max': 'space_kd_max',
    'include-ki-checkbox': 'search_ki',
        'ga-weight-itae': 'weights_itae', 'ga-weight-overshoot': 'weights_overshoot', 'ga-weight-control-effort': 'weights_control_effort',
        'ga-generations': 'ga_generations', 'ga-population': 'ga_population', 'ga-mutation-rate': 'ga_mutation_rate', 'ga-elitism': 'ga_elitism', 'ga-adaptive': 'ga_adaptive', 'ga-convergence-check': 'ga_convergence_check',
        'pso-iterations': 'pso_iterations', 'pso-particles': 'pso_particles', 'pso-inertia': 'pso_inertia', 'pso-adaptive-inertia': 'pso_adaptive_inertia', 'pso-velocity-clamp': 'pso_velocity_clamp', 'pso-neighborhood': 'pso_neighborhood',
        'zn-trial-duration': 'tuning_trial_duration_ms', 'zn-max-amplitude': 'zn_amplitude'
    };
    
    let bleDevice, rxCharacteristic, txCharacteristic;
    const SERVICE_UUID = "4fafc201-1fb5-459e-8fcc-c5c9c331914b", RX_UUID = "beb5483e-36e1-4688-b7f5-ea07361b26a9", TX_UUID = "beb5483e-36e1-4688-b7f5-ea07361b26a8";
    let bleBuffer = '', bleMessageQueue = [], isSendingBleMessage = false; const bleChunks = new Map();
    const BLE_SEND_INTERVAL = 20;
    
    let joystickCenter, joystickRadius, knobRadius, isDragging = false, lastJoystickSendTime = 0;
    const JOYSTICK_SEND_INTERVAL = 20;
    
    let gamepadIndex = null, lastGamepadState = [], gamepadMappings = {}; const GAMEPAD_MAPPING_KEY = 'pid_gamepad_mappings_v3';
    let isMappingButton = false, actionToMap = null;
    
    const CUSTOM_PRESET_PREFIX = 'pid_custom_preset_v4_';
    // Pitch trim: UI pokazuje warto≈õci w stopniach. Firmware stosuje TRIM w kwaternionie (Quaternion-First),
    // wiƒôc ustawienie trim = -raw_pitch zeruje wskazanie pitch i wp≈Çywa na balans zgodnie z oczekiwaniem.
    // Podstawowe prze≈ÇƒÖczniki
    const availableActions = { 
        'toggle_balance': { label: 'Wlacz/Wylacz Balansowanie', elementId: 'balanceSwitch' },
        'toggle_hold_position': { label: 'Wlacz/Wylacz Trzymanie Pozycji', elementId: 'holdPositionSwitch' },
        'toggle_speed_mode': { label: 'Wlacz/Wylacz Tryb Predkosci', elementId: 'speedModeSwitch' },
        'emergency_stop': { label: 'STOP AWARYJNY', elementId: 'emergencyStopBtn' },
        'reset_zero': { label: 'Resetuj Osie', elementId: 'resetZeroBtn' }
    };
    const availableTelemetry = { 'pitch': { label: 'Pitch (Kat)', color: '#61dafb' }, 'roll': { label: 'Roll (Przechyl)', color: '#a2f279' }, 'speed': { label: 'Predkosc', color: '#f7b731'}, 'target_speed': { label: 'Predkosc Zadana', color: '#ff9f43' }, 'output': { label: 'Wyjscie PID', color: '#ff6347'}, 'encoder_left': { label: 'Enkoder L', color: '#9966ff' }, 'encoder_right': { label: 'Enkoder P', color: '#cc66ff' } };
    const builtInPresetsData = { '1': { name: "1. PID Zbalansowany (Startowy)", params: { balanceKpInput: 95.0, balanceKiInput: 0.0, balanceKdInput: 3.23 }}, '2': { name: "2. PID Mieciutki (Plynny)", params: { balanceKpInput: 80.0, balanceKiInput: 0.0, balanceKdInput: 2.8 }}, '3': { name: "3. PID Agresywny (Sztywny)", params: { balanceKpInput: 110.0, balanceKiInput: 0.0, balanceKdInput: 4.0 }} };
    let skyDome;
    let scene3D, camera3D, renderer3D, controls3D, robotPivot, leftWheel, rightWheel, groundMesh, groundTexture, robotPerspectiveZoom = 40;
    let currentEncoderLeft = 0, currentEncoderRight = 0;
    let isAnimation3DEnabled = true, isMovement3DEnabled = false, lastEncoderAvg = 0;
    window.telemetryData = {}; 
    let isCalibrationModalShown = false;
    
    let pitchHistory = [], speedHistory = [];
    const HISTORY_LENGTH = 600;
    let lastTelemetryUpdateTime = 0;
    const TELEMETRY_UPDATE_INTERVAL = 1000; 

    document.addEventListener('DOMContentLoaded', () => {
        initJoystick(); 
        initSignalAnalyzerChart();
        setupSignalChartControls();
        setupSignalAnalyzerControls();
        populatePresetSelect();
        setupNumericInputs(); 
        // Zamiana legacy: wywo≈Çujemy nowy zestaw listener√≥w parametr√≥w zamiast usuniƒôtej funkcji.
        if (typeof setupParameterListeners === 'function') {
            setupParameterListeners();
        }
        setupManualTuneButtons(); 
        // Nowy modal Mapowanie Czujnika ‚Äì korzysta z istniejƒÖcych komend mount_calib2_* (backend ju≈º implementuje kwaternion-first)
        // Sekwencyjny kreator mapowania czujnika (auto-wykrycie rotacji ‚â• 90¬∞)
        let sensorWizard = { step: 0, rotStartYaw: null, monitorId: null, progress: {upright:false, rotation:false, saved:false} };
        function openSensorMappingModal(){
            const m=document.getElementById('sensor-mapping-modal'); if(!m) return; m.style.display='flex';
            sensorWizard = { step:0, rotStartYaw:null, monitorId:null, progress:{upright:false, rotation:false, saved:false} };
            updateSensorWizardUI();
        }
        function closeSensorMappingModal(){ const m=document.getElementById('sensor-mapping-modal'); if(!m) return; if(sensorWizard.monitorId){ clearInterval(sensorWizard.monitorId); sensorWizard.monitorId=null; } m.style.display='none'; }
        function setWizardProgress(){
            const el = document.getElementById('sensorWizardProgress');
            if(!el) return;
            const p = sensorWizard.progress;
            el.textContent = `[${p.upright?'x':' '}] Pion | [${p.rotation?'x':' '}] Rotacja ‚â• 90¬∞ | [${p.saved?'x':' '}] Zapis`;
            // Je≈õli mamy zapisanƒÖ korekcjƒô, poka≈º skr√≥cony kwaternion
            if(p.saved && window.lastMountCorr){
                const {qw,qx,qy,qz}=window.lastMountCorr;
                const preview = `\nqcorr: w=${qw.toFixed(3)} x=${qx.toFixed(3)} y=${qy.toFixed(3)} z=${qz.toFixed(3)}`;
                el.textContent += preview;
            }
        }
        function setWizardStepNo(){ const n=document.getElementById('sensorWizardStepNo'); if(n) n.textContent = (sensorWizard.step+1).toString(); }
        function getCurrentYawDeg(){
            const td = window.telemetryData || {}; const { qw, qx, qy, qz } = td; if (typeof qw !== 'number') return null;
            const eul = computeEulerFromQuaternion(qw, qx, qy, qz); return eul ? eul.yaw : null;
        }
        function angleDeltaDeg(a,b){ if (a===null||b===null) return null; let d = ((a - b + 540) % 360) - 180; return Math.abs(d); }
        function updateSensorWizardUI(){
            setWizardStepNo(); setWizardProgress();
            const t = document.getElementById('sensorWizardText'); const hint = document.getElementById('sensorWizardHint');
            const back = document.getElementById('sensorWizardBackBtn'); const next = document.getElementById('sensorWizardNextBtn');
            if(!t||!hint||!back||!next) return;
            if (sensorWizard.step === 0){
                back.disabled = true; next.disabled = false; next.textContent = 'Dalej';
                t.innerHTML = '1) Postaw robota pionowo (ko≈Ça w d√≥≈Ç, prosto) na stabilnej powierzchni i poczekaj a≈º siƒô uspokoi.<br>Po klikniƒôciu Dalej zarejestrujemy bazowƒÖ orientacjƒô.';
                hint.textContent = 'Warunek: kalibracja IMU (Sys=3). Je≈õli nie, wykonaj kalibracjƒô przed kontynuacjƒÖ.';
            } else if (sensorWizard.step === 1){
                back.disabled = false; next.disabled = true; next.textContent = 'Czekam na ‚â• 90¬∞';
                t.innerHTML = '2) Obracaj robota powoli zgodnie z ruchem wskaz√≥wek zegara (poziomo).<br>Krok zako≈Ñczy siƒô automatycznie po wykryciu obrotu ‚â• 90¬∞.';
                hint.textContent = 'Nie podno≈õ robota ‚Äì trzymaj ko≈Ça w d√≥≈Ç. Mo≈ºesz obracaƒá wiƒôcej (180‚Äì360¬∞) ‚Äì wystarczy przekroczyƒá 90¬∞.';
            } else {
                back.disabled = false; next.disabled = false; next.textContent = 'Zapisz';
                let extra = '';
                if(window.lastMountCorr){ const {qw,qx,qy,qz}=window.lastMountCorr; extra = `<div style="margin-top:8px; font-size:0.8em; color:#9fa;">Aktualne (ostatnie) qcorr:<br>w=${qw.toFixed(4)} x=${qx.toFixed(4)} y=${qy.toFixed(4)} z=${qz.toFixed(4)}</div>`; }
                t.innerHTML = '3) Zapisz ustawienia mapowania. Zmiany zostanƒÖ utrwalone w pamiƒôci i zacznƒÖ dzia≈Çaƒá natychmiast.' + extra;
                hint.textContent = 'Po zapisie osie w Dashboard i w modelu 3D bƒôdƒÖ ju≈º skorygowane.';
            }
        }
        function startRotationMonitor(){
            // zapamiƒôtaj yaw startowy i rozpocznij monitoring co 100ms
            sensorWizard.rotStartYaw = getCurrentYawDeg();
            if (sensorWizard.monitorId) { clearInterval(sensorWizard.monitorId); sensorWizard.monitorId = null; }
            sensorWizard.monitorId = setInterval(()=>{
                const cy = getCurrentYawDeg(); const d = angleDeltaDeg(cy, sensorWizard.rotStartYaw);
                if (d!==null && d >= 90){
                    clearInterval(sensorWizard.monitorId); sensorWizard.monitorId = null;
                    // auto-zamkniƒôcie kroku rotacji
                    sendBleMessage({type:'sensor_map_capture_rot_end'});
                    sensorWizard.progress.rotation = true;
                    sensorWizard.step = 2; updateSensorWizardUI(); setWizardProgress();
                    addLogMessage('[UI] Wykryto rotacjƒô ‚â• 90¬∞. Przechodzƒô do kroku Zapis.', 'success');
                }
            }, 100);
        }
        document.getElementById('sensorMappingBtn')?.addEventListener('click', ()=> { openSensorMappingModal(); });
        document.getElementById('sensorWizardCancelBtn')?.addEventListener('click', ()=> { sendBleMessage({type:'sensor_map_cancel'}); closeSensorMappingModal(); });
        document.getElementById('sensorWizardBackBtn')?.addEventListener('click', ()=> {
            if (sensorWizard.step === 0) return; // nic
            if (sensorWizard.step === 1){ if (sensorWizard.monitorId){ clearInterval(sensorWizard.monitorId); sensorWizard.monitorId=null; } }
            sensorWizard.step -= 1; updateSensorWizardUI();
        });
        document.getElementById('sensorWizardNextBtn')?.addEventListener('click', async ()=>{
            if (sensorWizard.step === 0){
                // Start i rejestracja pozycji pionowej
                sendBleMessage({type:'sensor_map_start'});
                await delay(80);
                sendBleMessage({type:'sensor_map_capture_upright'});
                sensorWizard.progress.upright = true; setWizardProgress();
                // Rozpocznij krok rotacji i monitoring
                sendBleMessage({type:'sensor_map_capture_rot_start'});
                sensorWizard.step = 1; updateSensorWizardUI(); startRotationMonitor();
            } else if (sensorWizard.step === 2){
                // Zapis
                sendBleMessage({type:'sensor_map_commit'});
                sensorWizard.progress.saved = true; setWizardProgress();
                closeSensorMappingModal();
            }
        });
        setupGamepadMappingModal(); 
        setupDpadControls(); 
        setupSequenceControls();
        initPathVisualization();
        loadGamepadMappings(); 
        renderMappingModal();
        // Toggle pomocy dla mapowania czujnika
        const smHelp = document.getElementById('sensorMappingHelp');
        const smHelpBox = document.getElementById('sensorMappingHelpText');
        if (smHelp && smHelpBox){
            smHelp.addEventListener('click', ()=>{
                smHelpBox.classList.toggle('visible');
                smHelpBox.setAttribute('aria-hidden', smHelpBox.classList.contains('visible') ? 'false' : 'true');
            });
        }
        pollGamepad(); 
        window.addEventListener('resize', initJoystick); 
        init3DVisualization(); 
        animate3D(); 
        setTuningUiLock(false, '');
    initAutotuneTuningChart();
    // Start strojenia dostƒôpny dopiero po wyborze metody
    const startBtnInit = document.getElementById('start-tuning-btn');
    if (startBtnInit) startBtnInit.disabled = true;
        setupAutotuningTabs();
        // Pinned bottom logs panel wiring (toggle + clear)
        const logToggleBar = document.getElementById('log-toggle-bar');
        const logHistoryBox = document.getElementById('log-history');
        const logsAutoscroll = document.getElementById('logsAutoscroll');
        document.getElementById('clearLogsBtn')?.addEventListener('click', ()=>{ allLogsBuffer.length = 0; renderAllLogs(true); });
        if (logToggleBar && logHistoryBox) {
            const logCard = document.getElementById('log-card');
            const updateBodyPadding = () => {
                // Ustal ≈ÇƒÖcznƒÖ wysoko≈õƒá paska tytu≈Çu i zawarto≈õci log√≥w, aby nie zas≈Çaniaƒá element√≥w na dole (np. Wczytaj/Zapisz)
                const barH = logToggleBar.getBoundingClientRect().height;
                const listH = logCard.classList.contains('open') ? logHistoryBox.getBoundingClientRect().height : 0;
                const total = Math.ceil(barH + listH);
                // Ustaw zmiennƒÖ CSS na body (zmienne dziedziczƒÖ w d√≥≈Ç, nie do g√≥ry)
                document.body.style.setProperty('--log-card-total', total + 'px');
                document.body.classList.toggle('logs-open', logCard.classList.contains('open'));
            };
            logToggleBar.addEventListener('click', (e)=>{
                if (e.target && (e.target.id === 'logsAutoscroll' || e.target.id === 'clearLogsBtn' || e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON')) return;
                logCard.classList.toggle('open');
                if (logCard.classList.contains('open')) {
                    renderAllLogs(true);
                }
                // Po prze≈ÇƒÖczeniu zaktualizuj padding
                setTimeout(updateBodyPadding, 0);
            });
            // Reaguj na resize aby trzymaƒá poprawny padding
            window.addEventListener('resize', updateBodyPadding);
        }
    // Przyciski robotowe (loadBtn/saveBtn) majƒÖ w≈Çasne listenery dalej w kodzie (setupParameterListeners)
    // Drugi wywo≈Çanie setupParameterListeners usuniƒôte (pierwsze ju≈º wykonane wy≈ºej) aby uniknƒÖƒá podw√≥jnych listener√≥w.
        // Domy≈õlnie nie szukamy Ki
        const kiChk = document.getElementById('include-ki-checkbox');
        if (kiChk) {
            kiChk.checked = false;
            kiChk.addEventListener('change', () => {
                updateSearchSpaceInputs();
                // Wy≈õlij do robota preferencjƒô szukania Ki
                sendBleMessage({ type: 'set_tuning_config_param', key: 'search_ki', value: kiChk.checked });
            });
        }

        // Obs≈Çuga modala historii pr√≥b
        const openHistBtn = document.getElementById('open-tuning-history-btn');
        const histModal = document.getElementById('tuning-history-modal');
        if (openHistBtn && histModal) {
            openHistBtn.addEventListener('click', ()=>{ histModal.style.display='flex'; refreshHistoryTable(); });
        }
        document.getElementById('closeHistoryBtn')?.addEventListener('click', ()=>{ histModal.style.display='none'; });
        document.getElementById('exportHistoryCsvBtn')?.addEventListener('click', exportHistoryCsv);
    });
    // Osobny bufor log√≥w systemowych (kana≈Ç 'log' z robota i wa≈ºne wpisy UI)
    // Pojedynczy, scalony bufor log√≥w
    const allLogsBuffer = [];
    const ALL_LOGS_MAX = 2000;
    function pushLog(message, level='info'){
        const ts = new Date().toLocaleTimeString();
        allLogsBuffer.push({ts, level, message});
        if (allLogsBuffer.length > ALL_LOGS_MAX) allLogsBuffer.shift();
    const logHistEl = document.getElementById('log-history');
    const autoEl = document.getElementById('logsAutoscroll');
    if (logHistEl && logHistEl.style.display === 'block' && autoEl && autoEl.checked) {
            renderAllLogs(true);
        }
    }
    function renderAllLogs(keepScrollBottom=false){
        const box = document.getElementById('log-history'); if(!box) return;
        const wasBottom = (box.scrollTop + box.clientHeight + 8) >= box.scrollHeight;
        box.innerHTML = '';
        for (const row of allLogsBuffer){
            const div = document.createElement('div');
            let color = '#ccc';
            if (row.level === 'error') color = '#ff6347';
            else if (row.level === 'warn') color = '#f7b731';
            else if (row.level === 'success') color = '#a2f279';
            div.style.color = color;
            div.textContent = `[${row.ts}] ${row.message}`;
            box.appendChild(div);
        }
        if (keepScrollBottom || wasBottom){ box.scrollTop = box.scrollHeight; }
    }

    // --- Model Mapping (wizualizacja 3D) ---
    let modelMapping = { pitch:{source:0,sign:1}, yaw:{source:1,sign:1}, roll:{source:2,sign:1} }; // domy≈õlne: identity
    function openModelMappingModal(){ const m=document.getElementById('model-mapping-modal'); if(!m) return; m.style.display='flex'; updateModelMappingUI(); }
    function closeModelMappingModal(){ const m=document.getElementById('model-mapping-modal'); if(!m) return; m.style.display='none'; }
    function updateModelMappingUI(){
        // Ustaw dropdowny
        const sPitch=document.getElementById('modelPitchSource'); const sYaw=document.getElementById('modelYawSource'); const sRoll=document.getElementById('modelRollSource');
        if(sPitch) sPitch.value=String(modelMapping.pitch.source);
        if(sYaw) sYaw.value=String(modelMapping.yaw.source);
        if(sRoll) sRoll.value=String(modelMapping.roll.source);
        // Ustaw przyciski sign
        setSignButtons('modelPitchSign', modelMapping.pitch.sign);
        setSignButtons('modelYawSign', modelMapping.yaw.sign);
        setSignButtons('modelRollSign', modelMapping.roll.sign);
        // PodglƒÖd
        const cur=document.getElementById('model-mapping-current');
        if(cur){ cur.textContent = `pitch: src=${modelMapping.pitch.source} sign=${modelMapping.pitch.sign} | yaw: src=${modelMapping.yaw.source} sign=${modelMapping.yaw.sign} | roll: src=${modelMapping.roll.source} sign=${modelMapping.roll.sign}`; }
    }
    function setSignButtons(containerId, sign){ const c=document.getElementById(containerId); if(!c) return; c.querySelectorAll('button').forEach(btn=>{ const s=parseInt(btn.dataset.sign); if(s===sign){ btn.classList.add('active'); } else { btn.classList.remove('active'); } }); }
    function gatherModelMappingFromUI(){ modelMapping.pitch.source=parseInt(document.getElementById('modelPitchSource').value); modelMapping.yaw.source=parseInt(document.getElementById('modelYawSource').value); modelMapping.roll.source=parseInt(document.getElementById('modelRollSource').value); modelMapping.pitch.sign = getActiveSign('modelPitchSign'); modelMapping.yaw.sign = getActiveSign('modelYawSign'); modelMapping.roll.sign = getActiveSign('modelRollSign'); }
    function getActiveSign(containerId){ const c=document.getElementById(containerId); if(!c) return 1; const active=c.querySelector('button.active'); return active? parseInt(active.dataset.sign):1; }
    function resetModelMapping(){ modelMapping = { pitch:{source:0,sign:1}, yaw:{source:1,sign:1}, roll:{source:2,sign:1} }; updateModelMappingUI(); }
    function applyModelMappingToEuler(e){ // e={pitch,yaw,roll}; zwraca przemapowane
        const arr=[e.pitch, e.yaw, e.roll];
        return {
            pitch: (arr[modelMapping.pitch.source]||0) * modelMapping.pitch.sign,
            yaw: (arr[modelMapping.yaw.source]||0) * modelMapping.yaw.sign,
            roll: (arr[modelMapping.roll.source]||0) * modelMapping.roll.sign
        };
    }
    // Pod≈ÇƒÖczenie event√≥w modalu
    document.getElementById('modelMappingBtn')?.addEventListener('click', ()=> { openModelMappingModal(); sendBleMessage({type:'get_model_mapping'}); });
    document.getElementById('modelMappingCloseBtn')?.addEventListener('click', ()=> closeModelMappingModal());
    document.getElementById('modelMappingLoadBtn')?.addEventListener('click', ()=> { sendBleMessage({type:'get_model_mapping'}); });
    document.getElementById('modelMappingSaveBtn')?.addEventListener('click', ()=> { gatherModelMappingFromUI(); sendBleMessage({type:'set_model_mapping', mapping:modelMapping}); addLogMessage('[UI] Wyslano mapowanie modelu 3D do robota.', 'info'); });
    document.getElementById('modelMappingResetBtn')?.addEventListener('click', ()=> { resetModelMapping(); addLogMessage('[UI] Przywr√≥cono domy≈õlne mapowanie modelu (identity).', 'info'); });
    // Toggle pomocy w modalum model mapping
    const mmHelp = document.getElementById('modelMappingHelp');
    const mmHelpBox = document.getElementById('modelMappingHelpText');
    if(mmHelp && mmHelpBox){
        mmHelp.addEventListener('click', ()=>{
            mmHelpBox.classList.toggle('visible');
            mmHelpBox.setAttribute('aria-hidden', mmHelpBox.classList.contains('visible') ? 'false' : 'true');
        });
    }
    // Listenery znak√≥w
    ['modelPitchSign','modelYawSign','modelRollSign'].forEach(id=>{ const c=document.getElementById(id); if(!c) return; c.querySelectorAll('button').forEach(btn=>{ btn.addEventListener('click',()=>{ c.querySelectorAll('button').forEach(b=>b.classList.remove('active')); btn.classList.add('active'); }); }); });

    // --- Przeliczanie kƒÖt√≥w Euler‚Äôa z kwaternionu (telemetria: qw,qx,qy,qz) ---
    function computeEulerFromQuaternion(qw, qx, qy, qz) {
        try {
            if ([qw, qx, qy, qz].some(v => typeof v !== 'number' || Number.isNaN(v))) return null;
            // ZYX (yaw-pitch-roll) zgodnie z firmware (imu_math.h)
            const n = Math.hypot(qw, qx, qy, qz) || 1;
            qw /= n; qx /= n; qy /= n; qz /= n;
            const siny_cosp = 2 * (qw * qz + qx * qy);
            const cosy_cosp = 1 - 2 * (qy * qy + qz * qz);
            const yaw = Math.atan2(siny_cosp, cosy_cosp);
            const sinp = 2 * (qw * qy - qz * qx);
            const pitch = Math.abs(sinp) >= 1 ? Math.sign(sinp) * (Math.PI / 2) : Math.asin(sinp);
            const sinr_cosp = 2 * (qw * qx + qy * qz);
            const cosr_cosp = 1 - 2 * (qx * qx + qy * qy);
            const roll = Math.atan2(sinr_cosp, cosr_cosp);
            return {
                yaw: THREE.MathUtils.radToDeg(yaw),
                pitch: THREE.MathUtils.radToDeg(pitch),
                roll: THREE.MathUtils.radToDeg(roll)
            };
        } catch (_) { return null; }
    }

    // Usuniƒôto legacy mapowanie IMU (Quaternion-First). Euler liczony bezpo≈õrednio z kwaternionu.

    // Zwraca SUROWE kƒÖty Euler'a z aktualnej telemetrii kwaternionu (bez mapowania IMU)
    function getRawEuler() {
        if (!window.telemetryData) return { pitch: 0, yaw: 0, roll: 0 };
        const { qw, qx, qy, qz } = window.telemetryData;
        const eul = (typeof qw === 'number') ? computeEulerFromQuaternion(qw, qx, qy, qz) : null;
        return eul || { pitch: 0, yaw: 0, roll: 0 };
    }

    const debounce = (func, delay) => { let timeout; return function(...args) { const context = this; clearTimeout(timeout); timeout = setTimeout(() => func.apply(context, args), delay); }; };
    const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
    function addLogMessage(message, level = 'info') { pushLog(message, level); const el = document.getElementById('log-history'); if (el && el.style.display === 'block') { renderAllLogs(true); } }
    function clearLogs() { if (typeof allLogsBuffer !== 'undefined') { allLogsBuffer.length = 0; } const box = document.getElementById('log-history'); if (box) box.innerHTML = ''; }
    function toggleAccordion(header) {
        const content = header.nextElementSibling;
        header.classList.toggle('active');
        const isOpening = header.classList.contains('active');
        if (!isOpening) {
            content.classList.remove('auto-height');
            content.style.maxHeight = '0px';
            content.style.padding = '0px 15px';
        } else {
            // Specjalne traktowanie panelu strojenia: sta≈Ça wysoko≈õƒá po otwarciu
            if (content.classList.contains('autotune-pane')) {
                const desktopH = 600; // px
                const mobileVH = 70; // vh
                const isMobile = window.matchMedia('(max-width: 768px)').matches;
                if (isMobile) {
                    content.style.maxHeight = mobileVH + 'vh';
                } else {
                    content.style.maxHeight = desktopH + 'px';
                }
                content.style.overflow = 'hidden';
            } else {
                content.style.maxHeight = content.scrollHeight + 40 + 'px';
            }
            content.style.padding = '15px';
            setTimeout(() => {
                if (header.classList.contains('active') && !content.classList.contains('autotune-pane')) content.classList.add('auto-height');
            }, 450);
        }
    }
    function updateAccordionHeight(content) {
        if (content && content.classList.contains('active')) {
            content.classList.remove('auto-height');
            content.style.maxHeight = content.scrollHeight + 40 + 'px';
            // Ustaw auto po chwili by nie ucinaƒá p√≥≈∫niejszych element√≥w (np. pojawiajƒÖce siƒô help-texty)
            clearTimeout(content._autoTimer);
            content._autoTimer = setTimeout(() => {
                if (content.classList.contains('active')) content.classList.add('auto-height');
            }, 300);
        }
    }
    // Obserwator zmian dla dynamicznego dopasowania wysoko≈õci (np. rozwiniƒôcie wielu help-text)
    const accordionObserver = new MutationObserver(mutations => {
        mutations.forEach(m => {
            const content = m.target.closest && m.target.closest('.accordion-content');
            if (content && content.classList.contains('active')) {
                // Nie zmieniaj wysoko≈õci sta≈Çego panelu strojenia
                if (!content.classList.contains('autotune-pane')) {
                    updateAccordionHeight(content);
                }
            }
        });
    });
    document.addEventListener('DOMContentLoaded', () => {
        document.querySelectorAll('.accordion-content').forEach(ac => {
            accordionObserver.observe(ac, { childList: true, subtree: true });
        });
    });
    // Relokacja wykresu procesu strojenia pod aktywny przycisk URUCHOM
    function relocateAutotuneChart(method) {
        const chartWrapper = document.querySelector('.autotune-tuning-chart-wrapper');
        if (!chartWrapper) return;
        let targetBtn = null;
        if (method === 'zn-relay') targetBtn = document.getElementById('run-zn-test');
        else if (method === 'ga-genetic') targetBtn = document.getElementById('run-ga-tune');
        else if (method === 'pso-particle') targetBtn = document.getElementById('run-pso-tune');
        else if (method === 'single-tests') targetBtn = document.querySelector('.run-test-btn[data-test-type="step_response"]');
        if (!targetBtn) return;
        // Wstaw chart tu≈º za przyciskiem
        if (targetBtn.parentElement && targetBtn.parentElement.contains(targetBtn)) {
            // Unikaj wielokrotnego przenoszenia je≈õli ju≈º jest poni≈ºej
            if (chartWrapper._lastMethod !== method) {
                targetBtn.insertAdjacentElement('afterend', chartWrapper);
                chartWrapper._lastMethod = method;
                // Aktualizacja wysoko≈õci akordeonu
                const accordionContent = chartWrapper.closest('.accordion-content');
                updateAccordionHeight(accordionContent);
            }
        }
    }

    async function connectBLE() {
        addLogMessage('[UI] Prosze o wybranie urzadzenia Bluetooth...', 'info');
        try {
            bleDevice = await navigator.bluetooth.requestDevice({ filters: [{ name: 'RoboBala' }], optionalServices: [SERVICE_UUID] });
            addLogMessage(`[UI] Laczenie z ${bleDevice.name}...`, 'info');
            const connectBtn = document.getElementById('connectBleBtn'); connectBtn.disabled = true;
            document.getElementById('connectionText').textContent = 'Laczenie...';
            bleDevice.addEventListener('gattserverdisconnected', onDisconnected);
            const server = await bleDevice.gatt.connect(); const service = await server.getPrimaryService(SERVICE_UUID);
            rxCharacteristic = await service.getCharacteristic(RX_UUID); txCharacteristic = await service.getCharacteristic(TX_UUID);
            await txCharacteristic.startNotifications(); txCharacteristic.addEventListener('characteristicvaluechanged', handleBleNotification);
            AppState.isConnected = true; AppState.isSynced = false;
            document.getElementById('connectionStatus').className = 'status-indicator status-ok'; document.getElementById('connectionText').textContent = 'Polaczony';
            addLogMessage('[UI] Polaczono! Rozpoczynam synchronizacje...', 'success');
            document.body.classList.remove('ui-locked');
            document.getElementById('connectBleBtn').textContent = 'Synchronizowanie...';
            AppState.isSynced = false;
            AppState.tempParams = {};
            AppState.tempTuningParams = {};
            AppState.tempStates = {};
            sendBleMessage({ type: 'request_full_config' });
            // Brak IMU mapping w nowej architekturze
            clearTimeout(AppState.syncTimeout);
            AppState.syncTimeout = setTimeout(() => {
                if (!AppState.isSynced && AppState.isConnected) {
                    addLogMessage('[UI] BLAD: Timeout synchronizacji. Robot nie odpowiedzial na czas (20s).', 'error');
                    document.getElementById('connectionText').textContent = 'Blad synchronizacji';
                    document.getElementById('connectBleBtn').textContent = 'SPROBUJ PONOWNIE ZSYNCHRONIZOWAC'; document.getElementById('connectBleBtn').style.backgroundColor = '#ff6347'; document.getElementById('connectBleBtn').disabled = false;
                }
            }, 20000); // Timeout na ca≈ÇƒÖ operacjƒô synchronizacji
        } catch (error) { addLogMessage(`[UI] Blad polaczenia BLE: ${error}`, 'error'); onDisconnected(); }
    }
    
    function onDisconnected() { AppState.isConnected = false; AppState.isSynced = false; document.body.classList.add('ui-locked'); if(AppState.isTuningActive) handleCancel(); const connectBtn = document.getElementById('connectBleBtn'); connectBtn.disabled = false; connectBtn.textContent = 'POLACZ Z ROBOTEM'; connectBtn.style.backgroundColor = ''; document.getElementById('connectionStatus').className = 'status-indicator status-disconnected'; document.getElementById('connectionText').textContent = 'Rozlaczony'; ['balanceSwitch', 'holdPositionSwitch', 'speedModeSwitch'].forEach(id => { const el = document.getElementById(id); if (el) el.checked = false; }); }
    function handleBleNotification(event) { const value = event.target.value; const decoder = new TextDecoder('utf-8'); bleBuffer += decoder.decode(value); let newlineIndex; while ((newlineIndex = bleBuffer.indexOf('\n')) !== -1) { const line = bleBuffer.substring(0, newlineIndex).trim(); bleBuffer = bleBuffer.substring(newlineIndex + 1); if (line) { try { const data = JSON.parse(line); if (data.type === 'chunk' && data.id !== undefined) { let entry = bleChunks.get(data.id); if (!entry) { entry = { total: data.total || 0, parts: new Map(), timer: setTimeout(() => { if (bleChunks.has(data.id)) { bleChunks.delete(data.id); addLogMessage(`[UI] Blad: Timeout podczas skladania wiadomosci (ID: ${data.id}).`, 'error'); } }, 5000)}; bleChunks.set(data.id, entry); } entry.parts.set(data.i, data.data || ''); if (data.total) entry.total = data.total; if (entry.parts.size === entry.total && entry.total > 0) { clearTimeout(entry.timer); let combined = ''; for (let i = 0; i < entry.total; i++) { combined += entry.parts.get(i) || ''; } bleChunks.delete(data.id); try { const fullMsg = JSON.parse(combined); processCompleteMessage(fullMsg); } catch (e) { addLogMessage(`[UI] Blad skladania chunkow: ${e}. Dane: ${combined}`, 'error'); } } } else { processCompleteMessage(data); } } catch (e) { addLogMessage(`[UI] Blad parsowania JSON: ${e}. Dane: ${line}`, 'error'); } } } }
    async function _sendRawBleMessage(message) { if (!rxCharacteristic) return; try { const encoder = new TextEncoder(); await rxCharacteristic.writeValueWithoutResponse(encoder.encode(JSON.stringify(message) + '\n')); } catch (error) { addLogMessage(`[UI] Blad wysylania danych BLE: ${error}`, 'error'); } }
    async function processBleQueue() { if (isSendingBleMessage || bleMessageQueue.length === 0 || !rxCharacteristic) return; isSendingBleMessage = true; const message = bleMessageQueue.shift(); await _sendRawBleMessage(message); setTimeout(() => { isSendingBleMessage = false; processBleQueue(); }, BLE_SEND_INTERVAL); }
    function sendBleMessage(message) { bleMessageQueue.push(message); processBleQueue(); }
    
    function processCompleteMessage(data) {
        if (!data || !data.type) return;
        const prevState = AppState.lastKnownRobotState;
        if (data.robot_state) {
            const changed = data.robot_state !== AppState.lastKnownRobotState;
            AppState.lastKnownRobotState = data.robot_state;
            // Gdy stan robota zmienia siƒô z trybu pracy autonomicznej na gotowo≈õƒá, przejd≈∫ do kolejnego kroku sekwencji
            if (changed) {
                try { checkAndExecuteNextSequenceStep(prevState); } catch (e) { /* no-op */ }
            }
        }
        // Automatically pause tuning on emergency stop
        if (data.robot_state === 'EMERGENCY_STOP' && AppState.isTuningActive) {
            pauseTuning();
            addLogMessage('[UI] WYKRYTO ZATRZYMANIE AWARYJNE! Proces wstrzymany. Postaw robota, w≈ÇƒÖcz balansowanie i wzn√≥w test.', 'error');
        }
        switch(data.type) {
            case 'telemetry':
        // Je≈õli dostƒôpny jest kwaternion, policz kƒÖty bez dodatkowego mapowania (Quaternion-First)
                if (typeof data.qw === 'number' && typeof data.qx === 'number' && typeof data.qy === 'number' && typeof data.qz === 'number') {
                    const eul = computeEulerFromQuaternion(data.qw, data.qx, data.qy, data.qz);
                    if (eul) {
                        // Zachowaj SUROWE kƒÖty z kwaternionu (dla logiki, wykres√≥w, ≈õcie≈ºki)
                        data.raw_pitch = eul.pitch;
                        data.raw_yaw   = eul.yaw;
                        data.raw_roll  = eul.roll;
                        // Oblicz tylko dla wizualizacji (model 3D) ‚Äì nie wp≈Çywa na logikƒô
                        const mapped = applyModelMappingToEuler(eul);
                        data.viz_pitch = mapped.pitch;
                        data.viz_yaw   = mapped.yaw;
                        data.viz_roll  = mapped.roll;
                        // Pola kompatybilno≈õci: pitch/yaw/roll = surowe (dla istniejƒÖcych funkcji)
                        data.pitch = data.raw_pitch;
                        data.yaw   = data.raw_yaw;
                        data.roll  = data.raw_roll;
                    }
                }
                updateTelemetryUI(data);
                updateChart(data);
                updateActualPath(data);
                // Legacy guard: mappingWizard removed; keep defensive check
                if (typeof mappingWizard !== 'undefined' && mappingWizard && mappingWizard.isActive && typeof processWizardTelemetry === 'function') {
                    processWizardTelemetry(data);
                }
                break;
            case 'status_update':
                // Specjalna obs≈Çuga mount_corr_set (echo po sensor_map_commit)
                if(data.message === 'mount_corr_set' && typeof data.qw === 'number'){
                    window.lastMountCorr = {qw:data.qw,qx:data.qx,qy:data.qy,qz:data.qz};
                    addLogMessage(`[UI] Korekcja monta≈ºu zastosowana: w=${data.qw.toFixed(3)} x=${data.qx.toFixed(3)} y=${data.qy.toFixed(3)} z=${data.qz.toFixed(3)}`, 'success');
                    // Je≈õli modal nadal otwarty a zapis jeszcze nie zaznaczony, od≈õwie≈º postƒôp
                    if(document.getElementById('sensor-mapping-modal')?.style.display === 'flex'){
                        sensorWizard.progress.saved = true; setWizardProgress(); updateSensorWizardUI();
                    }
                }
                break;
            case 'imu_mapping':
                // Zachowaj w pamiƒôci (mo≈ºe w przysz≈Ço≈õci do oblicze≈Ñ sterowania UI)
                window.imuMapping = data;
                addLogMessage('[UI] Otrzymano mapowanie czujnika (imu_mapping).', 'info');
                break;
            case 'model_mapping':
                // Aktualizacja struktury modelMapping z EEPROM
                if(data.pitch && data.yaw && data.roll){
                    modelMapping.pitch.source = parseInt(data.pitch.source); modelMapping.pitch.sign = parseInt(data.pitch.sign);
                    modelMapping.yaw.source = parseInt(data.yaw.source); modelMapping.yaw.sign = parseInt(data.yaw.sign);
                    modelMapping.roll.source = parseInt(data.roll.source); modelMapping.roll.sign = parseInt(data.roll.sign);
                    updateModelMappingUI();
                }
                addLogMessage('[UI] Otrzymano mapowanie modelu 3D (model_mapping).', 'info');
                break;
            case 'sync_begin':
                clearTimeout(AppState.syncTimeout);
                AppState.isSynced = false;
                document.getElementById('connectionText').textContent = 'Synchronizowanie...';
                addLogMessage('[UI] Rozpoczeto odbieranie konfiguracji...', 'info');
                break;
            case 'set_param':
                if (!AppState.isSynced) { // Je≈õli jeste≈õmy w trakcie synchronizacji
                    if (data.key === 'balancing' || data.key === 'holding_pos' || data.key === 'speed_mode') {
                        AppState.tempStates[data.key] = data.value;
                    } else {
                        AppState.tempParams[data.key] = data.value;
                    }
                } else {
                    applySingleParam(data.key, data.value);
                }
                break;
            case 'set_tuning_config_param':
                // Umo≈ºliw obs≈Çugƒô runtime dla search_ki r√≥wnie≈º z firmware (na wypadek zmian po stronie robota)
                if (!AppState.isSynced) {
                    AppState.tempTuningParams[data.key] = data.value;
                } else {
                    applySingleAutotuneParam(data.key, data.value);
                    if (data.key === 'search_ki') updateSearchSpaceInputs();
                }
                break;
            
            case 'ack':
                if (data.command === 'request_full_config') { // NOWE: Obs≈Çuga ACK dla request_full_config
                    if (data.success) {
                        addLogMessage(`[UI] Robot potwierdzil wyslanie konfiguracji: ${data.message}`, 'info');
                    } else {
                        addLogMessage(`[UI] Robot odrzucil zadanie konfiguracji: ${data.message || 'Nieznany blad'}`, 'error');
                    }
                } else if (data.command === 'save_tunings') {
                    const level = data.success ? 'success' : 'error';
                    addLogMessage(`[ROBOT] Zapis do EEPROM: ${data.message || (data.success ? 'OK' : 'Blad')}`, level);
                } else {
                    // Og√≥lna obs≈Çuga dla innych polece≈Ñ
                    const level = data.success ? 'info' : 'warn';
                    const message = `[ROBOT ACK] ${data.command}: ${data.success ? 'OK' : 'FAILED'} ${data.message ? `(${data.message})` : ''}`;
                    addLogMessage(message, level);
                }
                break;
            case 'full_config':
                break;
            case 'sync_complete':
                // Zastosuj wszystkie zebrane parametry i stany
                AppState.isApplyingConfig = true;
                for (const [key, value] of Object.entries(AppState.tempParams)) {
                    applySingleParam(key, value);
                }
                for (const [key, value] of Object.entries(AppState.tempTuningParams)) {
                    applySingleAutotuneParam(key, value);
                }
                if (AppState.tempStates.balancing !== undefined) document.getElementById('balanceSwitch').checked = AppState.tempStates.balancing;
                if (AppState.tempStates.holding_pos !== undefined) document.getElementById('holdPositionSwitch').checked = AppState.tempStates.holding_pos;
                if (AppState.tempStates.speed_mode !== undefined) document.getElementById('speedModeSwitch').checked = AppState.tempStates.speed_mode;
                AppState.isApplyingConfig = false;
                
                // Zaktualizuj UI
                clearTimeout(AppState.syncTimeout);
                AppState.isSynced = true;
                document.getElementById('connectionText').textContent = 'Polaczony';
                document.getElementById('connectBleBtn').textContent = 'POLACZ Z ROBOTEM';
                addLogMessage('[UI] Synchronizacja konfiguracji zakonczona pomyslnie.', 'success');
                AppState.tempParams = {};
                AppState.tempTuningParams = {};
                AppState.tempStates = {};
                break;
            case 'set_rgb_blink': // NOWE: Obs≈Çuga komend RGB
            case 'log':
                addLogMessage(`[ROBOT] ${data.message}`, data.level);
                break;
            case 'tuner_live_status': updateTunerStatus(data); break;
            case 'tuner_live_chart_data': updateAutotuneTuningChart(data); break;
            case 'tuning_result': handleTunerResult(data); break;
            case 'tuning_iteration_result': handleTuningIterationResult(data); break;
            // POPRAWKA: Dodano obs≈Çugƒô wyniku strojenia PWM
            case 'min_pwm_autotune_result':
                if (data.motor && data.direction && data.found_pwm !== undefined) {
                    const { motor, direction, found_pwm } = data;
                    addLogMessage(`[UI] Auto-strojenie zako≈Ñczone dla ${motor} ${direction}. Znaleziono PWM: ${found_pwm}`, 'success');
                    
                    // Znajd≈∫ odpowiedni wiersz i pole input
                    const row = document.querySelector(`.manual-tune-row[data-motor="${motor}"][data-direction="${direction}"]`);
                    if (row) {
                        const input = row.querySelector('.tune-input');
                        const autoBtn = row.querySelector('.auto-btn');
                        // Zastosuj znalezionƒÖ warto≈õƒá do pola input
                        if (input) input.value = found_pwm;
                        // Odblokuj przycisk "Auto"
                        if (autoBtn) {
                            autoBtn.disabled = false;
                            autoBtn.textContent = 'Auto';
                        }
                    }
                }
                break;
            case 'test_result': handleDynamicTestResult(data); break;
            case 'metrics_result': handleDynamicTestResult(data); break;
            case 'tuner_session_end':
                // POPRAWKA: Obs≈Çuga komunikatu o zako≈Ñczeniu sesji strojenia.
                // Odblokowuje UI, gdy strojenie zostanie przerwane na robocie lub zako≈Ñczy siƒô naturalnie.
                addLogMessage(`[UI] Sesja strojenia zakonczona: ${data.reason || 'Zdalne zatrzymanie'}`, 'info');
                // U≈ºywamy funkcji handleCancel, kt√≥ra ju≈º zawiera logikƒô czyszczenia stanu UI.
                handleCancel(false);
                break;
        }
    // Broadcast BLE message for client-side autotuning algorithms (Simple Test API)
    try { window.dispatchEvent(new CustomEvent('ble_message', { detail: data })); } catch(e) {}
    }

    // Historia pr√≥b strojenia + lista ostatnich 5
    const tuningHistory = [];
    function refreshRecentList() {
        const box = document.getElementById('recent-results-list');
        if (!box) return;
        const last5 = tuningHistory.slice(-5).reverse();
        if (!last5.length) { box.textContent = 'Brak danych.'; return; }
        box.innerHTML = last5.map((r, idx)=> `#${r.idx} | Kp=${r.kp.toFixed(3)} Ki=${r.ki.toFixed(3)} Kd=${r.kd.toFixed(3)} | fitness=${r.fitness.toFixed(4)} | ITAE=${(r.itae??NaN).toFixed?.(2)??'---'} | ov=${(r.overshoot??NaN).toFixed?.(2)??'---'}%`).join('\n');
    }
    function refreshHistoryTable(){
        const tbody = document.getElementById('results-table-body');
        if (!tbody) return;
        tbody.innerHTML = '';
        for (let i=tuningHistory.length-1; i>=0; i--) {
            const r = tuningHistory[i];
            const tr = document.createElement('tr');
            tr.innerHTML = `<td>${r.idx}</td><td>${r.kp.toFixed(3)}</td><td>${r.ki.toFixed(3)}</td><td>${r.kd.toFixed(3)}</td><td>${r.fitness.toFixed(4)}</td><td>${(r.itae??0).toFixed(2)}</td><td>${(r.overshoot??0).toFixed(2)}%</td><td><button class="btn-small" data-apply="${i}">Zastosuj</button></td>`;
            tbody.appendChild(tr);
        }
    { const hc = document.getElementById('historyCount'); if (hc) hc.textContent = `${tuningHistory.length} pr√≥b`; }
        // Delegacja dla przycisk√≥w Zastosuj
        tbody.querySelectorAll('button[data-apply]').forEach(btn=>{
            btn.addEventListener('click', ()=>{
                const i = parseInt(btn.getAttribute('data-apply'));
                const r = tuningHistory[i];
                if (!r) return;
                applyParameters(r.kp, r.ki, r.kd);
            });
        });
    }
    function exportHistoryCsv(){
        if (!tuningHistory.length) { showNotification('Brak danych historii'); return; }
        const headers = ['#','Kp','Ki','Kd','Fitness','ITAE','Overshoot'];
        const lines = [headers.join(',')];
        tuningHistory.forEach(r=>{
            lines.push([r.idx, r.kp.toFixed(3), r.ki.toFixed(3), r.kd.toFixed(3), r.fitness.toFixed(4), (r.itae??0).toFixed(2), (r.overshoot??0).toFixed(2)].join(','));
        });
        const csv = lines.join('\n');
        const blob = new Blob([csv], {type:'text/csv'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = 'tuning_history.csv'; a.click(); URL.revokeObjectURL(url);
    }
    
    function applySingleParam(snakeKey, value) {
        const inputId = Object.keys(parameterMapping).find(key => parameterMapping[key] === snakeKey);
        if (inputId) {
            const el = document.getElementById(inputId);
            if (el) {
                let displayValue = value;
                if (['turn_factor', 'expo_joystick', 'joystick_sensitivity', 'joystick_deadzone', 'balance_pid_derivative_filter_alpha', 'speed_pid_filter_alpha', 'position_pid_filter_alpha'].includes(snakeKey)) {
                    displayValue = (value * 100);
                }
                if (el.tagName === 'INPUT' || el.tagName === 'SELECT') {
                    if (el.type === 'checkbox') {
                        el.checked = !!displayValue;
                        if (inputId === 'include-ki-checkbox') updateSearchSpaceInputs();
                    } else {
                        el.value = displayValue;
                    }
                } else if (el.tagName === 'SPAN') {
                    el.textContent = (typeof displayValue === 'number') ? parseFloat(displayValue).toFixed(2) : displayValue;
                }
            }
        }
        // Fallback dla trim√≥w (je≈õli elementy sƒÖ poza mappingiem lub dodatkowe od≈õwie≈ºenie)
        if (snakeKey === 'trim_angle') {
            const span = document.getElementById('trimValueDisplay');
            if (span) span.textContent = parseFloat(value).toFixed(2);
        } else if (snakeKey === 'roll_trim') {
            const span = document.getElementById('rollTrimValueDisplay');
            if (span) span.textContent = parseFloat(value).toFixed(2);
        }
    }

    function applySingleAutotuneParam(snakeKey, value) {
        const inputId = Object.keys(parameterMapping).find(key => parameterMapping[key] === snakeKey);

        if (inputId) {
            const input = document.getElementById(inputId);
            if (input) {
                let displayValue = value;
                if (snakeKey.startsWith('weights_')) {
                    displayValue = (value * 100);
                }
                if (snakeKey === 'ga_mutation_rate') {
                    displayValue = (value * 100);
                }
                if (snakeKey === 'tuning_trial_duration_ms') {
                    displayValue = (value / 1000.0);
                }

                if (input.type === 'checkbox') {
                    input.checked = displayValue;
                } else {
                    input.value = displayValue;
                }

                if (snakeKey === 'search_ki') {
                    // Od≈õwie≈º uk≈Çad p√≥l przestrzeni wyszukiwania
                    updateSearchSpaceInputs();
                }

                // If it's a shared field, update the other tab too
                const sharedFields = ['kp-min', 'kp-max', 'ki-min', 'ki-max', 'kd-min', 'kd-max', 'weight-itae', 'weight-overshoot', 'weight-control-effort'];
                const sharedField = sharedFields.find(f => inputId.endsWith(f));
                if (sharedField) {
                    const prefix = inputId.startsWith('ga-') ? 'pso-' : 'ga-';
                    const otherInput = document.getElementById(`${prefix}${sharedField}`);
                    if (otherInput) {
                        otherInput.value = input.value;
                    }
                }

                // Trigger input event for range sliders to update their text displays
                if (input.type === 'range') {
                    input.dispatchEvent(new Event('input'));
                }
            }
        }
    }

    function applyFullConfig(params) { 
        for (const [inputId, snakeKey] of Object.entries(parameterMapping)) { 
            const input = document.getElementById(inputId); 
            if (input && params[snakeKey] !== undefined) { 
                let value = params[snakeKey]; 
                if (['turn_factor', 'expo_joystick', 'joystick_sensitivity', 'joystick_deadzone', 'balance_pid_derivative_filter_alpha', 'speed_pid_filter_alpha', 'position_pid_filter_alpha', 'weights_itae', 'weights_overshoot', 'weights_control_effort'].includes(snakeKey)) { 
                    value = (value * 100); 
                } 
                input.value = value; 
            } 
        } 
    }
    
    function normalizeTelemetryData(d) {
        if (!d || typeof d !== 'object') return d;
        if (d.sp !== undefined && d.speed === undefined) d.speed = d.sp;
        if (d.ts !== undefined && d.target_speed === undefined) d.target_speed = d.ts;
        if (d.el !== undefined && d.encoder_left === undefined) d.encoder_left = d.el;
        if (d.er !== undefined && d.encoder_right === undefined) d.encoder_right = d.er;
        if (d.o !== undefined && d.output === undefined) d.output = d.o;
        if (d.cs !== undefined && d.calib_sys === undefined) d.calib_sys = d.cs;
        if (d.cg !== undefined && d.calib_gyro === undefined) d.calib_gyro = d.cg;
        if (d.ca !== undefined && d.calib_accel === undefined) d.calib_accel = d.ca;
        if (d.cm !== undefined && d.calib_mag === undefined) d.calib_mag = d.cm;
        if (d.lt !== undefined && d.loop_time === undefined) d.loop_time = d.lt;
        if (d.ta !== undefined && d.trim_angle === undefined) d.trim_angle = d.ta;
        if (d.rt !== undefined && d.roll_trim === undefined) d.roll_trim = d.rt;
        if (d.states && typeof d.states === 'object') {
            const s = d.states;
            if (s.b !== undefined && s.balancing === undefined) s.balancing = s.b;
            if (s.hp !== undefined && s.holding_pos === undefined) s.holding_pos = s.hp;
            if (s.sm !== undefined && s.speed_mode === undefined) s.speed_mode = s.sm;
            if (s.es !== undefined && s.emergency_stop === undefined) s.emergency_stop = s.es;
        }
        return d;
    }

    function updateTelemetryUI(data) {
        data = normalizeTelemetryData(data);
        window.telemetryData = data; // Zapisz ostatnie dane telemetryczne globalnie
    if (data.robot_state !== undefined) document.getElementById('robotStateVal').textContent = data.robot_state;
        // Fitness paused indicator
        const dash = document.getElementById('autotune-dashboard');
        if (dash) {
            const statusEl = document.getElementById('dashboard-status');
            if (data.fitness_paused) {
                statusEl.textContent = 'Test wstrzymany (czekam na ustawienie)';
                dash.style.display = 'block';
            }
        }
    // loop time: support long 'loop_time' or short 'lt'
    const loopTimeVal = (data.loop_time !== undefined) ? data.loop_time : data.lt;
    if (loopTimeVal !== undefined) document.getElementById('loopTimeVal').textContent = loopTimeVal + ' \u00B5s';
        if (data.loop_load !== undefined) {
            const loopLoadValEl = document.getElementById('loopLoadVal');
            const loopLoadItemEl = document.getElementById('loopLoadItem');
            const loadVal = parseFloat(data.loop_load).toFixed(0);
            if (loopLoadValEl) loopLoadValEl.textContent = loadVal + '%';
            if (loopLoadItemEl) {
                loopLoadItemEl.classList.toggle('warn', loadVal > 70);
                loopLoadItemEl.classList.toggle('error', loadVal > 90);
            }
        }
        if (data.pitch !== undefined) {
            document.getElementById('angleVal').textContent = data.pitch.toFixed(1) + ' \u00B0';
            document.getElementById('robot3d-pitch').textContent = data.pitch.toFixed(1) + '¬∞';
            pitchHistory.push(data.pitch);
            if (pitchHistory.length > HISTORY_LENGTH) pitchHistory.shift();
        }
        if (data.roll !== undefined) {
            document.getElementById('robot3d-roll').textContent = data.roll.toFixed(1) + '¬∞';
            document.getElementById('rollVal').textContent = data.roll.toFixed(1) + ' \u00B0';
        }
        if (data.yaw !== undefined) {
            document.getElementById('yawVal').textContent = data.yaw.toFixed(1) + ' ¬∞';
            document.getElementById('compassNeedle').style.transform = `rotate(${data.yaw}deg)`;
        }
        // speed actual (sp) and target (ts) short keys
        const speedActual = (data.speed !== undefined) ? data.speed : data.sp;
        if (speedActual !== undefined) {
            const speed = parseFloat(speedActual);
            document.getElementById('speedVal').textContent = speed.toFixed(0) + ' imp/s';
            const ppr = parseFloat(document.getElementById('encoderPprInput').value) || 820;
            const wheelRpm = (speed / ppr) * 60;
            document.getElementById('robot3d-wheel-speed').textContent = wheelRpm.toFixed(0) + ' obr/min';
            speedHistory.push(speed);
            if (speedHistory.length > HISTORY_LENGTH) speedHistory.shift();
        }
        const encLeft = (data.encoder_left !== undefined) ? data.encoder_left : data.el;
        if (encLeft !== undefined) {
            currentEncoderLeft = encLeft;
            document.getElementById('encoderLeftVal').textContent = encLeft;
        }
        const encRight = (data.encoder_right !== undefined) ? data.encoder_right : data.er;
        if (encRight !== undefined) {
            currentEncoderRight = encRight;
            document.getElementById('encoderRightVal').textContent = encRight;
        }
        if (Date.now() - lastTelemetryUpdateTime > TELEMETRY_UPDATE_INTERVAL) {
            if (pitchHistory.length > 0) {
                const minPitch = Math.min(...pitchHistory);
                const maxPitch = Math.max(...pitchHistory);
                const avgPitch = pitchHistory.reduce((sum, val) => sum + val, 0) / pitchHistory.length;
                document.getElementById('pitchMin').textContent = minPitch.toFixed(1) + '¬∞';
                document.getElementById('pitchMax').textContent = maxPitch.toFixed(1) + '¬∞';
                document.getElementById('pitchAvg').textContent = avgPitch.toFixed(1) + '¬∞';
            }
             if (speedHistory.length > 0) {
                const minSpeed = Math.min(...speedHistory);
                const maxSpeed = Math.max(...speedHistory);
                const avgSpeed = speedHistory.reduce((sum, val) => sum + val, 0) / speedHistory.length; // Poprawka: toFixed(0) dla speedAvg
                document.getElementById('speedMin').textContent = minSpeed.toFixed(0) + ' imp/s';
                document.getElementById('speedMax').textContent = maxSpeed.toFixed(0) + ' imp/s';
                document.getElementById('speedAvg').textContent = avgSpeed.toFixed(0) + ' imp/s';
            }
            lastTelemetryUpdateTime = Date.now();
        }
        const calibSys = (data.calib_sys !== undefined) ? data.calib_sys : data.cs;
        if (calibSys !== undefined) {
            document.getElementById('calibSysVal').textContent = calibSys;
            updateCalibrationProgress('sys', calibSys);
            const systemHealthItem = document.getElementById('systemHealthItem');
            const sysCalibVal = parseInt(calibSys);
            if (sysCalibVal < 2) { systemHealthItem.classList.add('error'); systemHealthItem.classList.remove('warn'); document.getElementById('systemHealthVal').textContent = 'KRYTYCZNY'; }
            else if (sysCalibVal === 2) { systemHealthItem.classList.add('warn'); systemHealthItem.classList.remove('error'); document.getElementById('systemHealthVal').textContent = 'NISKI'; } else { systemHealthItem.classList.remove('warn', 'error'); document.getElementById('systemHealthVal').textContent = 'OK'; }
        }
        const calibAccel = (data.calib_accel !== undefined) ? data.calib_accel : data.ca;
        if (calibAccel !== undefined) { document.getElementById('calibAccelVal').textContent = calibAccel; updateCalibrationProgress('accel', calibAccel); }
        const calibGyro = (data.calib_gyro !== undefined) ? data.calib_gyro : data.cg;
        if (calibGyro !== undefined) { document.getElementById('calibGyroVal').textContent = calibGyro; updateCalibrationProgress('gyro', calibGyro); }
        const calibMag = (data.calib_mag !== undefined) ? data.calib_mag : data.cm;
        if (calibMag !== undefined) { document.getElementById('calibMagVal').textContent = calibMag; updateCalibrationProgress('mag', calibMag); }
        const trimAngle = (data.trim_angle !== undefined) ? data.trim_angle : data.ta;
        if (trimAngle !== undefined) { document.getElementById('trimValueDisplay').textContent = parseFloat(trimAngle).toFixed(2); }
        const rollTrim = (data.roll_trim !== undefined) ? data.roll_trim : data.rt;
        if (rollTrim !== undefined) {
            const rollSpan = document.getElementById('rollTrimValueDisplay');
            const v = parseFloat(rollTrim);
            if (rollSpan && !Number.isNaN(v)) rollSpan.textContent = v.toFixed(2);
        }
        if (data.states && !AppState.isApplyingConfig) {
            AppState.isApplyingConfig = true;
            // states short keys fallback
            const s = data.states;
            const stBal = (s.balancing !== undefined) ? s.balancing : s.b;
            const stHold = (s.holding_pos !== undefined) ? s.holding_pos : s.hp;
            const stSpeed = (s.speed_mode !== undefined) ? s.speed_mode : s.sm;
            const stEstop = (s.emergency_stop !== undefined) ? s.emergency_stop : s.es;
            if (stBal !== undefined) document.getElementById('balanceSwitch').checked = !!stBal;
            if (stHold !== undefined) document.getElementById('holdPositionSwitch').checked = !!stHold;
            if (stSpeed !== undefined) document.getElementById('speedModeSwitch').checked = !!stSpeed;
            AppState.isApplyingConfig = false;
            const emergencyBanner = document.getElementById('emergency-banner'); if (emergencyBanner) emergencyBanner.style.display = stEstop ? 'block' : 'none';
        } else {
            const emergencyBanner = document.getElementById('emergency-banner'); if (emergencyBanner) emergencyBanner.style.display = data.states && (data.states.emergency_stop || data.states.es) ? 'block' : 'none';
        }
    }

    let signalAnalyzerChart; let isChartPaused = false; let cursorA = null, cursorB = null;
    let chartRangeSelection = { isSelecting: false, startIndex: null, endIndex: null };
    
    function initSignalAnalyzerChart() {
        const ctx = document.getElementById('signalAnalyzerChart').getContext('2d');
        signalAnalyzerChart = new Chart(ctx, {
            type: 'line', data: { labels: Array(200).fill(''), datasets: [] },
            options: {
                animation: false, responsive: true, maintainAspectRatio: false,
                scales: {
                    x: { 
                        display: true, 
                        title: { display: true, text: 'Czas', color: '#fff' }, 
                        ticks: { color: '#fff' }
                    },
                    y: { type: 'linear', display: true, position: 'left', id: 'y-pitch', ticks: { color: availableTelemetry['pitch']?.color || '#61dafb' }, title: { display: true, text: 'Pitch (¬∞)', color: availableTelemetry['pitch']?.color || '#61dafb' }},
                    y1: { type: 'linear', display: false, position: 'right', id: 'y-speed', ticks: { color: availableTelemetry['speed']?.color || '#f7b731' }, title: { display: true, text: 'Speed (imp/s)', color: availableTelemetry['speed']?.color || '#f7b731' }, grid: { drawOnChartArea: false } }
                },
                plugins: { 
                    legend: { labels: { color: '#fff' } }, 
                    tooltip: { mode: 'index', intersect: false }
                },
                onClick: handleChartClick,
                onHover: (event, activeElements, chart) => {
                    if (chartRangeSelection.isSelecting) {
                        chart.canvas.style.cursor = 'crosshair';
                    } else {
                        chart.canvas.style.cursor = 'default';
                    }
                }
            }
        });
        
        // Add range selection functionality
        const canvas = ctx.canvas;
        let selectionStart = null;
        
        canvas.addEventListener('mousedown', (e) => {
            if (e.shiftKey) {
                chartRangeSelection.isSelecting = true;
                const rect = canvas.getBoundingClientRect();
                selectionStart = e.clientX - rect.left;
                chartRangeSelection.startIndex = getChartIndexFromX(selectionStart);
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (chartRangeSelection.isSelecting && selectionStart !== null) {
                const rect = canvas.getBoundingClientRect();
                const currentX = e.clientX - rect.left;
                chartRangeSelection.endIndex = getChartIndexFromX(currentX);
                highlightSelectedRange();
            }
        });
        
        canvas.addEventListener('mouseup', (e) => {
            if (chartRangeSelection.isSelecting) {
                chartRangeSelection.isSelecting = false;
                selectionStart = null;
                // Range is now selected and stored in chartRangeSelection
                if (chartRangeSelection.startIndex !== null && chartRangeSelection.endIndex !== null) {
                    addLogMessage(`[UI] Zakres zaznaczony: ${chartRangeSelection.startIndex} - ${chartRangeSelection.endIndex}. U≈ºyj "Eksport CSV (Zakres)" aby wyeksportowaƒá.`, 'info');
                }
            }
        });
    }
    function setupSignalChartControls() {
        const container = document.getElementById('signalChartControls'); container.innerHTML = '';
        const defaultChecked = ['pitch', 'speed'];
        Object.keys(availableTelemetry).forEach((key) => {
            const label = document.createElement('label'); const checkbox = document.createElement('input');
            checkbox.type = 'checkbox'; checkbox.value = key; checkbox.checked = defaultChecked.includes(key);
            checkbox.addEventListener('change', (e) => {
                const varName = e.target.value, datasetLabel = availableTelemetry[varName].label, datasetColor = availableTelemetry[varName].color;
                let dataset = signalAnalyzerChart.data.datasets.find(ds => ds.label === datasetLabel);
                if (e.target.checked) {
                    if (!dataset) {
                        let yAxisID = 'y-pitch';
                        if (['speed', 'target_speed', 'output'].includes(varName)) { yAxisID = 'y-speed'; signalAnalyzerChart.options.scales['y1'].display = true; }
                        signalAnalyzerChart.data.datasets.push({ label: datasetLabel, data: Array(signalAnalyzerChart.data.labels.length).fill(null), borderColor: datasetColor, fill: false, tension: 0.1, pointRadius: 0, yAxisID: yAxisID });
                    }
                } else {
                    const datasetIndex = signalAnalyzerChart.data.datasets.findIndex(ds => ds.label === datasetLabel);
                    if (datasetIndex > -1) { signalAnalyzerChart.data.datasets.splice(datasetIndex, 1); }
                    if (!signalAnalyzerChart.data.datasets.some(ds => ds.yAxisID === 'y-speed')) { signalAnalyzerChart.options.scales['y1'].display = false; }
                }
                signalAnalyzerChart.update(); updateCursorInfo();
            });
            label.appendChild(checkbox); label.append(` ${availableTelemetry[key].label}`); container.appendChild(label);
            if (checkbox.checked) checkbox.dispatchEvent(new Event('change'));
        });
    }
    function updateChart(data) {
        if (isChartPaused) return;
        const chartData = signalAnalyzerChart.data;
        const currentTimeLabel = (Date.now() / 1000).toFixed(1);
        if (chartData.labels.length >= 200) { chartData.labels.shift(); chartData.datasets.forEach(ds => ds.data.shift()); }
        chartData.labels.push(currentTimeLabel);
        chartData.datasets.forEach(ds => {
            const key = Object.keys(availableTelemetry).find(k => availableTelemetry[k].label === ds.label);
            const value = (key && data[key] !== undefined) ? data[key] : null;
            ds.data.push(value);
        });
        signalAnalyzerChart.update('none');
    }
    function setupSignalAnalyzerControls() {
        document.getElementById('pauseChartBtn').addEventListener('click', () => { isChartPaused = true; document.getElementById('pauseChartBtn').style.display = 'none'; document.getElementById('resumeChartBtn').style.display = 'inline-block'; addLogMessage('[UI] Wykres wstrzymany.', 'info'); });
        document.getElementById('resumeChartBtn').addEventListener('click', () => { isChartPaused = false; document.getElementById('resumeChartBtn').style.display = 'none'; document.getElementById('pauseChartBtn').style.display = 'inline-block'; addLogMessage('[UI] Wykres wznowiony.', 'info'); });
        document.getElementById('cursorABBtn').addEventListener('click', toggleCursors);
        document.getElementById('exportCsvBtn').addEventListener('click', () => exportChartDataToCsv(false));
        document.getElementById('exportRangeCsvBtn').addEventListener('click', () => {
            if (chartRangeSelection.startIndex === null || chartRangeSelection.endIndex === null) {
                addLogMessage('[UI] Najpierw zaznacz zakres! Przytrzymaj Shift i przeciƒÖgnij myszkƒÖ po wykresie.', 'warn');
                return;
            }
            exportChartDataToCsv(true);
        });
        document.getElementById('resetZoomBtn').addEventListener('click', () => {
            if (signalAnalyzerChart.resetZoom) {
                signalAnalyzerChart.resetZoom();
                addLogMessage('[UI] Widok wykresu zresetowany.', 'info');
            }
        });
        document.getElementById('exportPngBtn').addEventListener('click', exportChartToPng);
    }
    function toggleCursors() { const cursorInfo = document.getElementById('cursorInfo'); if (cursorInfo.style.display === 'none') { cursorInfo.style.display = 'flex'; cursorA = { index: Math.floor(signalAnalyzerChart.data.labels.length * 0.25) }; cursorB = { index: Math.floor(signalAnalyzerChart.data.labels.length * 0.75) }; updateCursorInfo(); } else { cursorInfo.style.display = 'none'; cursorA = null; cursorB = null; } signalAnalyzerChart.update(); }
    function handleChartClick(event) { if (!cursorA && !cursorB) return; const activePoints = signalAnalyzerChart.getElementsAtEventForMode(event, 'index', { intersect: false }, true); if (activePoints.length > 0) { const clickedIndex = activePoints[0].index; if (cursorA && cursorB) { const distA = Math.abs(clickedIndex - cursorA.index); const distB = Math.abs(clickedIndex - cursorB.index); if (distA < distB) { cursorA.index = clickedIndex; } else { cursorB.index = clickedIndex; } } else if (cursorA) { cursorA.index = clickedIndex; } updateCursorInfo(); signalAnalyzerChart.update(); } }
    function updateCursorInfo() { if (!cursorA && !cursorB) { document.getElementById('cursorInfo').style.display = 'none'; return; } document.getElementById('cursorInfo').style.display = 'flex'; const labels = signalAnalyzerChart.data.labels; const datasets = signalAnalyzerChart.data.datasets; if (cursorA) { document.getElementById('cursorAX').textContent = labels[cursorA.index] || '---'; document.getElementById('cursorAY').textContent = datasets.length > 0 && datasets[0].data[cursorA.index] !== undefined ? datasets[0].data[cursorA.index].toFixed(2) : '---'; } if (cursorB) { document.getElementById('cursorBX').textContent = labels[cursorB.index] || '---'; document.getElementById('cursorBY').textContent = datasets.length > 0 && datasets[0].data[cursorB.index] !== undefined ? datasets[0].data[cursorB.index].toFixed(2) : '---'; } if (cursorA && cursorB) { const timeA = parseFloat(labels[cursorA.index]); const timeB = parseFloat(labels[cursorB.index]); document.getElementById('cursorDeltaT').textContent = `${Math.abs(timeB - timeA).toFixed(2)}s`; datasets.forEach(ds => { const valA = ds.data[cursorA.index]; const valB = ds.data[cursorB.index]; if (valA !== null && valB !== null) { if (ds.yAxisID === 'y-pitch') document.getElementById('cursorDeltaYPitch').textContent = `${(valB - valA).toFixed(2)}¬∞`; else if (ds.yAxisID === 'y-speed') document.getElementById('cursorDeltaYSpeed').textContent = `${(valB - valA).toFixed(0)} imp/s`; } }); } }
    function getChartIndexFromX(xPixel) {
        const chart = signalAnalyzerChart;
        const xScale = chart.scales['x'];
        const dataLength = chart.data.labels.length;
        
        // Calculate which index this X coordinate corresponds to
        const xStart = xScale.left;
        const xEnd = xScale.right;
        const xRange = xEnd - xStart;
        
        // Prevent division by zero
        if (xRange === 0 || dataLength === 0) {
            return 0;
        }
        
        const relativeX = (xPixel - xStart) / xRange;
        const index = Math.round(relativeX * (dataLength - 1));
        
        return Math.max(0, Math.min(dataLength - 1, index));
    }
    
    function highlightSelectedRange() {
        // Update the chart to show selected range
        // The visual feedback is provided through the selection state and console messages
        if (chartRangeSelection.startIndex !== null && chartRangeSelection.endIndex !== null) {
            const start = Math.min(chartRangeSelection.startIndex, chartRangeSelection.endIndex);
            const end = Math.max(chartRangeSelection.startIndex, chartRangeSelection.endIndex);
            // Visual highlighting could be added here with a Chart.js plugin in future
            // For now, we rely on user feedback through the log system
        }
    }
    
    function exportChartDataToCsv(exportRange = false) { 
        const data = signalAnalyzerChart.data; 
        let csvContent = "data:text/csv;charset=utf-8,"; 
        let headers = ['Time']; 
        data.datasets.forEach(ds => headers.push(ds.label)); 
        csvContent += headers.join(',') + '\n'; 
        
        let startIdx = 0;
        let endIdx = data.labels.length - 1;
        
        // If exporting range and a range is selected, use it
        if (exportRange && chartRangeSelection.startIndex !== null && chartRangeSelection.endIndex !== null) {
            startIdx = Math.min(chartRangeSelection.startIndex, chartRangeSelection.endIndex);
            endIdx = Math.max(chartRangeSelection.startIndex, chartRangeSelection.endIndex);
            addLogMessage(`[UI] Eksportowanie zakresu: ${startIdx} - ${endIdx}`, 'info');
        }
        
        for (let i = startIdx; i <= endIdx; i++) { 
            let row = [data.labels[i]]; 
            data.datasets.forEach(ds => { 
                const value = ds.data[i] !== null ? ds.data[i].toFixed(4) : ''; 
                row.push(value); 
            }); 
            csvContent += row.join(',') + '\n'; 
        } 
        const encodedUri = encodeURI(csvContent); 
        const link = document.createElement("a"); 
        link.setAttribute("href", encodedUri); 
        const filename = exportRange ? "telemetry_data_range.csv" : "telemetry_data.csv";
        link.setAttribute("download", filename); 
        document.body.appendChild(link); 
        link.click(); 
        document.body.removeChild(link); 
        const message = exportRange ? '[UI] Zaznaczony zakres wyeksportowany do CSV.' : '[UI] Dane wykresu wyeksportowane do CSV.';
        addLogMessage(message, 'info'); 
    }
    function exportChartToPng() { const link = document.createElement('a'); link.download = 'telemetry_chart.png'; link.href = signalAnalyzerChart.toBase64Image(); link.click(); addLogMessage('[UI] Wykres wyeksportowany do PNG.', 'info'); }

    function saveCurrentAsPreset() {
        const presetName = prompt("Podaj nazwe dla nowego presetu:", "");
        if (presetName && presetName.trim() !== "") {
            const presetData = {};
            for (const [inputId, snakeKey] of Object.entries(parameterMapping)) {
                const input = document.getElementById(inputId); if (input) { presetData[inputId] = parseFloat(input.value); }
            }
            presetData['balanceSwitch'] = document.getElementById('balanceSwitch').checked;
            presetData['holdPositionSwitch'] = document.getElementById('holdPositionSwitch').checked;
            presetData['speedModeSwitch'] = document.getElementById('speedModeSwitch').checked;
            localStorage.setItem(CUSTOM_PRESET_PREFIX + presetName.trim(), JSON.stringify(presetData));
            addLogMessage(`[UI] Zapisano wlasny preset '${presetName.trim()}'.`, 'success');
            populatePresetSelect();
        }
    }
    async function applySelectedPreset() {
        const select = document.getElementById('pidPresetSelect'); const selectedValue = select.value; let presetData;
        if (selectedValue.startsWith(CUSTOM_PRESET_PREFIX)) { presetData = JSON.parse(localStorage.getItem(selectedValue)); } else { presetData = builtInPresetsData[selectedValue]?.params; }
        if (presetData) {
            AppState.isApplyingConfig = true;
            for (const [key, value] of Object.entries(presetData)) {
                const input = document.getElementById(key);
                if (input) { let actualValue = value; if (['turn_factor', 'expo_joystick', 'joystick_sensitivity', 'joystick_deadzone', 'balance_pid_derivative_filter_alpha'].includes(parameterMapping[key])) { actualValue = (value * 100); } input.value = actualValue; } 
                else if (['balanceSwitch', 'holdPositionSwitch', 'speedModeSwitch'].includes(key)) { document.getElementById(key).checked = value; }
            }
            AppState.isApplyingConfig = false; addLogMessage('[UI] Zastosowano wartosci presetu. Zapisz na robocie, aby wyslac.', 'info');
            for (const [key, value] of Object.entries(presetData)) { const input = document.getElementById(key); if (input) { input.dispatchEvent(new Event('change', { bubbles: true })); } }
        }
    }
    function populatePresetSelect() { const select = document.getElementById('pidPresetSelect'); select.innerHTML = ''; for (const [index, preset] of Object.entries(builtInPresetsData)) { const option = document.createElement('option'); option.value = index; option.textContent = preset.name; select.appendChild(option); } for (let i = 0; i < localStorage.length; i++) { const key = localStorage.key(i); if (key.startsWith(CUSTOM_PRESET_PREFIX)) { const presetName = key.substring(CUSTOM_PRESET_PREFIX.length); const option = document.createElement('option'); option.value = key; option.textContent = `Wlasny: ${presetName}`; select.appendChild(option); } } }
    function deleteSelectedPreset() { const select = document.getElementById('pidPresetSelect'); const selectedValue = select.value; if (!selectedValue.startsWith(CUSTOM_PRESET_PREFIX)) { addLogMessage('[UI] Nie mozna usunac wbudowanego presetu.', 'warn'); return; } if (confirm(`Czy na pewno chcesz usunac preset '${selectedValue.substring(CUSTOM_PRESET_PREFIX.length)}'?`)) { localStorage.removeItem(selectedValue); addLogMessage(`[UI] Usunieto preset.`, 'info'); populatePresetSelect(); } }

    function setupSequenceControls() { document.getElementById('add-sequence-step-btn').addEventListener('click', addSequenceStep); document.getElementById('run-sequence-btn').addEventListener('click', runSequence); document.getElementById('stop-sequence-btn').addEventListener('click', stopSequenceExecution); document.getElementById('clear-sequence-btn').addEventListener('click', clearSequence); }
    function addSequenceStep() {
        const list = document.getElementById('sequence-list'); if (list.children.length >= MAX_SEQUENCE_STEPS) { addLogMessage(`[UI] Osiagnieto maksymalna liczbe krokow (${MAX_SEQUENCE_STEPS}).`, 'warn'); return; }
        const stepDiv = document.createElement('div'); stepDiv.className = 'sequence-step';
        stepDiv.innerHTML = `<select class="sequence-type"><option value="move_fwd">Przod (cm)</option><option value="move_bwd">Tyl (cm)</option><option value="rotate_r">Obrot Prawo (st.)</option><option value="rotate_l">Obrot Lewo (st.)</option><option value="wait_ms">Czekaj (ms)</option><option value="wait_condition">Czekaj az (np. pitch < 0.5)</option><option value="set_param">Ustaw parametr (np. Kp=100)</option></select><input type="text" class="sequence-value" value="20"><button class="remove-step-btn">&times;</button>`;
        list.appendChild(stepDiv); updateAccordionHeight(list.closest('.accordion-content'));
        stepDiv.querySelector('.sequence-type').addEventListener('change', (e) => {
            const valueInput = stepDiv.querySelector('.sequence-value'); const type = e.target.value;
            if (type === 'wait_condition') { valueInput.type = 'text'; valueInput.value = 'pitch < 0.5'; } 
            else if (type === 'set_param') { valueInput.type = 'text'; valueInput.value = 'balanceKpInput=100.0'; } 
            else { valueInput.type = 'number'; valueInput.value = '20'; }
        });
        stepDiv.querySelector('.remove-step-btn').addEventListener('click', () => { stepDiv.remove(); updateAccordionHeight(list.closest('.accordion-content')); });
    }
    function runSequence() { if (AppState.isSequenceRunning) return; if (AppState.lastKnownRobotState !== 'TRZYMA_POZYCJE' && AppState.lastKnownRobotState !== 'BALANSUJE') { addLogMessage(`[UI] Nie mozna rozpoczac sekwencji. Robot w stanie '${AppState.lastKnownRobotState}'.`, 'error'); return; } const steps = document.querySelectorAll('.sequence-step'); if (steps.length === 0) return; resetPathVisualization(); AppState.isSequenceRunning = true; currentSequenceStep = 0; updateSequenceUI(); addLogMessage(`[UI] Rozpoczeto sekwencje z ${steps.length} krokow.`, 'info'); executeNextSequenceStep(); }
    function stopSequenceExecution() { if (!AppState.isSequenceRunning) return; AppState.isSequenceRunning = false; sendBleMessage({ type: 'command_stop' }); updateSequenceUI(); addLogMessage('[UI] Sekwencja zatrzymana.', 'warn'); }
    function clearSequence() { if (AppState.isSequenceRunning) stopSequenceExecution(); const list = document.getElementById('sequence-list'); list.innerHTML = ''; updateAccordionHeight(list.closest('.accordion-content')); resetPathVisualization(); }
    function updateSequenceUI() { document.querySelectorAll('.sequence-step').forEach((step, index) => { step.classList.toggle('executing', AppState.isSequenceRunning && index === currentSequenceStep); }); document.getElementById('run-sequence-btn').disabled = AppState.isSequenceRunning; document.getElementById('add-sequence-step-btn').disabled = AppState.isSequenceRunning; document.getElementById('clear-sequence-btn').disabled = AppState.isSequenceRunning; document.getElementById('stop-sequence-btn').disabled = !AppState.isSequenceRunning; }
    function checkAndExecuteNextSequenceStep(previousState) { const wasWorking = ['RUCH_AUTONOMICZNY', 'OBROT_AUTONOMICZNY'].includes(previousState); const isReady = ['TRZYMA_POZYCJE', 'BALANSUJE'].includes(AppState.lastKnownRobotState); if (AppState.isSequenceRunning && wasWorking && isReady) { addLogMessage(`[UI] Krok ${currentSequenceStep + 1} zakonczony.`, 'info'); currentSequenceStep++; executeNextSequenceStep(); } }

    // Pomocnicze: ewaluacja warunku w oparciu o ostatniƒÖ telemetriƒô
    function evaluateCondition(expr) {
        if (typeof expr !== 'string') return null;
        const m = expr.match(/^\s*([a-zA-Z_][\w]*)\s*(==|!=|>=|<=|>|<)\s*(-?\d+(?:\.\d+)?)\s*$/);
        if (!m) return null;
        const [, key, op, rhsStr] = m;
        const lhs = window.telemetryData ? window.telemetryData[key] : undefined;
        const rhs = parseFloat(rhsStr);
        if (typeof lhs !== 'number' || Number.isNaN(lhs)) return null;
        switch (op) {
            case '==': return lhs === rhs;
            case '!=': return lhs !== rhs;
            case '>': return lhs > rhs;
            case '<': return lhs < rhs;
            case '>=': return lhs >= rhs;
            case '<=': return lhs <= rhs;
            default: return null;
        }
    }

    function waitForCondition(expr, timeoutMs = 10000, intervalMs = 100) {
        return new Promise((resolve, reject) => {
            const start = Date.now();
            const timer = setInterval(() => {
                const ok = evaluateCondition(expr);
                if (ok === true) { clearInterval(timer); resolve(); }
                else if (Date.now() - start > timeoutMs) { clearInterval(timer); reject(new Error('timeout')); }
            }, intervalMs);
        });
    }
    function executeNextSequenceStep() {
        const steps = document.querySelectorAll('.sequence-step');
        if (!AppState.isSequenceRunning || currentSequenceStep >= steps.length) { if (AppState.isSequenceRunning) { AppState.isSequenceRunning = false; addLogMessage('[UI] Sekwencja ukonczona.', 'success'); showSequenceReport(); } updateSequenceUI(); return; }
        updateSequenceUI();
        const stepNode = steps[currentSequenceStep], type = stepNode.querySelector('.sequence-type').value, value = stepNode.querySelector('.sequence-value').value; let command = {};
        switch (type) {
            case 'move_fwd': command = { type: 'execute_move', distance_cm: parseFloat(value) }; break;
            case 'move_bwd': command = { type: 'execute_move', distance_cm: -parseFloat(value) }; break;
            case 'rotate_r': command = { type: 'execute_rotate', angle_deg: parseFloat(value) }; break;
            case 'rotate_l': command = { type: 'execute_rotate', angle_deg: -parseFloat(value) }; break;
            case 'wait_ms': {
                const duration = parseInt(value);
                const ms = Number.isFinite(duration) ? duration : 0;
                addLogMessage(`[UI] Czekam ${ms} ms...`, 'info');
                setTimeout(() => { currentSequenceStep++; executeNextSequenceStep(); }, ms);
                return; // nie wysy≈Çamy komendy do robota
            }
            case 'wait_condition': {
                const cond = String(value || '').trim();
                if (!cond) { addLogMessage('[UI] Pusty warunek. Pomijam.', 'warn'); currentSequenceStep++; executeNextSequenceStep(); return; }
                addLogMessage(`[UI] Czekam az warunek bedzie prawdziwy: ${cond}`, 'info');
                waitForCondition(cond).then(() => {
                    addLogMessage('[UI] Warunek spelniony.', 'success');
                    currentSequenceStep++;
                    executeNextSequenceStep();
                }).catch(() => {
                    addLogMessage('[UI] Timeout czekania na warunek. Przechodze dalej.', 'warn');
                    currentSequenceStep++;
                    executeNextSequenceStep();
                });
                return; // nie wysy≈Çamy komendy do robota
            }
            case 'set_param': {
                const parts = String(value).split('=');
                const inputId = parts[0]?.trim();
                const paramValue = parts[1]?.trim();
                if (inputId && paramValue) {
                    const snakeKey = parameterMapping[inputId];
                    if (snakeKey) {
                        let val = parseFloat(paramValue);
                        if (['turn_factor', 'expo_joystick', 'joystick_sensitivity', 'joystick_deadzone', 'balance_pid_derivative_filter_alpha', 'speed_pid_filter_alpha', 'position_pid_filter_alpha', 'weights_itae', 'weights_overshoot', 'weights_control_effort'].includes(snakeKey)) {
                            val /= 100.0;
                        }
                        addLogMessage(`[UI] Ustaw parametr: ${snakeKey} = ${val}`, 'info');
                        sendBleMessage({ type: 'set_param', key: snakeKey, value: val });
                        // natychmiast przejd≈∫ dalej
                        currentSequenceStep++;
                        executeNextSequenceStep();
                        return;
                    } else {
                        addLogMessage(`[UI] Nieznany parametr: ${inputId}.`, 'error'); currentSequenceStep++; executeNextSequenceStep(); return;
                    }
                } else { addLogMessage(`[UI] Nieprawidlowy format: ${value}.`, 'error'); currentSequenceStep++; executeNextSequenceStep(); return; }
            }
        }
        addLogMessage(`[UI] Wysylanie kroku ${currentSequenceStep + 1}/${steps.length}: ${JSON.stringify(command)}`, 'info');
        sendBleMessage(command);
        if (['move_fwd', 'move_bwd', 'rotate_r', 'rotate_l'].includes(type)) { addPlannedPathSegment(type, parseFloat(value)); }
    }
    let pathCanvas, pathCtx; let robotPathX = 0, robotPathY = 0, robotPathHeading = 0; const CM_PER_PIXEL = 1.0; let plannedPath = [], actualPath = [];
    function initPathVisualization() { pathCanvas = document.getElementById('pathCanvas'); pathCtx = pathCanvas.getContext('2d'); pathCanvas.width = pathCanvas.clientWidth; pathCanvas.height = pathCanvas.clientHeight; resetPathVisualization(); }
    function drawPathVisualization() { if (!pathCtx) return; pathCtx.clearRect(0, 0, pathCanvas.width, pathCanvas.height); const drawPath = (path, color) => { pathCtx.strokeStyle = color; pathCtx.lineWidth = 2; pathCtx.beginPath(); if (path.length > 0) { pathCtx.moveTo(path[0].x, path[0].y); path.forEach(p => pathCtx.lineTo(p.x, p.y)); } pathCtx.stroke(); }; drawPath(plannedPath, '#61dafb'); drawPath(actualPath, '#a2f279'); if (actualPath.length > 0) { const lastPos = actualPath[actualPath.length - 1]; pathCtx.fillStyle = '#ff6347'; pathCtx.beginPath(); pathCtx.arc(lastPos.x, lastPos.y, 4, 0, Math.PI * 2); pathCtx.fill(); } }
    function addPlannedPathSegment(type, value) { let { x, y, heading } = plannedPath.length > 0 ? plannedPath[plannedPath.length-1] : {x: robotPathX, y: robotPathY, heading: robotPathHeading}; let newX = x, newY = y, newHeading = heading; const angleRad = (heading - 90) * Math.PI / 180; if (type === 'move_fwd') { newX += Math.cos(angleRad) * value / CM_PER_PIXEL; newY += Math.sin(angleRad) * value / CM_PER_PIXEL; } else if (type === 'move_bwd') { newX -= Math.cos(angleRad) * value / CM_PER_PIXEL; newY -= Math.sin(angleRad) * value / CM_PER_PIXEL; } else if (type === 'rotate_r') { newHeading += value; } else if (type === 'rotate_l') { newHeading -= value; } plannedPath.push({ x: newX, y: newY, heading: newHeading }); drawPathVisualization(); }
    function updateActualPath(data) { if (data.pos_x_cm !== undefined && data.pos_y_cm !== undefined && data.yaw !== undefined) { const actualX = robotPathX + (data.pos_x_cm / CM_PER_PIXEL); const actualY = robotPathY - (data.pos_y_cm / CM_PER_PIXEL); actualPath.push({ x: actualX, y: actualY, heading: data.yaw }); drawPathVisualization(); } }
    function resetPathVisualization() { robotPathX = pathCanvas.width / 2; robotPathY = pathCanvas.height / 2; robotPathHeading = 0; plannedPath = [{x: robotPathX, y: robotPathY, heading: robotPathHeading}]; actualPath = [{x: robotPathX, y: robotPathY, heading: robotPathHeading}]; const ReportPanel = document.getElementById('sequenceReportPanel'); if (ReportPanel) { ReportPanel.style.display = 'none'; } drawPathVisualization(); }
    function showSequenceReport() { document.getElementById('sequence-report-panel').style.display = 'block'; document.getElementById('avgHeadingError').textContent = 'X.X ¬∞'; document.getElementById('maxHeadingError').textContent = 'Y.Y ¬∞'; document.getElementById('totalDistanceCovered').textContent = 'Z.Z cm'; }

    let autotuneTuningChart; let autotuneChartData = { labels: [], datasets: [] };
    function initAutotuneTuningChart() {
        const canvas = document.getElementById('autotuneTuningChart');
        if (!canvas) { return; }
        const ctx = canvas.getContext('2d');
        autotuneTuningChart = new Chart(ctx, { type: 'line', data: autotuneChartData, options: { animation: false, responsive: true, maintainAspectRatio: false, scales: { x: { display: false }, y: { type: 'linear', display: true, position: 'left', ticks: { color: '#61dafb' } } }, plugins: { legend: { labels: { color: '#fff' } } } } });
    }
    function updateAutotuneTuningChart(data) {
        if (!autotuneTuningChart) return;
        if (autotuneTuningChart.data.labels.length >= 200) { autotuneTuningChart.data.labels.shift(); autotuneTuningChart.data.datasets.forEach(dataset => dataset.data.shift()); }
        autotuneTuningChart.data.labels.push(data.timestamp || '');
        const mapDataToDataset = (label, value, color) => {
            let dataset = autotuneTuningChart.data.datasets.find(ds => ds.label === label);
            if (!dataset) { dataset = { label: label, data: [], borderColor: color, fill: false, tension: 0.1, pointRadius: 0 }; autotuneTuningChart.data.datasets.push(dataset); }
            dataset.data.push(value);
        };
        if(data.pitch !== undefined) mapDataToDataset('Pitch', data.pitch, '#61dafb');
        if(data.target_pitch !== undefined) mapDataToDataset('Target Pitch', data.target_pitch, '#a2f279');
        autotuneTuningChart.update('none');
    }
    // Ujednolicony prze≈ÇƒÖcznik zak≈Çadek metod (zapobiega dublowaniu listener√≥w)
    function activateMethodTab(method) {
        if (!method) return;
        if (AppState.isTuningActive) return; // blokada podczas strojenia

        const btn = document.querySelector(`.method-tab[data-method="${method}"]`);
        const content = document.querySelector(`.method-content[data-method="${method}"]`);
        if (!btn || !content) return;

        document.querySelectorAll('.method-tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.method-content').forEach(c => c.classList.remove('active'));
        btn.classList.add('active');
        content.classList.add('active');

        // Reset danych wykresu dla nowej karty
        try { autotuneChartData.labels = []; autotuneChartData.datasets = []; autotuneTuningChart.update(); } catch(e) {}

        // Stabilizacja wysoko≈õci akordeonu (kilkukrotne wymuszenie)
        const accordionContent = document.querySelector('#autotuning-card-content')?.closest('.accordion-content');
        if (accordionContent && !accordionContent.classList.contains('autotune-pane')) {
            let attempts = 0; let lastHeight = 0;
            const intervalId = setInterval(() => {
                const currentHeight = accordionContent.scrollHeight;
                if (currentHeight >= lastHeight) {
                    accordionContent.style.maxHeight = (currentHeight + 30) + 'px';
                    lastHeight = currentHeight;
                }
                attempts++;
                if (attempts >= 5) clearInterval(intervalId);
            }, 30);
        }

        // Ustaw pozycjƒô wykresu wzglƒôdem wybranej metody
        relocateAutotuneChart(method);

    // Odblokuj Start po wyborze metody
    const startBtn = document.getElementById('start-tuning-btn');
    if (startBtn) startBtn.disabled = false;
    }

    function setupAutotuningTabs() {
        document.querySelectorAll('.method-tab').forEach(tab => {
            tab.addEventListener('click', function() {
                activateMethodTab(this.dataset.method);
            });
        });
        document.querySelectorAll('input[type="range"]').forEach(range => {
            const valueDisplay = document.getElementById(range.id + '-val');
            if (valueDisplay) {
                range.addEventListener('input', () => { 
                    let unit = valueDisplay.dataset.unit || '';
                    valueDisplay.textContent = range.value + unit;
                    if(range.id === 'ga-generations') document.getElementById('ga-gen-total').textContent = range.value;
                    if(range.id === 'pso-iterations') document.getElementById('pso-it-total').textContent = range.value;
                    if(range.id.includes('-weight-')) valueDisplay.textContent = range.value + '%';
                });
                range.dispatchEvent(new Event('input'));
            }
        });
    // Legacy przyciski (GA/PSO/ZN sterowane przez robota) ‚Äì usuniƒôte
        // Obs≈Çuga test√≥w dynamicznych (impuls, prƒôdko≈õƒá)
        const impulseBtn = document.getElementById('run-impulse-test');
        if (impulseBtn) impulseBtn.addEventListener('click', function() {
            const power = parseInt(document.getElementById('impulsePowerInput').value) || 40;
            sendBleMessage({ type: 'execute_position_test_impulse', impulse_power: power });
            addLogMessage('[UI] Wys≈Çano test impulsu pozycji.', 'info');
        });
        const speedBtn = document.getElementById('run-speed-test');
        if (speedBtn) speedBtn.addEventListener('click', function() {
            const dist = parseFloat(document.getElementById('distanceCmInput').value) || 50;
            const speed = parseFloat(document.getElementById('speedCmpsInput').value) || 20;
            sendBleMessage({ type: 'execute_speed_test_run', distance_cm: dist, speed_cmps: speed });
            addLogMessage('[UI] Wys≈Çano test prƒôdko≈õci.', 'info');
        });
    document.querySelectorAll('.run-test-btn').forEach(btn => btn.addEventListener('click', function() { runDynamicTest(this.dataset.testType); }));
    const applyZnBtn = document.getElementById('apply-zn-results');
    if (applyZnBtn) applyZnBtn.addEventListener('click', () => {
             const kp = parseFloat(document.getElementById('zn-kp-suggest').textContent), kd = parseFloat(document.getElementById('zn-kd-suggest').textContent);
             if(!isNaN(kp) && !isNaN(kd)) {
                document.getElementById('balanceKpInput').value = kp.toFixed(4); document.getElementById('balanceKdInput').value = kd.toFixed(4);
                document.getElementById('balanceKpInput').dispatchEvent(new Event('change')); document.getElementById('balanceKdInput').dispatchEvent(new Event('change'));
                addLogMessage('[UI] Zastosowano wartosci z Z-N.', 'info');
            }
    });
    const __loopSel = document.getElementById('tuning-loop-selector');
    if (__loopSel) __loopSel.addEventListener('change', updateSearchSpaceInputs);
    updateSearchSpaceInputs();
    }

    // G≈Ç√≥wne zak≈Çadki w panelu optymalizacji (Konfiguracja/Metody)
    function setupMainAutotuneTabs(){
        const tabs = document.querySelectorAll('.autotune-main-tab');
        const panes = document.querySelectorAll('.autotune-main-content');
        tabs.forEach(tab=>{
            tab.addEventListener('click', ()=>{
                const target = tab.dataset.tab;
                tabs.forEach(t=>t.classList.remove('active'));
                panes.forEach(p=>p.classList.remove('active'));
                tab.classList.add('active');
                document.querySelector(`.autotune-main-content[data-tab="${target}"]`)?.classList.add('active');
        // Pokazuj przyciski sterujƒÖce tylko na zak≈Çadce 'methods'
        const controlsBar = document.getElementById('tuning-controls-bar');
        if (controlsBar) controlsBar.style.display = (target === 'methods') ? 'flex' : 'none';
            });
        });
    // Ustaw widoczno≈õƒá kontrolek zgodnie z aktywnƒÖ zak≈ÇadkƒÖ na starcie
    const activeMain = document.querySelector('.autotune-main-tab.active')?.dataset.tab || 'config';
    const controlsBar = document.getElementById('tuning-controls-bar');
    if (controlsBar) controlsBar.style.display = (activeMain === 'methods') ? 'flex' : 'none';
    }
    function updateSearchSpaceInputs() {
    const __loopEl = document.getElementById('tuning-loop-selector');
    const selectedLoop = __loopEl ? __loopEl.value : 'balance';
    const includeKi = !!document.getElementById('include-ki-checkbox')?.checked;
        const showKi = includeKi && ['speed', 'position', 'heading', 'balance', 'rotation'].includes(selectedLoop);
        ['ga', 'pso'].forEach(prefix => {
            const kiMinEl = document.getElementById(`${prefix}-ki-min`);
            if (!kiMinEl) return; // element nie istnieje w tej wersji UI
            const kiMinWrap = kiMinEl.closest('.search-space-param');
            if (kiMinWrap) kiMinWrap.style.display = showKi ? 'block' : 'none';
        });
    }
    function checkTuningPrerequisites() { if (!AppState.isConnected || !AppState.isSynced) { addLogMessage('[UI] Blad: Polacz i zsynchronizuj z robotem.', 'error'); return false; } if (!['BALANSUJE', 'TRZYMA_POZYCJE'].includes(AppState.lastKnownRobotState)) { addLogMessage(`[UI] Blad: Wymagany stan 'BALANSUJE'. Aktualny: '${AppState.lastKnownRobotState}'.`, 'error'); return false; } if (AppState.isTuningActive) { addLogMessage('[UI] Blad: Inna sesja strojenia jest juz w toku.', 'warn'); return false; } return true; }
    function setTuningUiLock(isLocked, method) {
        AppState.isTuningActive = isLocked;
        AppState.activeTuningMethod = isLocked ? method : '';
    
    // Globalny tryb strojenia (odblokowane: Sterowanie, Optymalizacja, Logi)
    document.body.classList.toggle('tuning-active', isLocked);
    
    // Wy≈ÇƒÖczamy prze≈ÇƒÖczanie zak≈Çadek i testy UI
        document.querySelectorAll('.run-test-btn').forEach(btn => btn.disabled = isLocked);
        document.querySelectorAll('.method-tab').forEach(tab => tab.disabled = isLocked);
        // Dashboard legacy usuniƒôty

    // Prze≈ÇƒÖcz widoki w panelu optymalizacji
    const cfgPanel = document.getElementById('autotuning-config-panel');
    const progress = document.getElementById('tuning-progress-panel');
    if (cfgPanel) cfgPanel.classList.toggle('autotune-config-hide', isLocked);
    if (progress) progress.style.display = isLocked ? 'block' : 'none';
    }
    // Legacy handler wynik√≥w strojenia (serwerowych) zosta≈Ç usuniƒôty.
    // Wyniki algorytm√≥w (GA/PSO/ZN/Bayesian) sƒÖ obs≈Çugiwane wy≈ÇƒÖcznie po stronie klienta.
    
    function addResultToTable(tableBody, data) {
        // Add table row (for desktop)
        const row = tableBody.insertRow(0); 
        row.insertCell().textContent = tableBody.rows.length;
        row.insertCell().textContent = (data.kp !== undefined ? data.kp.toFixed(4) : '---');
        row.insertCell().textContent = (data.ki !== undefined ? data.ki.toFixed(4) : '---');
        row.insertCell().textContent = (data.kd !== undefined ? data.kd.toFixed(4) : '---');
        row.insertCell().textContent = (data.fitness !== undefined ? data.fitness.toFixed(4) : '---');
        row.insertCell().textContent = (data.overshoot !== undefined ? data.overshoot.toFixed(2) : '---');
        row.insertCell().textContent = (data.rise_time !== undefined ? data.rise_time.toFixed(2) : '---');
        const actionsCell = row.insertCell(); 
        const applyBtn = document.createElement('button');
        applyBtn.textContent = 'Zastosuj'; 
        applyBtn.classList.add('test-btn');
        applyBtn.addEventListener('click', () => { 
            document.getElementById('balanceKpInput').value = data.kp;
            document.getElementById('balanceKiInput').value = data.ki;
            document.getElementById('balanceKdInput').value = data.kd;
            sendBleMessage({ type: 'set_param', key: 'kp_b', value: data.kp });
            sendBleMessage({ type: 'set_param', key: 'ki_b', value: data.ki });
            sendBleMessage({ type: 'set_param', key: 'kd_b', value: data.kd });
            addLogMessage('[UI] Zastosowano parametry z historii strojenia.', 'info'); 
        });
        actionsCell.appendChild(applyBtn);
        
        // Also add block entry (for mobile)
        const method = AppState.activeTuningMethod;
        let blockContainer;
        if (method.startsWith('ga')) {
            blockContainer = document.getElementById('ga-results-blocks');
        } else if (method.startsWith('pso')) {
            blockContainer = document.getElementById('pso-results-blocks');
        }
        
        if (blockContainer) {
            const block = document.createElement('div');
            block.className = 'result-entry';
            
            const header = document.createElement('div');
            header.className = 'result-header';
            header.innerHTML = `<strong>Wynik #${tableBody.rows.length}:</strong> Fitness = ${data.fitness !== undefined ? data.fitness.toFixed(4) : '---'}`;
            
            const params = document.createElement('div');
            params.className = 'result-params';
            params.textContent = `Kp: ${data.kp !== undefined ? data.kp.toFixed(4) : '---'}, Ki: ${data.ki !== undefined ? data.ki.toFixed(4) : '---'}, Kd: ${data.kd !== undefined ? data.kd.toFixed(4) : '---'}`;
            
            const metrics = document.createElement('div');
            metrics.className = 'result-metrics';
            metrics.textContent = `Overshoot: ${data.overshoot !== undefined ? data.overshoot.toFixed(2) + '%' : '---'}, Rise Time: ${data.rise_time !== undefined ? data.rise_time.toFixed(2) + 'ms' : '---'}`;
            
            const applyBtnBlock = document.createElement('button');
            applyBtnBlock.textContent = 'Zastosuj';
            applyBtnBlock.classList.add('test-btn');
            applyBtnBlock.addEventListener('click', () => {
                document.getElementById('balanceKpInput').value = data.kp;
                document.getElementById('balanceKiInput').value = data.ki;
                document.getElementById('balanceKdInput').value = data.kd;
                sendBleMessage({ type: 'set_param', key: 'kp_b', value: data.kp });
                sendBleMessage({ type: 'set_param', key: 'ki_b', value: data.ki });
                sendBleMessage({ type: 'set_param', key: 'kd_b', value: data.kd });
                addLogMessage('[UI] Zastosowano parametry z historii strojenia.', 'info');
            });
            
            block.appendChild(header);
            block.appendChild(params);
            block.appendChild(metrics);
            block.appendChild(applyBtnBlock);
            
            blockContainer.insertBefore(block, blockContainer.firstChild);
        }
    }
    // Ujednolicone API: prosta warstwa nad sendBleMessage w stylu (type,payload)
    function sendBleCommand(type, payload) {
        const msg = Object.assign({ type }, payload || {});
        sendBleMessage(msg);
    }

    // Refaktoryzacja: wykorzystuj Simple Test API (run_metrics_test / run_relay_test)
    function runDynamicTest(testType) {
        if (!checkTuningPrerequisites()) return;
        addLogMessage(`[Test] Uruchamianie testu: ${testType}`, 'info');

        const testId = Date.now();
        // Nas≈Çuch zako≈Ñczenia aby odblokowaƒá UI, nawet je≈õli nie otrzymamy metryk (np. anulowanie)
        const onMsg = (evt) => {
            const data = evt.detail || evt;
            if (!data || !data.type) return;
            if ((data.type === 'test_complete' && data.testId === testId) || (data.type === 'test_result' && data.testId === testId)) {
                // Gdy dostaniemy komplet lub zako≈Ñczenie, odblokuj UI
                setTuningUiLock(false, '');
                window.removeEventListener('ble_message', onMsg);
            }
        };
        window.addEventListener('ble_message', onMsg);

        // Dla prostoty wszystkie testy dynamiczne w tej karcie mapujemy na test metryk step-response
        // UI algorytm√≥w (GA/PSO/ZN) i tak wywo≈Çuje run_metrics_test z odpowiednimi PID.
        // Tu u≈ºywamy aktualnych warto≈õci z formularza PID balansu jako wej≈õcie testu.
        const kp = parseFloat(document.getElementById('balanceKpInput')?.value) || 0;
        const ki = parseFloat(document.getElementById('balanceKiInput')?.value) || 0;
        const kd = parseFloat(document.getElementById('balanceKdInput')?.value) || 0;
    sendBleCommand('run_dynamic_test', { kp, ki, kd, testId });
    setTuningUiLock(true, 'single-tests');
}
    function handleDynamicTestResult(raw) {
        // Ujednolicenie: obs≈Çu≈º zar√≥wno legacy 'test_result' jak i nowoczesne 'metrics_result'
        const data = {
            kp: raw.kp ?? raw.params?.kp,
            ki: raw.ki ?? raw.params?.ki,
            kd: raw.kd ?? raw.params?.kd,
            itae: raw.itae ?? raw.metrics?.itae,
            overshoot: raw.overshoot ?? raw.metrics?.overshoot,
            rise_time: raw.rise_time ?? raw.metrics?.rise_time,
            settling_time: raw.settling_time ?? raw.metrics?.settling_time,
            steady_state_error: raw.steady_state_error ?? raw.metrics?.steady_state_error,
            testId: raw.testId
        };

        setTuningUiLock(false, '');

        // Aktualizacja historii wynik√≥w je≈ºeli tabela istnieje
        try {
            if (typeof addTestToResultsTable === 'function' && data.kp !== undefined && data.kd !== undefined) {
                const nextIdx = (document.getElementById('results-table-body')?.children.length || 0) + 1;
                addTestToResultsTable(nextIdx, { kp: data.kp, ki: data.ki ?? 0, kd: data.kd }, data.itae ?? Infinity, data.itae ?? NaN, data.overshoot ?? NaN);
                // poka≈º kontener wynik√≥w
                const cont = document.getElementById('results-container');
                if (cont) cont.style.display = 'block';
            }
        } catch(_) {}

        // Lekka notyfikacja do log√≥w
        addLogMessage(`[Test] Wyniki: ITAE=${data.itae?.toFixed?.(4) ?? '---'}, Overshoot=${data.overshoot?.toFixed?.(2) ?? '---'}%`, 'info');
    }
    function initJoystick() {
        const wrapper = document.getElementById('joystickWrapper');
        const size = wrapper.clientWidth;
        const joystickCanvas = document.getElementById('joystickCanvas');
        const joystickCtx = joystickCanvas.getContext('2d');
        joystickCanvas.width = size;
        joystickCanvas.height = size;
        joystickCenter = { x: size / 2, y: size / 2 };
        joystickRadius = size / 2 * 0.75;
        knobRadius = size / 2 * 0.25;
        drawJoystick(joystickCtx, joystickCenter.x, joystickCenter.y);
    }
    function drawJoystick(ctx, x, y) {
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        ctx.beginPath();
        ctx.arc(joystickCenter.x, joystickCenter.y, joystickRadius, 0, 2 * Math.PI);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.fill();
        ctx.beginPath();
        ctx.arc(x, y, knobRadius, 0, 2 * Math.PI);
        ctx.fillStyle = '#61dafb';
        ctx.fill();
    }
    function handleJoystickStart(event) { event.preventDefault(); isDragging = true; }
    function handleJoystickMove(event) { if (!isDragging) return; event.preventDefault(); const joystickCanvas = document.getElementById('joystickCanvas'); let { x, y } = getJoystickPosition(event); const dx = x - joystickCenter.x; const dy = y - joystickCenter.y; const distance = Math.sqrt(dx * dx + dy * dy); if (distance > joystickRadius) { x = joystickCenter.x + (dx / distance) * joystickRadius; y = joystickCenter.y + (dy / distance) * joystickRadius; } drawJoystick(joystickCanvas.getContext('2d'), x, y); const now = Date.now(); if (now - lastJoystickSendTime > JOYSTICK_SEND_INTERVAL) { const joyX = (x - joystickCenter.x) / joystickRadius; const joyY = -(y - joystickCenter.y) / joystickRadius; sendBleMessage({ type: 'joystick', x: joyX, y: joyY }); lastJoystickSendTime = now; } }
    function getJoystickPosition(event) { const rect = document.getElementById('joystickCanvas').getBoundingClientRect(); const touch = event.touches ? event.touches[0] : event; return { x: touch.clientX - rect.left, y: touch.clientY - rect.top }; }
    function handleJoystickEnd(event) { if (!isDragging) return; event.preventDefault(); isDragging = false; drawJoystick(document.getElementById('joystickCanvas').getContext('2d'), joystickCenter.x, joystickCenter.y); sendBleMessage({ type: 'joystick', x: 0, y: 0 }); }
    function pollGamepad() { if (gamepadIndex !== null) { const gp = navigator.getGamepads()[gamepadIndex]; if (!gp) return; if (isMappingButton && actionToMap) { gp.buttons.forEach((button, i) => { if (button.pressed && !lastGamepadState[i]) { Object.keys(gamepadMappings).forEach(key => { if (gamepadMappings[key] === actionToMap) delete gamepadMappings[key]; }); gamepadMappings[i] = actionToMap; saveGamepadMappings(); addLogMessage(`[UI] Akcja '${availableActions[actionToMap].label}' przypisana do przycisku ${i}.`, 'success'); isMappingButton = false; actionToMap = null; renderMappingModal(); } }); } else { gp.buttons.forEach((button, i) => { if (button.pressed && !lastGamepadState[i]) { const action = gamepadMappings[i]; if (action && availableActions[action]) { const element = document.getElementById(availableActions[action].elementId); if (element && !element.disabled) { element.click(); flashElement(element); } } } }); } lastGamepadState = gp.buttons.map(b => b.pressed); let x = gp.axes[0] || 0; let y = gp.axes[1] || 0; if (Math.abs(x) < 0.15) x = 0; if (Math.abs(y) < 0.15) y = 0; sendBleMessage({ type: 'joystick', x: x, y: -y }); } requestAnimationFrame(pollGamepad); }
    window.addEventListener('gamepadconnected', (e) => { gamepadIndex = e.gamepad.index; document.getElementById('gamepadStatus').textContent = 'Polaczony'; document.getElementById('gamepadStatus').style.color = '#a2f279'; addLogMessage(`[UI] Gamepad polaczony: ${e.gamepad.id}`, 'success'); });
    window.addEventListener('gamepaddisconnected', (e) => { gamepadIndex = null; document.getElementById('gamepadStatus').textContent = 'Brak'; document.getElementById('gamepadStatus').style.color = '#f7b731'; addLogMessage('[UI] Gamepad rozlaczony.', 'warn'); });
    function startMapping(action, buttonElement) { if (gamepadIndex === null) { addLogMessage("Podlacz gamepada, aby rozpoczac mapowanie!", "warn"); return; } isMappingButton = true; actionToMap = action; document.querySelectorAll('.mapping-button').forEach(btn => btn.textContent = "Przypisz"); buttonElement.textContent = "Czekam..."; addLogMessage(`[UI] Nasluchiwanie na przycisk dla akcji: ${availableActions[action].label}...`, "info"); }
    function renderMappingModal() { const list = document.getElementById('gamepad-mapping-list'); list.innerHTML = ''; for (const [action, config] of Object.entries(availableActions)) { const row = document.createElement('div'); row.className = 'mapping-row'; const buttonIndex = Object.keys(gamepadMappings).find(key => gamepadMappings[key] === action); row.innerHTML = `<span class="mapping-label">${config.label}</span><span class="mapping-display">${buttonIndex !== undefined ? `Przycisk ${buttonIndex}` : 'Brak'}</span><button class="mapping-button" data-action="${action}">Przypisz</button>`; list.appendChild(row); } list.querySelectorAll('.mapping-button').forEach(button => { button.addEventListener('click', (e) => { const action = e.target.dataset.action; startMapping(action, e.target); }); }); }
    function setupNumericInputs() { 
        document.querySelectorAll('.numeric-input-wrapper').forEach(wrapper => { 
            const container = wrapper.closest('.setting-container') || wrapper.closest('.pwm-input-row'); 
            if (!container) return; 
            const input = container.querySelector('input[type=number]'); 
            const minusBtn = wrapper.querySelector('button:first-child'); 
            const plusBtn = wrapper.querySelector('button:last-child'); 
            if (!input || !minusBtn || !plusBtn || input.disabled) return; 
            const step = parseFloat(input.step) || 1; 
            const isFloat = input.step.includes('.'); 
            
            // Add automatic value clamping on input
            input.addEventListener('input', (e) => {
                let value = parseFloat(e.target.value);
                if (isNaN(value)) return;
                
                const min = parseFloat(e.target.min);
                const max = parseFloat(e.target.max);
                
                if (!isNaN(min) && value < min) {
                    e.target.value = min;
                }
                if (!isNaN(max) && value > max) {
                    e.target.value = max;
                }
            });
            
            // Also clamp on blur (when user leaves the field)
            input.addEventListener('blur', (e) => {
                let value = parseFloat(e.target.value);
                if (isNaN(value)) {
                    e.target.value = parseFloat(e.target.min) || 0;
                    return;
                }
                
                const min = parseFloat(e.target.min);
                const max = parseFloat(e.target.max);
                
                if (!isNaN(min) && value < min) {
                    e.target.value = min;
                    e.target.dispatchEvent(new Event('change', { bubbles: true }));
                }
                if (!isNaN(max) && value > max) {
                    e.target.value = max;
                    e.target.dispatchEvent(new Event('change', { bubbles: true }));
                }
            });
            
            const updateValue = (amount) => { 
                let current = parseFloat(input.value); 
                if (isNaN(current)) current = 0; 
                let newValue = current + amount; 
                if (isFloat) { 
                    const dp = (step.toString().split('.')[1] || '').length; 
                    newValue = parseFloat(newValue.toFixed(dp)); 
                } 
                const min = parseFloat(input.min); 
                const max = parseFloat(input.max); 
                if (!isNaN(min)) newValue = Math.max(min, newValue); 
                if (!isNaN(max)) newValue = Math.min(max, newValue); 
                input.value = newValue; 
                input.dispatchEvent(new Event('change', { bubbles: true })); 
            }; 
            minusBtn.addEventListener('click', () => updateValue(-step)); 
            plusBtn.addEventListener('click', () => updateValue(step)); 
        }); 
    }
    function sendFullConfigToRobot() {
        const params = {};
        for (const [inputId, snakeKey] of Object.entries(parameterMapping)) {
            const input = document.getElementById(inputId);
            if (!input) continue;
            let value;
            if (input.type === 'checkbox') value = input.checked;
            else value = parseFloat(input.value);

            // Konwersje jednostek i procent√≥w
            if (['turn_factor', 'expo_joystick', 'joystick_sensitivity', 'joystick_deadzone', 'balance_pid_derivative_filter_alpha', 'speed_pid_filter_alpha', 'position_pid_filter_alpha', 'weights_itae', 'weights_overshoot', 'weights_control_effort'].includes(snakeKey)) {
                value /= 100.0;
            }
            if (snakeKey === 'ga_mutation_rate') {
                value /= 100.0; // % -> frakcja
            }
            if (snakeKey === 'tuning_trial_duration_ms') {
                value = (value * 1000.0); // s -> ms
            }
            params[snakeKey] = value;
        }
        // Add trim parameters from displays
        params['trim_angle'] = parseFloat(document.getElementById('trimValueDisplay').textContent) || 0;
        params['roll_trim'] = parseFloat(document.getElementById('rollTrimValueDisplay').textContent) || 0;
        addLogMessage('[UI] Wysylam pelna konfiguracje do robota...', 'info');
        sendBleMessage({ type: 'full_config', params });
    }
    // LEGACY REMOVED: setupEventListeners() nieu≈ºywane po refaktorze ‚Äì zachowane tylko jako komentarz dla historii.
    // (Je≈õli potrzebne w przysz≈Ço≈õci: przenie≈õƒá potrzebne listenery do setupParameterListeners.)

    function setupParameterListeners() {
        const sendSingleParam = (inputId, value) => { 
            if (AppState.isApplyingConfig) return; 
            const snakeKey = parameterMapping[inputId]; 
            if (snakeKey) { 
                if (['turn_factor', 'expo_joystick', 'joystick_sensitivity', 'joystick_deadzone', 'balance_pid_derivative_filter_alpha', 'speed_pid_filter_alpha', 'position_pid_filter_alpha', 'weights_itae', 'weights_overshoot', 'weights_control_effort'].includes(snakeKey)) { 
                    value /= 100.0; 
                } 
                sendBleMessage({ type: 'set_param', key: snakeKey, value: value }); 
            } 
        }; 
        const debouncedSendSingleParam = debounce(sendSingleParam, 400); 
        document.querySelectorAll('.config-value').forEach(input => { input.addEventListener('change', (e) => { debouncedSendSingleParam(e.target.id, parseFloat(e.target.value)); }); }); 
        // AUTOTUNING: wysy≈Çanie parametr√≥w metod (GA/PSO/ZN) jako set_tuning_config_param z odpowiednimi konwersjami
        const sendTuningParam = (snakeKey, rawValue) => {
            if (AppState.isApplyingConfig) return;
            let value = rawValue;
            if (typeof value === 'number' && isNaN(value)) return;
            if (snakeKey && snakeKey.startsWith('weights_')) {
                value = (parseFloat(value) / 100.0);
            }
            if (snakeKey === 'ga_mutation_rate') {
                value = (parseFloat(value) / 100.0);
            }
            if (snakeKey === 'tuning_trial_duration_ms') {
                value = Math.round(parseFloat(value) * 1000.0); // s -> ms
            }
            sendBleMessage({ type: 'set_tuning_config_param', key: snakeKey, value });
        };
        const debouncedSendTuningParam = debounce((inputId, val) => {
            const snakeKey = parameterMapping[inputId];
            if (!snakeKey) return;
            sendTuningParam(snakeKey, val);
        }, 300);
        // Zarejestruj listenery dla wszystkich p√≥l autotuningu, kt√≥re nie majƒÖ klasy .config-value
        for (const [inputId, snakeKey] of Object.entries(parameterMapping)) {
            const input = document.getElementById(inputId);
            if (!input) continue;
            if (input.classList.contains('config-value')) continue; // te obs≈Çuguje blok wy≈ºej
            // Ogranicz do kluczy strojenia/poszukiwania/pr√≥b
            const isTuningKey = (
                snakeKey.startsWith('ga_') || snakeKey.startsWith('pso_') || snakeKey.startsWith('space_') ||
                snakeKey.startsWith('weights_') || snakeKey === 'tuning_trial_duration_ms' || snakeKey === 'zn_amplitude'
            );
            if (!isTuningKey) continue;
            if (input.type === 'checkbox') {
                input.addEventListener('change', (e) => {
                    sendBleMessage({ type: 'set_tuning_config_param', key: snakeKey, value: e.target.checked });
                });
            } else {
                input.addEventListener('change', (e) => {
                    const v = parseFloat(e.target.value);
                    debouncedSendTuningParam(inputId, v);
                });
            }
        }
        const joystickCanvasEl = document.getElementById('joystickCanvas');
        if (joystickCanvasEl) {
            joystickCanvasEl.addEventListener('mousedown', handleJoystickStart); document.addEventListener('mousemove', handleJoystickMove); document.addEventListener('mouseup', handleJoystickEnd);
            joystickCanvasEl.addEventListener('touchstart', handleJoystickStart, { passive: false }); document.addEventListener('touchmove', handleJoystickMove, { passive: false }); document.addEventListener('touchend', handleJoystickEnd); document.addEventListener('touchcancel', handleJoystickEnd);
        }
        const connectBleBtnEl = document.getElementById('connectBleBtn');
        connectBleBtnEl?.addEventListener('click', connectBLE);
        ['balanceSwitch', 'holdPositionSwitch', 'speedModeSwitch'].forEach(id => { const el = document.getElementById(id); if(!el) return; el.addEventListener('change', (e) => { if (AppState.isApplyingConfig) return; const typeMap = { 'balanceSwitch': 'balance_toggle', 'holdPositionSwitch': 'hold_position_toggle', 'speedModeSwitch': 'speed_mode_toggle' }; sendBleMessage({ type: typeMap[id], enabled: e.target.checked }); }); });

        // POPRAWKA: Usuniƒôto stare listenery dla trim+/- i dodano nowe, poprawne dla precyzyjnych przycisk√≥w.
    const toolButtons = { 'resetZeroBtn': { type: 'reset_pitch' }, 'resetEncodersBtn': { type: 'reset_encoders' }, 'emergencyStopBtn': { type: 'emergency_stop' } };
    // Trim: aktualizacja + wysy≈Çka set_param (jednolite traktowanie)
    function updateAndSendTrim(delta) {
        const span = document.getElementById('trimValueDisplay');
        if (!span) return; const current = parseFloat(span.textContent) || 0; const v = current + delta; span.textContent = v.toFixed(2);
        sendBleMessage({ type: 'set_param', key: 'trim_angle', value: v });
    }
    document.getElementById('trimMinus01Btn')?.addEventListener('click', () => updateAndSendTrim(-0.1));
    document.getElementById('trimMinus001Btn')?.addEventListener('click', () => updateAndSendTrim(-0.01));
    document.getElementById('trimPlus001Btn')?.addEventListener('click', () => updateAndSendTrim(0.01));
    document.getElementById('trimPlus01Btn')?.addEventListener('click', () => updateAndSendTrim(0.1));
    // Roll trim: aktualizacja + wysy≈Çka set_param
    document.getElementById('resetRollZeroBtn')?.addEventListener('click', () => sendBleMessage({ type: 'reset_roll' }));
    function updateAndSendRollTrim(delta) {
        const span = document.getElementById('rollTrimValueDisplay');
        if (!span) return; const current = parseFloat(span.textContent) || 0; const v = current + delta; span.textContent = v.toFixed(2);
        sendBleMessage({ type: 'set_param', key: 'roll_trim', value: v });
    }
    document.getElementById('rollTrimMinus01Btn')?.addEventListener('click', () => updateAndSendRollTrim(-0.1));
    document.getElementById('rollTrimMinus001Btn')?.addEventListener('click', () => updateAndSendRollTrim(-0.01));
    document.getElementById('rollTrimPlus001Btn')?.addEventListener('click', () => updateAndSendRollTrim(0.01));
    document.getElementById('rollTrimPlus01Btn')?.addEventListener('click', () => updateAndSendRollTrim(0.1));

    document.getElementById('saveBtn')?.addEventListener('click', () => {
            if (AppState.isConnected && confirm("Czy na pewno chcesz trwale zapisaƒá bie≈ºƒÖcƒÖ konfiguracjƒô z panelu do pamiƒôci EEPROM robota?")) {
                addLogMessage('[UI] Wyslano polecenie zapisu konfiguracji do EEPROM...', 'info');
                sendBleMessage({ type: 'save_tunings' });
            } else if (!AppState.isConnected) { addLogMessage('[UI] Po≈ÇƒÖcz z robotem przed zapisem konfiguracji.', 'warn'); }
        });
    document.getElementById('loadBtn')?.addEventListener('click', () => { if (confirm("UWAGA! Spowoduje to nadpisanie wszystkich niezapisanych zmian w panelu. Kontynuowac?")) { AppState.isSynced = false; AppState.tempParams = {}; AppState.tempStates = {}; sendBleMessage({ type: 'request_full_config' }); } });

        document.getElementById('calibrateMpuBtn')?.addEventListener('click', showCalibrationModal);
        document.getElementById('calibrateZeroPointBtn')?.addEventListener('click', () => { if (confirm("Upewnij sie, ze robot stoi na idealnie plaskiej powierzchni. Robot bedzie balansowal przez 10 sekund w celu znalezienia dokladnego punktu rownowagi. Kontynuowac?")) { sendBleMessage({ type: 'calibrate_zero_point' }); } });

    document.getElementById('applySelectedPresetBtn')?.addEventListener('click', applySelectedPreset); document.getElementById('saveCurrentAsPresetBtn')?.addEventListener('click', saveCurrentAsPreset); document.getElementById('deleteSelectedPresetBtn')?.addEventListener('click', deleteSelectedPreset); 
    document.querySelectorAll('.help-icon').forEach(icon => { icon.addEventListener('click', (e) => { e.stopPropagation(); const container = icon.closest('.setting-container') || icon.closest('.control-row') || icon.closest('.fitness-weight-item'); if(!container) return; const next = container.nextElementSibling; const helpText = (next && next.classList && next.classList.contains('help-text')) ? next : container.querySelector('.help-text'); if (helpText) { helpText.classList.toggle('visible'); const accordionContent = container.closest('.accordion-content'); if (accordionContent) updateAccordionHeight(accordionContent); } }); }); 
    // Legacy IMU mapping wizard: usuniƒôty
    }
    function setupManualTuneButtons() {
        // Przechowuj timery auto-stop dla test√≥w 5s
        const activeTestTimers = new Map(); // key: `${motor}-${direction}` -> timeoutId

        document.querySelectorAll('.manual-tune-row').forEach(row => {
            const motor = row.dataset.motor;
            const direction = row.dataset.direction;
            const rowKey = `${motor}-${direction}`;
            const input = row.querySelector('.tune-input');
            const testBtn = row.querySelector('.test-btn');
            const stopBtn = row.querySelector('.stop-btn');
            const autoBtn = row.querySelector('.auto-btn');

            testBtn.addEventListener('click', () => {
                const pwm = parseInt(input.value) || 0;
                if (pwm <= 0) { addLogMessage('[UI] Wpisz dodatni PWM do testu.', 'warn'); return; }
                // Wy≈õlij start testu rƒôcznego
                sendBleMessage({ type: 'manual_tune_motor', motor, direction, pwm });
                addLogMessage(`[UI] Test ${motor} ${direction} rozpoczƒôty na 5s (PWM=${pwm}).`, 'info');
                // Skasuj poprzedni timer (je≈õli by≈Ç)
                if (activeTestTimers.has(rowKey)) {
                    clearTimeout(activeTestTimers.get(rowKey));
                }
                // Ustaw auto-stop po 5 sekundach
                const timeoutId = setTimeout(() => {
                    sendBleMessage({ type: 'manual_tune_motor', motor, direction, pwm: 0 });
                    addLogMessage(`[UI] Test ${motor} ${direction} zako≈Ñczony automatycznie po 5s.`, 'info');
                    activeTestTimers.delete(rowKey);
                }, 5000);
                activeTestTimers.set(rowKey, timeoutId);
            });

            stopBtn.addEventListener('click', () => {
                // Rƒôczne zatrzymanie ‚Äì przerwij timer i wy≈õlij stop
                if (activeTestTimers.has(rowKey)) {
                    clearTimeout(activeTestTimers.get(rowKey));
                    activeTestTimers.delete(rowKey);
                }
                sendBleMessage({ type: 'manual_tune_motor', motor, direction, pwm: 0 });
                addLogMessage(`[UI] Test ${motor} ${direction} zatrzymany.`, 'warn');
            });

            autoBtn.addEventListener('click', (e) => {
                if (confirm("UWAGA! Upewnij sie, ze robot jest uniesiony, a kola moga sie swobodnie obracac. Kontynuowac?")) {
                    const startValue = parseInt(document.getElementById('pwmTuneStartInput').value);
                    sendBleMessage({ type: 'autotune_single_pwm', motor, direction, start_pwm: startValue });
                    e.target.disabled = true; e.target.textContent = 'Szukanie...';
                    addLogMessage(`[UI] Rozpoczynam auto-strojenie dla ${motor} ${direction}...`, 'info');
                }
            });
        });

        document.getElementById('manualTuneStopAll').addEventListener('click', () => {
            sendBleMessage({ type: 'manual_tune_stop_all' });
            addLogMessage('[UI] Zatrzymano wszystkie silniki.', 'warn');
        });
    }
    function setupGamepadMappingModal() { document.getElementById('open-gamepad-modal-btn').addEventListener('click', () => { document.getElementById('gamepad-mapping-modal').style.display = 'flex'; }); document.getElementById('close-modal-btn').addEventListener('click', () => { document.getElementById('gamepad-mapping-modal').style.display = 'none'; }); }
    function flashElement(element) { if (!element) return; const target = element.tagName === 'INPUT' ? element.closest('.switch') || element.closest('.control-row') || element : element; target.classList.add('gamepad-flash'); setTimeout(() => target.classList.remove('gamepad-flash'), 300); }
    function loadGamepadMappings() { const saved = localStorage.getItem(GAMEPAD_MAPPING_KEY); gamepadMappings = saved ? JSON.parse(saved) : {}; }
    function saveGamepadMappings() { localStorage.setItem(GAMEPAD_MAPPING_KEY, JSON.stringify(gamepadMappings)); }
    function setupDpadControls() { document.querySelectorAll('.dpad-btn').forEach(btn => { btn.addEventListener('click', (e) => { const action = e.currentTarget.dataset.dpad; if (action === 'up') sendBleMessage({ type: 'execute_move', distance_cm: parseFloat(document.getElementById('dpadDistInput').value) }); else if (action === 'down') sendBleMessage({ type: 'execute_move', distance_cm: -parseFloat(document.getElementById('dpadDistInput').value) }); else if (action === 'left') sendBleMessage({ type: 'execute_rotate', angle_deg: -parseFloat(document.getElementById('dpadAngleInput').value) }); else if (action === 'right') sendBleMessage({ type: 'execute_rotate', angle_deg: parseFloat(document.getElementById('dpadAngleInput').value) }); else if (action === 'stop') sendBleMessage({ type: 'command_stop' }); }); }); }
    function refreshCalibrationFromTelemetry(){
        // Odczytaj ostatniƒÖ telemetriƒô i zaktualizuj paski w modalu
        const td = window.telemetryData || {};
        const sys = Number.isFinite(td.calib_sys) ? td.calib_sys : (Number.isFinite(td.calibSystem) ? td.calibSystem : 0);
        const accel = Number.isFinite(td.calib_accel) ? td.calib_accel : (Number.isFinite(td.calibAccel) ? td.calibAccel : 0);
        const gyro = Number.isFinite(td.calib_gyro) ? td.calib_gyro : (Number.isFinite(td.calibGyro) ? td.calibGyro : 0);
        const mag = Number.isFinite(td.calib_mag) ? td.calib_mag : (Number.isFinite(td.calibMag) ? td.calibMag : 0);
        const sysBar = document.getElementById('calib-sys-bar'); const sysTxt = document.getElementById('calib-sys-text');
        const accBar = document.getElementById('calib-accel-bar'); const accTxt = document.getElementById('calib-accel-text');
        const gyrBar = document.getElementById('calib-gyro-bar'); const gyrTxt = document.getElementById('calib-gyro-text');
        const magBar = document.getElementById('calib-mag-bar'); const magTxt = document.getElementById('calib-mag-text');
        if(sysBar) sysBar.value = sys; if(sysTxt) sysTxt.textContent = sys;
        if(accBar) accBar.value = accel; if(accTxt) accTxt.textContent = accel;
        if(gyrBar) gyrBar.value = gyro; if(gyrTxt) gyrTxt.textContent = gyro;
        if(magBar) magBar.value = mag; if(magTxt) magTxt.textContent = mag;
    }
    function setupCalibrationModal() {
        const upd = document.getElementById('calib-update-btn');
        if (upd) upd.addEventListener('click', refreshCalibrationFromTelemetry);
        const close = document.getElementById('calib-close-btn');
        if (close) close.addEventListener('click', () => { const sys = parseInt(document.getElementById('calib-sys-text').textContent) || 0; if (sys >= 3) { hideCalibrationModal(); } else if (confirm('Poziom kalibracji systemu jest niski (<3). Czy na pewno chcesz zamknac?')) { hideCalibrationModal(); } });
    }
    function showCalibrationModal() { document.getElementById('calibration-modal').style.display = 'flex'; isCalibrationModalShown = true; sendBleMessage({ type: 'set_rgb_blink', colors: ['00FF00', 'FFA500'] }); addLogMessage('[UI] Rozpocznij proces kalibracji IMU - obracaj robota powoli we wszystkich kierunkach.', 'info'); }
    function hideCalibrationModal() { document.getElementById('calibration-modal').style.display = 'none'; isCalibrationModalShown = false; sendBleMessage({ type: 'stop_rgb_blink' }); addLogMessage('[UI] Asystent kalibracji zamkniety.', 'info'); }
    function updateCalibrationProgress(axis, value) { if (document.getElementById('calibration-modal').style.display === 'none') return; const barId = `calib-${axis}-bar`; const textId = `calib-${axis}-text`; const bar = document.getElementById(barId); const text = document.getElementById(textId); if (bar && text) { bar.value = value; text.textContent = value; const sys = parseInt(document.getElementById('calib-sys-text').textContent) || 0; if (sys >= 3 && document.getElementById('calibration-modal').style.display !== 'none') { hideCalibrationModal(); addLogMessage('[UI] Kalibracja systemu osiagnela poziom 3. Asystent zamkniety.', 'success'); } } }; // ZMIANA: Usuniƒôto duplikacjƒô funkcji setupCalibrationModal()
    function init3DVisualization() { const container = document.getElementById('robot3d-container'); scene3D = new THREE.Scene(); camera3D = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 2000); camera3D.position.set(28, 22, 48); camera3D.lookAt(0, 8, 0); renderer3D = new THREE.WebGLRenderer({ antialias: true }); renderer3D.setSize(container.clientWidth, container.clientHeight); container.appendChild(renderer3D.domElement); controls3D = new THREE.OrbitControls(camera3D, renderer3D.domElement); controls3D.target.set(0, 8, 0); controls3D.maxPolarAngle = Math.PI / 2; const ambientLight = new THREE.AmbientLight(0xffffff, 0.8); scene3D.add(ambientLight); const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9); directionalLight.position.set(10, 20, 15); scene3D.add(directionalLight); const PLANE_SIZE_CM = 2000; groundTexture = createCheckerTexture(40); const repeats = PLANE_SIZE_CM / 40; groundTexture.repeat.set(repeats, repeats); const groundMaterial = new THREE.MeshStandardMaterial({ map: groundTexture, roughness: 1.0, metalness: 0.0 }); const groundGeo = new THREE.PlaneGeometry(PLANE_SIZE_CM, PLANE_SIZE_CM, 1, 1); groundMesh = new THREE.Mesh(groundGeo, groundMaterial); groundMesh.rotation.x = -Math.PI / 2; groundMesh.position.y = 0; scene3D.add(groundMesh); robotPivot = createRobotModel3D(); robotPivot.position.y = 4.1; scene3D.add(robotPivot); skyDome = createSkyDome(); scene3D.add(skyDome); window.addEventListener('resize', () => { const width = container.clientWidth; const height = container.clientHeight; camera3D.aspect = width / height; camera3D.updateProjectionMatrix(); renderer3D.setSize(width, height); }); setupControls3D(); setupCalibrationModal(); }; // ZMIANA: Usuniƒôto duplikacjƒô funkcji setupCalibrationModal()
    function createCustomWheel(totalRadius, tireThickness, width) { const wheelGroup = new THREE.Group(); const tireMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.8 }); const rimMaterial = new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.4 }); const rimRadius = totalRadius - tireThickness; const tire = new THREE.Mesh(new THREE.TorusGeometry(rimRadius + tireThickness / 2, tireThickness / 2, 16, 100), tireMaterial); wheelGroup.add(tire); const rimShape = new THREE.Shape(); rimShape.absarc(0, 0, rimRadius, 0, Math.PI * 2, false); const holePath = new THREE.Path(); holePath.absarc(0, 0, rimRadius * 0.85, 0, Math.PI * 2, true); rimShape.holes.push(holePath); const extrudeSettings = { depth: width * 0.4, bevelEnabled: false }; const outerRimGeometry = new THREE.ExtrudeGeometry(rimShape, extrudeSettings); outerRimGeometry.center(); const outerRim = new THREE.Mesh(outerRimGeometry, rimMaterial); wheelGroup.add(outerRim); const hubRadius = rimRadius * 0.2; const hub = new THREE.Mesh(new THREE.CylinderGeometry(hubRadius, hubRadius, width * 0.5, 24), rimMaterial); hub.rotateX(Math.PI / 2); wheelGroup.add(hub); const spokeLength = (rimRadius * 0.85) - hubRadius; const spokeGeometry = new THREE.BoxGeometry(spokeLength, rimRadius * 0.15, width * 0.4); spokeGeometry.translate(hubRadius + spokeLength / 2, 0, 0); for (let i = 0; i < 6; i++) { const spoke = new THREE.Mesh(spokeGeometry, rimMaterial); spoke.rotation.z = i * (Math.PI / 3); wheelGroup.add(spoke); } return wheelGroup; }
    function createRobotModel3D() { const BODY_WIDTH = 9.0, BODY_HEIGHT = 6.0, BODY_DEPTH = 3.5, WHEEL_GAP = 1.0; const MAST_HEIGHT = 14.5, MAST_THICKNESS = 1.5; const BATTERY_WIDTH = 6.0, BATTERY_HEIGHT = 1.0, BATTERY_DEPTH = 3.0; const TIRE_THICKNESS = 1.0, WHEEL_WIDTH = 2.0; const WHEEL_RADIUS_3D = 4.1; const pivot = new THREE.Object3D(); const model = new THREE.Group(); const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x1C1C1C }); const batteryMaterial = new THREE.MeshStandardMaterial({ color: 0x4169E1 }); const body = new THREE.Mesh(new THREE.BoxGeometry(BODY_WIDTH, BODY_HEIGHT, BODY_DEPTH), bodyMaterial); body.position.y = WHEEL_RADIUS_3D; model.add(body); const mast = new THREE.Mesh(new THREE.BoxGeometry(MAST_THICKNESS, MAST_HEIGHT, MAST_THICKNESS), bodyMaterial); mast.position.y = WHEEL_RADIUS_3D + BODY_HEIGHT / 2 + MAST_HEIGHT / 2; model.add(mast); const battery = new THREE.Mesh(new THREE.BoxGeometry(BATTERY_WIDTH, BATTERY_HEIGHT, BATTERY_DEPTH), batteryMaterial); battery.position.y = mast.position.y + MAST_HEIGHT / 2 + BATTERY_HEIGHT / 2; model.add(battery); leftWheel = createCustomWheel(WHEEL_RADIUS_3D, TIRE_THICKNESS, WHEEL_WIDTH); leftWheel.rotation.y = Math.PI / 2; leftWheel.position.set(-(BODY_WIDTH / 2 + WHEEL_GAP), WHEEL_RADIUS_3D, 0); model.add(leftWheel); rightWheel = createCustomWheel(WHEEL_RADIUS_3D, TIRE_THICKNESS, WHEEL_WIDTH); rightWheel.rotation.y = Math.PI / 2; rightWheel.position.set(BODY_WIDTH / 2 + WHEEL_GAP, WHEEL_RADIUS_3D, 0); model.add(rightWheel); model.position.y = -WHEEL_RADIUS_3D; pivot.add(model); return pivot; }
    function createCheckerTexture(squareSizeCm = 20, colorA = '#C8C8C8', colorB = '#787878') { const size = 256; const squares = 2; const canvas = document.createElement('canvas'); canvas.width = size; canvas.height = size; const ctx = canvas.getContext('2d'); const s = size / squares; for (let y = 0; y < squares; y++) { for (let x = 0; x < squares; x++) { ctx.fillStyle = ((x + y) % 2 === 0) ? colorA : colorB; ctx.fillRect(x * s, y * s, s, s); } } const tex = new THREE.CanvasTexture(canvas); tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping; tex.anisotropy = 8; tex.encoding = THREE.sRGBEncoding; return tex; }
    function createSkyDome() { 
        const width = 2048, height = 1024; 
        const canvas = document.createElement('canvas'); 
        canvas.width = width; 
        canvas.height = height; 
        const ctx = canvas.getContext('2d'); 
        
        // Create gradient background
        const grad = ctx.createLinearGradient(0, 0, 0, height); 
        grad.addColorStop(0, '#87CEEB'); 
        grad.addColorStop(0.6, '#B0E0E6'); 
        grad.addColorStop(1, '#E6F2FA'); 
        ctx.fillStyle = grad; 
        ctx.fillRect(0, 0, width, height); 
        
        // Draw clouds with seamless wrapping
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)'; 
        for (let i = 0; i < 150; i++) { 
            const x = Math.random() * width; 
            const y = Math.random() * height * 0.6; 
            const radius = 20 + Math.random() * 80; 
            const blur = 10 + Math.random() * 20; 
            ctx.filter = `blur(${blur}px)`; 
            
            // Draw the cloud
            ctx.beginPath(); 
            ctx.arc(x, y, radius, 0, Math.PI * 2); 
            ctx.fill(); 
            
            // Draw the cloud again on the opposite edge to create seamless wrapping
            // If cloud is near the right edge, draw it also on the left edge
            if (x > width - radius * 2) {
                ctx.beginPath(); 
                ctx.arc(x - width, y, radius, 0, Math.PI * 2); 
                ctx.fill(); 
            }
            // If cloud is near the left edge, draw it also on the right edge
            if (x < radius * 2) {
                ctx.beginPath(); 
                ctx.arc(x + width, y, radius, 0, Math.PI * 2); 
                ctx.fill(); 
            }
        } 
        ctx.filter = 'none'; 
        
        const tex = new THREE.CanvasTexture(canvas); 
        tex.wrapS = THREE.RepeatWrapping; 
        tex.wrapT = THREE.ClampToEdgeWrapping; 
        tex.encoding = THREE.sRGBEncoding; 
        
        const skyGeo = new THREE.SphereGeometry(1000, 32, 16); 
        const skyMat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.BackSide }); 
        const skyDome = new THREE.Mesh(skyGeo, skyMat); 
        return skyDome; 
    }
    function setupControls3D() { document.getElementById('reset3dViewBtn').addEventListener('click', () => { camera3D.position.set(28, 22, 48); controls3D.target.set(0, 8, 0); controls3D.update(); }); document.getElementById('toggle3dAnimationBtn').addEventListener('click', () => isAnimation3DEnabled = !isAnimation3DEnabled); document.getElementById('toggle3dMovementBtn').addEventListener('click', () => { isMovement3DEnabled = !isMovement3DEnabled; if(!isMovement3DEnabled) { lastEncoderAvg = (currentEncoderLeft + currentEncoderRight) / 2; } }); }
    
    function update3DAnimation() {
        if (isAnimation3DEnabled && robotPivot) {
            // NOWE: u≈ºywamy bezpo≈õrednio kwaternionu z telemetrii + mapowanie przez premno≈ºenie.
            // Eliminujemy artefakt unoszenia wynikajƒÖcy z dynamicznej korekty wysoko≈õci zale≈ºnej od roll.
            if (typeof window.telemetryData?.qw === 'number') {
                try {
                    // Surowy kwaternion z IMU (Three.js: x,y,z,w)
                    const qRaw = new THREE.Quaternion(
                        window.telemetryData.qx,
                        window.telemetryData.qy,
                        window.telemetryData.qz,
                        window.telemetryData.qw
                    ).normalize();

                    // Budowa kwaternionu korekcyjnego na podstawie mapowania.
                    // Uwaga: pojedynczy sign flip osi jest odbiciem (nie reprezentowalny jako czysta rotacja);
                    // je≈õli liczba negatywnych znak√≥w jest parzysta ‚Äì mo≈ºna odwzorowaƒá jako rotacjƒô 180¬∞ wok√≥≈Ç osi prostopad≈Çej.
                    const signs = [modelMapping.pitch.sign, modelMapping.yaw.sign, modelMapping.roll.sign];
                    const negCount = signs.filter(s => s === -1).length;
                    let qCorr = new THREE.Quaternion(); // identity

                    // Permutacja osi + znaki: realizujemy przez przej≈õcie do Euler, przemapowanie i z≈Ço≈ºenie z powrotem.
                    // Dla ograniczenia artefakt√≥w wprowadzamy jednorazowy kwaternion docelowy i p≈Çynne przej≈õcie (slerp).
                    const eulRaw = computeEulerFromQuaternion(window.telemetryData.qw, window.telemetryData.qx, window.telemetryData.qy, window.telemetryData.qz);
                    let mapped = eulRaw ? applyModelMappingToEuler(eulRaw) : {pitch:0,yaw:0,roll:0};
                    // Je≈õli negCount jest nieparzyste ‚Äì stosujemy fallback (bez pr√≥b tworzenia niepoprawnej rotacji).
                    if (negCount % 2 === 0) {
                        // Mo≈ºna spr√≥bowaƒá zakodowaƒá kombinacjƒô dw√≥ch flips jako rotacjƒô 180¬∞ wok√≥≈Ç pozosta≈Çej osi.
                        // (Heurystyka ‚Äì poprawia przypadki odwrotu dw√≥ch osi.)
                        if (negCount === 2) {
                            // Znajd≈∫ o≈õ, kt√≥ra pozosta≈Ça dodatnia
                            const idx = signs.findIndex(s => s === 1);
                            const axisVec = idx === 0 ? new THREE.Vector3(1,0,0) : (idx === 1 ? new THREE.Vector3(0,1,0) : new THREE.Vector3(0,0,1));
                            qCorr.setFromAxisAngle(axisVec, Math.PI); // 180¬∞ rotacja kompensujƒÖca dwa odbicia
                        }
                    }
                    // Kwaternion wynikowy: qResult = qCorr * qMappedEuler
                    const qMappedEuler = new THREE.Quaternion().setFromEuler(new THREE.Euler(
                        THREE.MathUtils.degToRad(mapped.pitch),
                        THREE.MathUtils.degToRad(mapped.yaw),
                        THREE.MathUtils.degToRad(mapped.roll),
                        'YXZ'
                    ));
                    const qResult = new THREE.Quaternion().multiplyQuaternions(qCorr, qMappedEuler).normalize();

                    // P≈Çynne przej≈õcie (redukcja mikro-skok√≥w przy wrap 360¬∞)
                    robotPivot.quaternion.slerp(qResult, 0.35);
                } catch (err) {
                    console.error('Quaternion mapping error:', err);
                }
            } else {
                // Brak kwaternionu ‚Äì pozostaw orientation bez zmian.
            }

            // Sta≈Ça wysoko≈õƒá (z minimalnym podniesieniem aby ko≈Ça nie "przecina≈Çy" pod≈Çogi)
            robotPivot.position.y = 4.4; // 4.1 + 0.3 buffer
            
            // Aktualizacja kamery w trybie "Perspektywa Robota"
            const isRobotPerspective = document.getElementById('robotPerspectiveCheckbox').checked;
            controls3D.enabled = !isRobotPerspective; // Wylacz OrbitControls w trybie perspektywy

            if (isRobotPerspective) {
                const offset = new THREE.Vector3(0, 15, robotPerspectiveZoom); // Uzyj zmiennej do kontroli dystansu
                offset.applyQuaternion(robotPivot.quaternion); // Obroc wektor offsetu zgodnie z orientacja robota
                
                const cameraPosition = robotPivot.position.clone().add(offset);
                camera3D.position.lerp(cameraPosition, 0.1); // Plynne przejscie do nowej pozycji
                
                const lookAtPosition = robotPivot.position.clone().add(new THREE.Vector3(0, 10, 0)); // Patrz troche powyzej srodka robota
                camera3D.lookAt(lookAtPosition);
            }

            // Reszta funkcji pozostaje bez zmian (obrot kol, ruch podloza itp.)
            const ppr = parseFloat(document.getElementById('encoderPprInput').value) || 820;
            const wheelRotationL = (currentEncoderLeft / ppr) * 2 * Math.PI;
            const wheelRotationR = (currentEncoderRight / ppr) * 2 * Math.PI;
            if (leftWheel) leftWheel.rotation.z = -wheelRotationL;
            if (rightWheel) rightWheel.rotation.z = -wheelRotationR;
            if (isMovement3DEnabled) {
                const wheelDiameter = parseFloat(document.getElementById('wheelDiameterInput').value) || 8.2;
                const currentEncoderAvg = (currentEncoderLeft + currentEncoderRight) / 2;
                const dist_cm = ((currentEncoderAvg - lastEncoderAvg) / ppr) * Math.PI * wheelDiameter;
                if (groundTexture) {
                    // Uzyj juz ustawionej, bezpiecznej rotacji z samego modelu, aby uniknac bledu NaN
                    // Pobieramy rotacjƒô modelu wok√≥≈Ç osi Y, kt√≥ra odpowiada za kurs (yaw)
                    const yawRad = robotPivot.rotation.y;
                    const dx = Math.sin(yawRad) * dist_cm;
                    const dz = Math.cos(yawRad) * dist_cm;
                    const squaresPerCm = 1 / 20;
                    groundTexture.offset.x += dx * squaresPerCm;
                    groundTexture.offset.y -= dz * squaresPerCm;
                    groundTexture.needsUpdate = true;
                }
                const logicalX = (groundTexture ? -groundTexture.offset.x * 20 : 0);
                const logicalZ = (groundTexture ? -groundTexture.offset.y * 20 : 0);
                document.getElementById('robot3d-position-x').textContent = logicalX.toFixed(1) + ' cm';
                document.getElementById('robot3d-position-z').textContent = logicalZ.toFixed(1) + ' cm';
                lastEncoderAvg = currentEncoderAvg;
            }
        }
    }
    
    function animate3D() {
        requestAnimationFrame(animate3D);

        update3DAnimation();

        // Powolny obrot kopuly nieba dla efektu dynamiki
        if (skyDome) {
            skyDome.rotation.y += 0.00005;
        }

        if (controls3D && renderer3D && scene3D && camera3D) {
            controls3D.update();
            renderer3D.render(scene3D, camera3D);
        }
    }

// ========================================================================
// AUTO-TUNING ALGORITHMS - CLIENT-SIDE IMPLEMENTATION
// ========================================================================

// Global tuning session management
let currentTuningSession = null;
let fitnessChart = null;
let fitnessChartData = [];

// ========================================================================
// HELPER FUNCTIONS
// ========================================================================

function mean(arr) {
    if (arr.length === 0) return 0;
    return arr.reduce((a, b) => a + b, 0) / arr.length;
}

// NOTE: a delay helper (const delay = ms => ...) is already defined earlier in the file;
// the duplicate function declaration was removed to avoid "Declaration or statement expected" / duplicate identifier errors.

function updateBestDisplay(params) {
    document.getElementById('best-kp').textContent = params.kp.toFixed(3);
    document.getElementById('best-ki').textContent = params.ki.toFixed(3);
    document.getElementById('best-kd').textContent = params.kd.toFixed(3);
    if (params.fitness !== undefined && params.fitness !== Infinity) {
        document.getElementById('best-fitness').textContent = params.fitness.toFixed(4);
    }
    document.getElementById('apply-best-btn').disabled = false;
}

function updateProgressDisplay(current, total, bestFitness) {
    document.getElementById('current-iteration').textContent = current;
    document.getElementById('total-iterations').textContent = total;
    if (bestFitness !== undefined && bestFitness !== Infinity) {
        document.getElementById('best-fitness').textContent = bestFitness.toFixed(4);
    }
    
    // Update chart
    fitnessChartData.push({x: current, y: bestFitness});
    updateFitnessChart();
}

function updateFitnessChart() {
    const canvas = document.getElementById('fitness-chart');
    const ctx = canvas.getContext('2d');
    
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    if (fitnessChartData.length === 0) return;
    
    // Find min/max for scaling
    const minFitness = Math.min(...fitnessChartData.map(d => d.y));
    const maxFitness = Math.max(...fitnessChartData.map(d => d.y));
    const maxIteration = Math.max(...fitnessChartData.map(d => d.x));
    
    const padding = 40;
    const width = canvas.width - 2 * padding;
    const height = canvas.height - 2 * padding;
    
    // Draw axes
    ctx.strokeStyle = '#61dafb';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(padding, padding);
    ctx.lineTo(padding, canvas.height - padding);
    ctx.lineTo(canvas.width - padding, canvas.height - padding);
    ctx.stroke();
    
    // Draw labels
    ctx.fillStyle = '#ffffff';
    ctx.font = '12px Arial';
    ctx.fillText('Fitness', 5, padding);
    ctx.fillText('Iteracja', canvas.width - padding, canvas.height - padding + 20);
    
    // Draw data
    ctx.strokeStyle = '#a2f279';
    ctx.lineWidth = 2;
    ctx.beginPath();
    
    fitnessChartData.forEach((point, i) => {
        const x = padding + (point.x / maxIteration) * width;
        const y = canvas.height - padding - ((point.y - minFitness) / (maxFitness - minFitness + 0.0001)) * height;
        
        if (i === 0) {
            ctx.moveTo(x, y);
        } else {
            ctx.lineTo(x, y);
        }
    });
    ctx.stroke();
    
    // Draw points
    ctx.fillStyle = '#a2f279';
    fitnessChartData.forEach(point => {
        const x = padding + (point.x / maxIteration) * width;
        const y = canvas.height - padding - ((point.y - minFitness) / (maxFitness - minFitness + 0.0001)) * height;
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, 2 * Math.PI);
        ctx.fill();
    });
}

function addTestToResultsTable(testNum, params, fitness, itae, overshoot) {
    const tbody = document.getElementById('results-table-body');
    // Zapis do historii globalnej
    try {
        if (Array.isArray(tuningHistory)) {
            tuningHistory.push({ idx: testNum, kp: params.kp, ki: params.ki, kd: params.kd, fitness, itae, overshoot });
            refreshRecentList();
        }
    } catch(_) {}
    const row = tbody.insertRow(0); // Insert at top
    
    row.innerHTML = `
        <td>${testNum}</td>
        <td>${params.kp.toFixed(3)}</td>
        <td>${params.ki.toFixed(3)}</td>
        <td>${params.kd.toFixed(3)}</td>
        <td>${fitness.toFixed(4)}</td>
        <td>${itae.toFixed(2)}</td>
        <td>${overshoot.toFixed(2)}%</td>
        <td><button onclick="applyParameters(${params.kp}, ${params.ki}, ${params.kd})" class="btn-small">Zastosuj</button></td>
    `;
    
    // Tabela jest widoczna w modalu historii ‚Äì brak odwo≈Çania do nieistniejƒÖcego #results-container
}

function applyParameters(kp, ki, kd) {
    const loop = document.getElementById('tuning-loop-selector').value;
    let prefix = '';
    if (loop === 'balance') prefix = 'kp_b';
    else if (loop === 'speed') prefix = 'kp_s';
    else if (loop === 'position') prefix = 'kp_p';
    
    // Send parameters to robot
    sendBleCommand('set_param', {key: prefix.replace('kp', 'kp'), value: kp});
    sendBleCommand('set_param', {key: prefix.replace('kp', 'ki'), value: ki});
    sendBleCommand('set_param', {key: prefix.replace('kp', 'kd'), value: kd});
    
    showNotification(`Zastosowano parametry: Kp=${kp.toFixed(3)}, Ki=${ki.toFixed(3)}, Kd=${kd.toFixed(3)}`);
}

// ========================================================================
// GENETIC ALGORITHM
// ========================================================================

class GeneticAlgorithm {
    constructor(config) {
        this.populationSize = config.populationSize || 20;
        this.generations = config.generations || 30;
        this.mutationRate = config.mutationRate || 0.1;
        this.crossoverRate = config.crossoverRate || 0.7;
        this.elitism = config.elitism !== false;
        this.searchSpace = config.searchSpace;
        
        this.population = [];
        this.generation = 0;
        this.bestIndividual = null;
        this.isRunning = false;
        this.isPaused = false;
        this.testCounter = 0;
    }
    
    initialize() {
        this.population = [];
        for (let i = 0; i < this.populationSize; i++) {
            this.population.push(this.createRandomIndividual());
        }
        this.generation = 0;
        this.testCounter = 0;
        fitnessChartData = [];
    }
    
    createRandomIndividual() {
        return {
            kp: Math.random() * (this.searchSpace.kp_max - this.searchSpace.kp_min) + this.searchSpace.kp_min,
            ki: Math.random() * (this.searchSpace.ki_max - this.searchSpace.ki_min) + this.searchSpace.ki_min,
            kd: Math.random() * (this.searchSpace.kd_max - this.searchSpace.kd_min) + this.searchSpace.kd_min,
            fitness: Infinity
        };
    }
    
    async evaluateFitness(individual) {
        const testId = Date.now();
        this.testCounter++;
        
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                reject(new Error('Test timeout'));
            }, 10000); // 10 second timeout
            
            const handler = (data) => {
                if (data.type === 'test_result' && data.testId === testId) {
                    clearTimeout(timeout);
                    const fitness = data.itae + data.overshoot * 10 + data.steady_state_error * 5;
                    individual.fitness = fitness;
                    
                    addTestToResultsTable(this.testCounter, individual, fitness, data.itae, data.overshoot);
                    
                    // Remove handler
                    window.removeEventListener('ble_message', handler);
                    resolve(fitness);
                }
            };
            
            window.addEventListener('ble_message', handler);
            
            sendBleCommand('run_dynamic_test', {
                kp: individual.kp,
                ki: individual.ki,
                kd: individual.kd,
                testId: testId
            });
        });
    }
    
    async runGeneration() {
        // Evaluate all individuals
        for (let i = 0; i < this.population.length; i++) {
            if (this.isPaused) {
                await delay(100);
                i--; // Repeat this iteration
                continue;
            }
            
            if (!this.isRunning) break;
            
            if (this.population[i].fitness === Infinity) {
                try {
                    await this.evaluateFitness(this.population[i]);
                } catch (error) {
                    console.error('Test failed:', error);
                    this.population[i].fitness = Infinity;
                }
            }
        }
        
        // Sort by fitness
        this.population.sort((a, b) => a.fitness - b.fitness);
        
        // Update best
        if (!this.bestIndividual || this.population[0].fitness < this.bestIndividual.fitness) {
            this.bestIndividual = {...this.population[0]};
            updateBestDisplay(this.bestIndividual);
        }
        
        // Create new population
        const newPopulation = [];
        
        // Elitism
        if (this.elitism) {
            newPopulation.push({...this.population[0]});
        }
        
        // Selection, crossover, mutation
        while (newPopulation.length < this.populationSize) {
            const parent1 = this.tournamentSelection();
            const parent2 = this.tournamentSelection();
            
            let offspring;
            if (Math.random() < this.crossoverRate) {
                offspring = this.crossover(parent1, parent2);
            } else {
                offspring = {...parent1};
            }
            
            offspring = this.mutate(offspring);
            offspring.fitness = Infinity;
            newPopulation.push(offspring);
        }
        
        this.population = newPopulation;
        this.generation++;
        
        updateProgressDisplay(this.generation, this.generations, this.bestIndividual.fitness);
    }
    
    tournamentSelection() {
        const tournamentSize = 3;
        let best = null;
        
        for (let i = 0; i < tournamentSize; i++) {
            const candidate = this.population[Math.floor(Math.random() * this.population.length)];
            if (!best || candidate.fitness < best.fitness) {
                best = candidate;
            }
        }
        
        return best;
    }
    
    crossover(parent1, parent2) {
        const alpha = Math.random();
        return {
            kp: alpha * parent1.kp + (1 - alpha) * parent2.kp,
            ki: alpha * parent1.ki + (1 - alpha) * parent2.ki,
            kd: alpha * parent1.kd + (1 - alpha) * parent2.kd,
            fitness: Infinity
        };
    }
    
    mutate(individual) {
        const mutated = {...individual};
        
        if (Math.random() < this.mutationRate) {
            mutated.kp += (Math.random() - 0.5) * (this.searchSpace.kp_max - this.searchSpace.kp_min) * 0.1;
            mutated.kp = Math.max(this.searchSpace.kp_min, Math.min(this.searchSpace.kp_max, mutated.kp));
        }
        
        if (Math.random() < this.mutationRate) {
            mutated.ki += (Math.random() - 0.5) * (this.searchSpace.ki_max - this.searchSpace.ki_min) * 0.1;
            mutated.ki = Math.max(this.searchSpace.ki_min, Math.min(this.searchSpace.ki_max, mutated.ki));
        }
        
        if (Math.random() < this.mutationRate) {
            mutated.kd += (Math.random() - 0.5) * (this.searchSpace.kd_max - this.searchSpace.kd_min) * 0.1;
            mutated.kd = Math.max(this.searchSpace.kd_min, Math.min(this.searchSpace.kd_max, mutated.kd));
        }
        
        return mutated;
    }
    
    async run() {
        this.isRunning = true;
        this.initialize();
        
        document.getElementById('tuning-progress').style.display = 'block';
        
        while (this.generation < this.generations && this.isRunning) {
            if (!this.isPaused) {
                await this.runGeneration();
            } else {
                await delay(100);
            }
        }
        
        this.isRunning = false;
        showNotification(`Optymalizacja GA zako≈Ñczona! Najlepsze fitness: ${this.bestIndividual.fitness.toFixed(4)}`);
    }
    
    pause() { this.isPaused = true; }
    resume() { this.isPaused = false; }
    stop() { this.isRunning = false; }
}

// ========================================================================
// PSO ALGORITHM
// ========================================================================

class ParticleSwarmOptimization {
    constructor(config) {
        this.numParticles = config.numParticles || 20;
        this.iterations = config.iterations || 30;
        this.inertiaWeight = config.inertiaWeight || 0.7;
        this.cognitiveWeight = config.cognitiveWeight || 1.5;
        this.socialWeight = config.socialWeight || 1.5;
        this.searchSpace = config.searchSpace;
        
        this.particles = [];
        this.globalBest = null;
        this.iteration = 0;
        this.isRunning = false;
        this.isPaused = false;
        this.testCounter = 0;
    }
    
    initialize() {
        this.particles = [];
        for (let i = 0; i < this.numParticles; i++) {
            this.particles.push(this.createRandomParticle());
        }
        this.globalBest = null;
        this.iteration = 0;
        this.testCounter = 0;
        fitnessChartData = [];
    }
    
    createRandomParticle() {
        const position = {
            kp: Math.random() * (this.searchSpace.kp_max - this.searchSpace.kp_min) + this.searchSpace.kp_min,
            ki: Math.random() * (this.searchSpace.ki_max - this.searchSpace.ki_min) + this.searchSpace.ki_min,
            kd: Math.random() * (this.searchSpace.kd_max - this.searchSpace.kd_min) + this.searchSpace.kd_min
        };
        
        return {
            position: position,
            velocity: {kp: 0, ki: 0, kd: 0},
            bestPosition: {...position},
            bestFitness: Infinity,
            fitness: Infinity
        };
    }
    
    async evaluateFitness(particle) {
        const testId = Date.now();
        this.testCounter++;
        
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                reject(new Error('Test timeout'));
            }, 10000);
            
            const handler = (data) => {
                if (data.type === 'test_result' && data.testId === testId) {
                    clearTimeout(timeout);
                    const fitness = data.itae + data.overshoot * 10 + data.steady_state_error * 5;
                    particle.fitness = fitness;
                    
                    if (fitness < particle.bestFitness) {
                        particle.bestFitness = fitness;
                        particle.bestPosition = {...particle.position};
                    }
                    
                    if (!this.globalBest || fitness < this.globalBest.fitness) {
                        this.globalBest = {
                            position: {...particle.position},
                            fitness: fitness
                        };
                        updateBestDisplay(this.globalBest.position);
                    }
                    
                    addTestToResultsTable(this.testCounter, particle.position, fitness, data.itae, data.overshoot);
                    
                    window.removeEventListener('ble_message', handler);
                    resolve(fitness);
                }
            };
            
            window.addEventListener('ble_message', handler);
            
            sendBleCommand('run_dynamic_test', {
                kp: particle.position.kp,
                ki: particle.position.ki,
                kd: particle.position.kd,
                testId: testId
            });
        });
    }
    
    async runIteration() {
        // Evaluate all particles
        for (let i = 0; i < this.particles.length; i++) {
            if (this.isPaused) {
                await delay(100);
                i--;
                continue;
            }
            
            if (!this.isRunning) break;
            
            try {
                await this.evaluateFitness(this.particles[i]);
            } catch (error) {
                console.error('Test failed:', error);
                this.particles[i].fitness = Infinity;
            }
        }
        
        // Update velocities and positions
        for (let particle of this.particles) {
            this.updateVelocity(particle);
            this.updatePosition(particle);
        }
        
        this.iteration++;
        updateProgressDisplay(this.iteration, this.iterations, this.globalBest ? this.globalBest.fitness : Infinity);
    }
    
    updateVelocity(particle) {
        const r1 = Math.random();
        const r2 = Math.random();
        
        for (let dim of ['kp', 'ki', 'kd']) {
            const cognitive = this.cognitiveWeight * r1 * (particle.bestPosition[dim] - particle.position[dim]);
            const social = this.socialWeight * r2 * (this.globalBest.position[dim] - particle.position[dim]);
            particle.velocity[dim] = this.inertiaWeight * particle.velocity[dim] + cognitive + social;
            
            // Velocity clamping
            const maxVel = (this.searchSpace[dim + '_max'] - this.searchSpace[dim + '_min']) * 0.2;
            particle.velocity[dim] = Math.max(-maxVel, Math.min(maxVel, particle.velocity[dim]));
        }
    }
    
    updatePosition(particle) {
        for (let dim of ['kp', 'ki', 'kd']) {
            particle.position[dim] += particle.velocity[dim];
            // Clamp to search space
            particle.position[dim] = Math.max(this.searchSpace[dim + '_min'], 
                                             Math.min(this.searchSpace[dim + '_max'], 
                                                     particle.position[dim]));
        }
    }
    
    async run() {
        this.isRunning = true;
        this.initialize();
        
        document.getElementById('tuning-progress').style.display = 'block';
        
        while (this.iteration < this.iterations && this.isRunning) {
            if (!this.isPaused) {
                await this.runIteration();
            } else {
                await delay(100);
            }
        }
        
        this.isRunning = false;
        showNotification(`Optymalizacja PSO zako≈Ñczona! Najlepsze fitness: ${this.globalBest.fitness.toFixed(4)}`);
    }
    
    pause() { this.isPaused = true; }
    resume() { this.isPaused = false; }
    stop() { this.isRunning = false; }
}

// ========================================================================
// ZIEGLER-NICHOLS RELAY METHOD
// ========================================================================

class ZieglerNicholsRelay {
    constructor(config) {
        this.amplitude = config.amplitude || 2.0;
        this.minCycles = config.minCycles || 3;
        this.isRunning = false;
        
        this.oscillationData = [];
        this.peaks = [];
        this.valleys = [];
    }
    
    async run() {
        this.isRunning = true;
        const testId = Date.now();
        
        this.oscillationData = [];
        this.peaks = [];
        this.valleys = [];
        
        document.getElementById('zn-oscillation-display').style.display = 'block';
        
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                reject(new Error('ZN test timeout'));
            }, 30000); // 30 second timeout
            
            const handler = (data) => {
                if (data.type === 'relay_state' && data.testId === testId) {
                    this.oscillationData.push({
                        time: data.time,
                        angle: data.angle,
                        relayOutput: data.relay_output
                    });
                    
                    this.detectPeaksValleys();
                    this.updateRelayChart();
                    
                    document.getElementById('zn-detected-cycles').textContent = 
                        Math.min(this.peaks.length, this.valleys.length);
                    
                    // Check if we have enough cycles
                    if (this.peaks.length >= this.minCycles && this.valleys.length >= this.minCycles) {
                        clearTimeout(timeout);
                        window.removeEventListener('ble_message', handler);
                        
                        const results = this.calculateZNParameters();
                        this.displayResults(results);
                        resolve(results);
                    }
                } else if (data.type === 'test_complete' && data.testId === testId) {
                    clearTimeout(timeout);
                    window.removeEventListener('ble_message', handler);
                    
                    if (this.peaks.length >= this.minCycles && this.valleys.length >= this.minCycles) {
                        const results = this.calculateZNParameters();
                        this.displayResults(results);
                        resolve(results);
                    } else {
                        reject(new Error('Not enough oscillation cycles detected'));
                    }
                }
            };
            
            window.addEventListener('ble_message', handler);
            
            sendBleCommand('run_relay_test', {
                amplitude: this.amplitude,
                testId: testId
            });
        });
    }
    
    detectPeaksValleys() {
        const data = this.oscillationData;
        const n = data.length;
        if (n < 3) return;
        
        const last = data[n-1];
        const prev = data[n-2];
        const prevPrev = data[n-3];
        
        // Peak detected
        if (prev.angle > prevPrev.angle && prev.angle > last.angle) {
            if (this.peaks.length === 0 || prev.time - this.peaks[this.peaks.length - 1].time > 0.1) {
                this.peaks.push({time: prev.time, value: prev.angle});
            }
        }
        
        // Valley detected
        if (prev.angle < prevPrev.angle && prev.angle < last.angle) {
            if (this.valleys.length === 0 || prev.time - this.valleys[this.valleys.length - 1].time > 0.1) {
                this.valleys.push({time: prev.time, value: prev.angle});
            }
        }
    }
    
    calculateZNParameters() {
        const peakValues = this.peaks.slice(-this.minCycles).map(p => p.value);
        const valleyValues = this.valleys.slice(-this.minCycles).map(v => v.value);
        
        const avgAmplitude = (mean(peakValues) - mean(valleyValues)) / 2;
        const ku = (4 * this.amplitude) / (Math.PI * avgAmplitude);
        
        // Calculate period
        const periods = [];
        for (let i = 1; i < this.peaks.length; i++) {
            periods.push(this.peaks[i].time - this.peaks[i-1].time);
        }
        const tu = mean(periods);
        
        // Apply Z-N tuning rules
        return {
            ku: ku,
            tu: tu,
            kp: 0.6 * ku,
            ki: 1.2 * ku / tu,
            kd: 0.075 * ku * tu
        };
    }
    
    displayResults(results) {
        updateBestDisplay({kp: results.kp, ki: results.ki, kd: results.kd, fitness: 0});
        showNotification(`ZN: Ku=${results.ku.toFixed(3)}, Tu=${results.tu.toFixed(3)}s`);
    }
    
    updateRelayChart() {
        const canvas = document.getElementById('zn-oscillation-chart');
        const ctx = canvas.getContext('2d');
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        if (this.oscillationData.length === 0) return;
        
        const times = this.oscillationData.map(d => d.time);
        const angles = this.oscillationData.map(d => d.angle);
        
        const minTime = Math.min(...times);
        const maxTime = Math.max(...times);
        const minAngle = Math.min(...angles);
        const maxAngle = Math.max(...angles);
        
        const padding = 30;
        const width = canvas.width - 2 * padding;
        const height = canvas.height - 2 * padding;
        
        // Draw axes
        ctx.strokeStyle = '#61dafb';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(padding, padding);
        ctx.lineTo(padding, canvas.height - padding);
        ctx.lineTo(canvas.width - padding, canvas.height - padding);
        ctx.stroke();
        
        // Draw oscillation
        ctx.strokeStyle = '#a2f279';
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        this.oscillationData.forEach((point, i) => {
            const x = padding + ((point.time - minTime) / (maxTime - minTime + 0.001)) * width;
            const y = canvas.height - padding - ((point.angle - minAngle) / (maxAngle - minAngle + 0.001)) * height;
            
            if (i === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        });
        ctx.stroke();
        
        // Mark peaks and valleys
        ctx.fillStyle = '#ff6b6b';
        this.peaks.forEach(peak => {
            const x = padding + ((peak.time - minTime) / (maxTime - minTime + 0.001)) * width;
            const y = canvas.height - padding - ((peak.value - minAngle) / (maxAngle - minAngle + 0.001)) * height;
            ctx.beginPath();
            ctx.arc(x, y, 4, 0, 2 * Math.PI);
            ctx.fill();
        });
        
        ctx.fillStyle = '#4ecdc4';
        this.valleys.forEach(valley => {
            const x = padding + ((valley.time - minTime) / (maxTime - minTime + 0.001)) * width;
            const y = canvas.height - padding - ((valley.value - minAngle) / (maxAngle - minAngle + 0.001)) * height;
            ctx.beginPath();
            ctx.arc(x, y, 4, 0, 2 * Math.PI);
            ctx.fill();
        });
    }
    
    stop() {
        this.isRunning = false;
        sendBleCommand('cancel_test', {});
    }
}


// ========================================================================
// BAYESIAN OPTIMIZATION
// ========================================================================

class BayesianOptimization {
    constructor(config) {
        this.iterations = config.iterations || 25;
        this.initialSamples = config.initialSamples || 5;
        this.searchSpace = config.searchSpace;
        this.acquisitionFunction = config.acquisitionFunction || 'ei'; // ei, ucb, pi
        this.xi = config.xi || 0.01; // exploration parameter
        
        this.samples = [];
        this.iteration = 0;
        this.isRunning = false;
        this.neuralNetwork = null;
        this.testCounter = 0;
    }
    
    async initialize() {
        this.samples = [];
        this.iteration = 0;
        this.testCounter = 0;
        fitnessChartData = [];
        
        // Collect initial random samples
        for (let i = 0; i < this.initialSamples; i++) {
            const sample = this.sampleRandom();
            try {
                const fitness = await this.evaluateSample(sample);
                this.samples.push({...sample, fitness});
            } catch (error) {
                console.error('Initial sample failed:', error);
                this.samples.push({...sample, fitness: Infinity});
            }
        }
        
        // Train initial surrogate model
        await this.trainSurrogate();
        
        // Show visualization
        document.getElementById('bayesian-visualization').style.display = 'block';
        this.updateVisualization();
    }
    
    async trainSurrogate() {
        // Use ml5.js neural network as surrogate for Gaussian Process
        // In a real implementation, you'd use a proper GP library
        
        if (!this.neuralNetwork) {
            this.neuralNetwork = ml5.neuralNetwork({
                inputs: 3,
                outputs: 1,
                task: 'regression',
                layers: [
                    { type: 'dense', units: 32, activation: 'relu' },
                    { type: 'dense', units: 16, activation: 'relu' }
                ]
            });
        }
        
        // Clear previous data
        this.neuralNetwork.data.data.raw = [];
        
        // Add training data (filter out failed samples)
        const validSamples = this.samples.filter(s => s.fitness !== Infinity);
        validSamples.forEach(sample => {
            this.neuralNetwork.addData(
                {kp: sample.kp, ki: sample.ki, kd: sample.kd},
                {fitness: sample.fitness}
            );
        });
        
        if (validSamples.length < 2) {
            console.warn('Not enough valid samples to train surrogate');
            return;
        }
        
        await this.neuralNetwork.normalizeData();
        
        // Train with fewer epochs for faster iteration
        const trainingOptions = {
            epochs: 30,
            batchSize: Math.min(8, validSamples.length),
            validationSplit: 0.1
        };
        
        await this.neuralNetwork.train(trainingOptions);
    }
    
    async acquireNext() {
        // Use acquisition function to select next sample point
        let bestAcquisition = -Infinity;
        let bestSample = null;
        
        // Grid search over search space (coarse grid for speed)
        const gridSize = 8; // 8^3 = 512 points
        
        for (let i = 0; i < gridSize; i++) {
            for (let j = 0; j < gridSize; j++) {
                for (let k = 0; k < gridSize; k++) {
                    const kp = this.searchSpace.kp_min + (i / (gridSize - 1)) * (this.searchSpace.kp_max - this.searchSpace.kp_min);
                    const ki = this.searchSpace.ki_min + (j / (gridSize - 1)) * (this.searchSpace.ki_max - this.searchSpace.ki_min);
                    const kd = this.searchSpace.kd_min + (k / (gridSize - 1)) * (this.searchSpace.kd_max - this.searchSpace.kd_min);
                    
                    const acquisition = await this.calculateAcquisition({kp, ki, kd});
                    if (acquisition > bestAcquisition) {
                        bestAcquisition = acquisition;
                        bestSample = {kp, ki, kd};
                    }
                }
            }
        }
        
        return bestSample;
    }
    
    async calculateAcquisition(sample) {
        // Predict mean using neural network
        const prediction = await this.neuralNetwork.predict({kp: sample.kp, ki: sample.ki, kd: sample.kd});
        const predictedFitness = prediction[0].fitness;
        
        // Find current best
        const validSamples = this.samples.filter(s => s.fitness !== Infinity);
        if (validSamples.length === 0) return 0;
        
        const currentBest = Math.min(...validSamples.map(s => s.fitness));
        
        // Calculate acquisition based on selected function
        if (this.acquisitionFunction === 'ei') {
            // Expected Improvement (simplified without proper GP uncertainty)
            const improvement = currentBest - predictedFitness;
            return Math.max(0, improvement + this.xi);
        } else if (this.acquisitionFunction === 'ucb') {
            // Upper Confidence Bound (simplified)
            // In real GP, we'd have proper uncertainty estimates
            const uncertainty = 1.0; // Placeholder - would come from GP
            return -predictedFitness + 2.0 * uncertainty;
        } else if (this.acquisitionFunction === 'pi') {
            // Probability of Improvement (simplified)
            const improvement = currentBest - predictedFitness;
            return improvement > 0 ? 1 : 0;
        }
        
        return -predictedFitness;
    }
    
    async evaluateSample(sample) {
        const testId = Date.now();
        this.testCounter++;
        
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                reject(new Error('Test timeout'));
            }, 10000);
            
            const handler = (data) => {
                if (data.type === 'test_result' && data.testId === testId) {
                    clearTimeout(timeout);
                    const fitness = data.itae + data.overshoot * 10 + data.steady_state_error * 5;
                    
                    addTestToResultsTable(this.testCounter, sample, fitness, data.itae, data.overshoot);
                    
                    window.removeEventListener('ble_message', handler);
                    resolve(fitness);
                }
            };
            
            window.addEventListener('ble_message', handler);
            
            sendBleCommand('run_dynamic_test', {
                kp: sample.kp,
                ki: sample.ki,
                kd: sample.kd,
                testId: testId
            });
        });
    }
    
    sampleRandom() {
        return {
            kp: Math.random() * (this.searchSpace.kp_max - this.searchSpace.kp_min) + this.searchSpace.kp_min,
            ki: Math.random() * (this.searchSpace.ki_max - this.searchSpace.ki_min) + this.searchSpace.ki_min,
            kd: Math.random() * (this.searchSpace.kd_max - this.searchSpace.kd_min) + this.searchSpace.kd_min
        };
    }
    
    updateVisualization() {
        const canvas = document.getElementById('bayesian-space-chart');
        const ctx = canvas.getContext('2d');
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        if (this.samples.length === 0) return;
        
        // For visualization, we'll plot Kp vs Kd (most important dimensions)
        const padding = 40;
        const width = canvas.width - 2 * padding;
        const height = canvas.height - 2 * padding;
        
        // Draw axes
        ctx.strokeStyle = '#61dafb';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(padding, padding);
        ctx.lineTo(padding, canvas.height - padding);
        ctx.lineTo(canvas.width - padding, canvas.height - padding);
        ctx.stroke();
        
        // Labels
        ctx.fillStyle = '#ffffff';
        ctx.font = '12px Arial';
        ctx.fillText('Kp', canvas.width - padding + 5, canvas.height - padding + 5);
        ctx.fillText('Kd', padding - 30, padding);
        
        // Find best sample
        const validSamples = this.samples.filter(s => s.fitness !== Infinity);
        const bestSample = validSamples.length > 0 ? 
                          validSamples.reduce((a, b) => a.fitness < b.fitness ? a : b) : null;
        
        // Plot all samples
        this.samples.forEach(sample => {
            if (sample.fitness === Infinity) return;
            
            const x = padding + ((sample.kp - this.searchSpace.kp_min) / (this.searchSpace.kp_max - this.searchSpace.kp_min)) * width;
            const y = canvas.height - padding - ((sample.kd - this.searchSpace.kd_min) / (this.searchSpace.kd_max - this.searchSpace.kd_min)) * height;
            
            // Color based on fitness (gradient from red=bad to blue=good)
            const minFitness = Math.min(...validSamples.map(s => s.fitness));
            const maxFitness = Math.max(...validSamples.map(s => s.fitness));
            const normalized = (sample.fitness - minFitness) / (maxFitness - minFitness + 0.001);
            const hue = (1 - normalized) * 240; // 240=blue (good), 0=red (bad)
            
            ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, 2 * Math.PI);
            ctx.fill();
        });
        
        // Highlight best sample
        if (bestSample) {
            const x = padding + ((bestSample.kp - this.searchSpace.kp_min) / (this.searchSpace.kp_max - this.searchSpace.kp_min)) * width;
            const y = canvas.height - padding - ((bestSample.kd - this.searchSpace.kd_min) / (this.searchSpace.kd_max - this.searchSpace.kd_min)) * height;
            
            ctx.strokeStyle = '#a2f279';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(x, y, 8, 0, 2 * Math.PI);
            ctx.stroke();
        }
    }
    
    async run() {
        this.isRunning = true;
        
        document.getElementById('tuning-progress').style.display = 'block';
        showNotification('Inicjalizacja Bayesian Optimization...');
        
        await this.initialize();
        
        while (this.iteration < this.iterations && this.isRunning) {
            // 1. Select next sample using acquisition function
            const nextSample = await this.acquireNext();
            
            if (!nextSample) {
                console.error('Failed to acquire next sample');
                break;
            }
            
            // 2. Evaluate it
            try {
                const fitness = await this.evaluateSample(nextSample);
                this.samples.push({...nextSample, fitness});
            } catch (error) {
                console.error('Sample evaluation failed:', error);
                this.samples.push({...nextSample, fitness: Infinity});
            }
            
            // 3. Update surrogate model
            await this.trainSurrogate();
            
            // 4. Update visualization and display
            const validSamples = this.samples.filter(s => s.fitness !== Infinity);
            const best = validSamples.length > 0 ? 
                        validSamples.reduce((a, b) => a.fitness < b.fitness ? a : b) : null;
            
            if (best) {
                updateBestDisplay(best);
                updateProgressDisplay(this.iteration + 1, this.iterations, best.fitness);
            }
            
            this.updateVisualization();
            
            this.iteration++;
        }
        
        this.isRunning = false;
        
        const validSamples = this.samples.filter(s => s.fitness !== Infinity);
        const best = validSamples.length > 0 ? 
                    validSamples.reduce((a, b) => a.fitness < b.fitness ? a : b) : null;
        
        if (best) {
            showNotification(`Bayesian Optimization zako≈Ñczona! Najlepsze fitness: ${best.fitness.toFixed(4)}`);
        } else {
            showNotification('Bayesian Optimization zako≈Ñczona - brak udanych test√≥w');
        }
    }
    
    stop() { 
        this.isRunning = false; 
    }
}
// ========================================================================
// UI EVENT HANDLERS
// ========================================================================

function initAutoTuningUI() {
    // Zak≈Çadki ju≈º obs≈Çugiwane przez setupAutotuningTabs()+activateMethodTab
    // Upewnij siƒô ≈ºe domy≈õlnie aktywna karta jest poprawnie ustawiona
    const initial = document.querySelector('.method-tab.active')?.dataset.method || 'ga';
    activateMethodTab(initial);
}

// Initialize when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', ()=>{ initAutoTuningUI(); setupMainAutotuneTabs(); });
} else {
    initAutoTuningUI();
    setupMainAutotuneTabs();
}

// Listen for BLE messages
window.addEventListener('message', function(event) {
    if (event.data && event.data.type) {
        // Dispatch custom event for algorithm handlers
        const bleEvent = new CustomEvent('ble_message', { detail: event.data });
        window.dispatchEvent(bleEvent);
    }
});

// ML accordion helpers: bridge to Bayesian tab
document.addEventListener('DOMContentLoaded', () => {
    const openBtn = document.getElementById('ml-open-bayesian');
    if (openBtn) openBtn.addEventListener('click', () => {
        activateMethodTab('bayesian');
        document.querySelector('#autotuning-card-content')?.scrollIntoView({behavior:'smooth'});
    });
    const startBtn = document.getElementById('ml-start-bayesian');
    if (startBtn) startBtn.addEventListener('click', () => {
        activateMethodTab('bayesian');
        document.getElementById('start-tuning-btn')?.click();
    });
});

// ========================================================================
// UI EVENT HANDLERS & SESSION MANAGEMENT (Client-Side Logic)
// ========================================================================

let currentTuningSession = null;

function startTuning() {
    if (!checkTuningPrerequisites()) return;

    const method = document.querySelector('.method-tab.active')?.dataset.method;
    if (!method) {
        addLogMessage('[UI] Nie wybrano metody optymalizacji.', 'warn');
        return;
    }

    const searchSpace = {
        kp_min: parseFloat(document.getElementById('search-kp-min')?.value || 0),
        kp_max: parseFloat(document.getElementById('search-kp-max')?.value || 50),
        ki_min: parseFloat(document.getElementById('search-ki-min')?.value || 0),
        ki_max: parseFloat(document.getElementById('search-ki-max')?.value || 1),
        kd_min: parseFloat(document.getElementById('search-kd-min')?.value || 0),
        kd_max: parseFloat(document.getElementById('search-kd-max')?.value || 5)
    };
    
    setTuningUiLock(true, method);
    document.getElementById('tuning-status-text').textContent = 'Uruchamianie...';
    document.getElementById('current-iteration').textContent = '0';
    fitnessChartData = [];
    updateFitnessChart();
    document.getElementById('start-tuning-btn').disabled = true;
    document.getElementById('pause-tuning-btn').disabled = false;
    document.getElementById('stop-tuning-btn').disabled = false;

    addLogMessage(`[UI] Rozpoczynam strojenie po stronie UI metodƒÖ: ${method.toUpperCase()}`, 'info');

    try {
        let config;
        if (method === 'ga') {
            config = {
                populationSize: parseInt(document.getElementById('ga-population').value),
                generations: parseInt(document.getElementById('ga-generations').value),
                mutationRate: parseFloat(document.getElementById('ga-mutation').value) / 100.0,
                crossoverRate: parseFloat(document.getElementById('ga-crossover').value) / 100.0,
                elitism: document.getElementById('ga-elitism').checked,
                searchSpace: searchSpace
            };
            currentTuningSession = new GeneticAlgorithm(config);
        } else if (method === 'pso') {
            config = {
                numParticles: parseInt(document.getElementById('pso-particles').value),
                iterations: parseInt(document.getElementById('pso-iterations').value),
                inertiaWeight: parseFloat(document.getElementById('pso-inertia').value),
                cognitiveWeight: parseFloat(document.getElementById('pso-cognitive').value),
                socialWeight: parseFloat(document.getElementById('pso-social').value),
                searchSpace: searchSpace
            };
            currentTuningSession = new ParticleSwarmOptimization(config);
        } else if (method === 'zn') {
            config = {
                amplitude: parseFloat(document.getElementById('zn-amplitude').value),
                minCycles: parseInt(document.getElementById('zn-min-cycles').value)
            };
            currentTuningSession = new ZieglerNicholsRelay(config);
        } else if (method === 'bayesian') {
             config = {
                iterations: parseInt(document.getElementById('bayesian-iterations').value),
                initialSamples: parseInt(document.getElementById('bayesian-initial').value),
                acquisitionFunction: document.getElementById('bayesian-acquisition').value,
                xi: parseFloat(document.getElementById('bayesian-xi').value),
                searchSpace: searchSpace
            };
            currentTuningSession = new BayesianOptimization(config);
        } else {
             throw new Error(`Nieznana metoda: ${method}`);
        }
        
        currentTuningSession.run().finally(() => {
            stopTuning(false); 
        });

    } catch (error) {
        console.error('B≈ÇƒÖd inicjalizacji strojenia:', error);
        addLogMessage('B≈ÇƒÖd inicjalizacji strojenia: ' + error.message, 'error');
        stopTuning(false);
    }
}

function pauseTuning() {
    if (currentTuningSession && typeof currentTuningSession.pause === 'function') {
        currentTuningSession.pause();
        document.getElementById('tuning-status-text').textContent = 'Wstrzymany';
        addLogMessage('[UI] Strojenie wstrzymane.', 'info');
        document.getElementById('pause-tuning-btn').style.display = 'none';
        document.getElementById('resume-tuning-btn').style.display = 'inline-block';
        document.getElementById('resume-tuning-btn').disabled = false;
    }
}

function resumeTuning() {
    if (currentTuningSession && typeof currentTuningSession.resume === 'function') {
        currentTuningSession.resume();
        document.getElementById('tuning-status-text').textContent = 'W trakcie';
        addLogMessage('[UI] Strojenie wznowione.', 'info');
        document.getElementById('resume-tuning-btn').style.display = 'none';
        document.getElementById('pause-tuning-btn').style.display = 'inline-block';
        document.getElementById('pause-tuning-btn').disabled = false;
    }
}

function stopTuning(showPrompt = true) {
    if (showPrompt && !confirm('Czy na pewno chcesz zatrzymaƒá proces strojenia?')) {
        return;
    }
    if (currentTuningSession && typeof currentTuningSession.stop === 'function') {
        currentTuningSession.stop();
    }
    currentTuningSession = null;
    setTuningUiLock(false, '');
    document.getElementById('tuning-status-text').textContent = 'Zatrzymany';
    addLogMessage('[UI] Strojenie zatrzymane.', 'warn');
    
    document.getElementById('start-tuning-btn').disabled = false;
    document.getElementById('pause-tuning-btn').disabled = true;
    document.getElementById('stop-tuning-btn').disabled = true;
    document.getElementById('resume-tuning-btn').style.display = 'none';
    document.getElementById('pause-tuning-btn').style.display = 'inline-block';
}

document.addEventListener('DOMContentLoaded', () => {
    const startBtn = document.getElementById('start-tuning-btn');
    const pauseBtn = document.getElementById('pause-tuning-btn');
    const resumeBtn = document.getElementById('resume-tuning-btn');
    const stopBtn = document.getElementById('stop-tuning-btn');
    
    if (startBtn) startBtn.addEventListener('click', startTuning);
    if (pauseBtn) pauseBtn.addEventListener('click', pauseTuning);
    if (resumeBtn) resumeBtn.addEventListener('click', resumeTuning);
    if (stopBtn) stopBtn.addEventListener('click', () => stopTuning(true));
});


</script>

</body>
</html>
