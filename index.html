<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Robot PID - Panel Sterowania v18.0 (Kalman Filter)</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <style>
        body { font-family: Arial, sans-serif; text-align: center; margin: 0; padding: 15px; background-color: #282c34; color: #fff; font-size: 14px; }
        h1 { color: #61dafb; font-size: 1.8em; }
        h2 { color: #61dafb; font-size: 1.4em; margin-top: 0; margin-bottom: 15px; }
        .main-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(340px, 1fr)); gap: 15px; align-items: start; max-width: 1920px; margin: auto; }
        .card { background-color: #3a3f47; border-radius: 8px; padding: 15px; box-shadow: 0 2px 6px rgba(0,0,0,0.2); }
        .info-grid, .status-grid { display: grid; grid-template-columns: auto 1fr; gap: 8px; text-align: left; font-size: 1em; margin-top: 10px; align-items: center;}
        .info-grid strong, .status-grid strong { color: #a2f279; }
        button { background-color: #61dafb; color: #282c34; border: none; padding: 8px 12px; border-radius: 5px; font-weight: bold; cursor: pointer; transition: background-color 0.3s, opacity 0.3s, box-shadow 0.2s; font-size: 0.9em; }
        button:hover { background-color: #a2f279; }
        button:disabled { background-color: #4a4f58; color: #888; cursor: not-allowed; opacity: 0.6; }
        .gamepad-flash { box-shadow: 0 0 10px 3px #a2f279 !important; }
        #emergencyStopBtn { background-color: #ff6347; color: white; width: 100%; margin-top: 15px; }
        .control-row { display: flex; align-items: center; justify-content: space-between; width: 100%; margin-top: 10px; }
        .control-label { font-size: 1.1em; font-weight: bold; }
        .switch { position: relative; display: inline-block; width: 50px; height: 28px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider.round { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ff6347; transition: .4s; border-radius: 28px; }
        .slider.round:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #a2f279; }
        input:checked + .slider:before { transform: translateX(22px); }
        input[type="checkbox"].slider-checkbox + .slider { background-color: #4a4f58; }
        input[type="checkbox"].slider-checkbox:checked + .slider { background-color: #a2f279; }
        input:disabled + .slider { background-color: #4a4f58; cursor: not-allowed; }
        fieldset { border: 1px solid #4a4f58; border-radius: 8px; margin-top: 15px; padding: 10px 15px; }
        legend { color: #61dafb; font-weight: bold; padding: 0 10px; font-size: 1.1em; }
        #joystickWrapper { position: relative; width: 180px; height: 180px; border-radius: 50%; background-color: #4a4f58; border: 3px solid #61dafb; margin: 15px auto; touch-action: none; }
        #joystickCanvas { width: 100%; height: 100%; display: block; }
        #chart-wrapper { position: relative; height: 320px; border-radius: 8px; overflow: hidden; background-color: #20232a; }
        #log-history { text-align: left; height: 350px; overflow-y: auto; background-color: #20232a; padding: 10px; border-radius: 8px; font-family: monospace; white-space: pre-wrap; }
        .status-indicator { width: 14px; height: 14px; border-radius: 50%; display: inline-block; }
        .status-ok { background-color: #a2f279; }
        .status-warn { background-color: #f7b731; }
        .status-error { background-color: #ff6347; }
        .status-disconnected { background-color: #888; }
        #emergency-banner { display: none; background-color: #ff6347; color: white; padding: 10px; font-weight: bold; position: fixed; top: 0; left: 0; width: 100%; z-index: 1000; }
        .angle-display { display: flex; align-items: center; justify-content: space-between; }
        .angle-indicator-wrapper { position: relative; width: 34px; height: 34px; background-color: #20232a; border-radius: 50%; border: 1px solid #61dafb; }
        .angle-indicator-needle { position: absolute; bottom: 50%; left: calc(50% - 1px); width: 2px; height: 50%; background-color: #ff6347; transform-origin: bottom center; transition: transform 0.1s linear; }
        .chart-controls { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin-top: 10px; font-size: 0.9em; }
        .chart-controls label { color: #fff; }
        .setting-container { display: grid; grid-template-columns: 1fr auto; gap: 10px; align-items: center; margin: 8px 0; }
        .setting-container label { font-size: 1em; font-weight: bold; color: #a2f279; text-align: left; }
        .numeric-input-wrapper { display: flex; align-items: center; flex-shrink: 0; }
        .numeric-input-wrapper button { background-color: #4a4f58; color: #61dafb; padding: 4px 8px; font-size: 1em; line-height: 1; min-width: 30px; }
        .numeric-input-wrapper input[type=number] { width: 90px; text-align: center; font-size: 1em; background-color: #20232a; color: #fff; border: 1px solid #61dafb; border-radius: 5px; margin: 0 4px; padding: 4px; -moz-appearance: textfield; }
        input[type=number]::-webkit-inner-spin-button, input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        .manual-tune-row { background-color: #2a2f35; padding: 10px; border-radius: 6px; margin-bottom: 12px; }
        .pwm-input-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .pwm-input-row label { font-weight: bold; color: #a2f279; }
        .pwm-button-row { display: flex; justify-content: flex-end; gap: 10px; }
        .pwm-button-row button { flex-grow: 1; max-width: 100px; }
        .test-btn { background-color: #a2f279; }
        .stop-btn { background-color: #ff6347; }
        .auto-btn { background-color: #f7b731; }
        .trim-controls { display: flex; justify-content: space-between; align-items: center; margin-top: 10px; }
        .trim-controls span { font-weight: bold; }
        .trim-controls button { min-width: 40px; font-size: 1.2em; }
        .accordion-header { background-color: #4a4f58; color: #61dafb; cursor: pointer; padding: 12px 15px; border: none; text-align: left; outline: none; font-size: 1.1em; font-weight: bold; width: 100%; border-radius: 8px; margin-top: 5px; transition: background-color 0.3s; position: relative; }
        .accordion-header:hover { background-color: #5a6068; }
        .accordion-header.active { background-color: #61dafb; color: #282c34; border-bottom-left-radius: 0; border-bottom-right-radius: 0;}
        .accordion-header::after { content: '+'; position: absolute; right: 15px; font-size: 1.4em; transition: transform 0.3s; }
        .accordion-header.active::after { content: '-'; }
        .accordion-content { max-height: 0; overflow: hidden; transition: max-height 0.4s ease-out, padding 0.2s ease-out; background-color: #3a3f47; border-bottom-left-radius: 8px; border-bottom-right-radius: 8px; padding: 0 15px; }
        .accordion-content.active { padding: 15px; }
        .pwm-info { background-color: #20232a; padding: 10px; border-radius: 5px; margin-bottom: 15px; border-left: 4px solid #61dafb; }
        .pwm-info strong { color: #a2f279; }
        .parameter-group { background-color: #20232a; padding: 12px; border-radius: 6px; margin-bottom: 12px; }
        .parameter-group h5 { color: #61dafb; margin: 0 0 8px 0; font-size: 1.1em; }
        .help-icon { display: inline-block; width: 16px; height: 16px; border-radius: 50%; background-color: #61dafb; color: #282c34; font-size: 12px; font-weight: bold; text-align: center; line-height: 16px; margin-left: 8px; cursor: pointer; user-select: none; }
        .help-text { background-color: #20232a; color: #fff; border-radius: 6px; padding: 10px; border: 1px solid #61dafb; margin-top: 8px; text-align: left; font-size: 0.9em; line-height: 1.4; width: 100%; box-sizing: border-box; max-height: 0; overflow: hidden; transition: max-height 0.3s ease-out, padding 0.3s ease-out; padding-top: 0; padding-bottom: 0; grid-column: 1 / -1; }
        .help-text.visible { max-height: 200px; padding-top: 10px; padding-bottom: 10px; }
        .modal-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); z-index: 2000; display: none; justify-content: center; align-items: center; }
        .modal-content { background-color: #3a3f47; padding: 20px; border-radius: 8px; width: 90%; max-width: 500px; box-shadow: 0 5px 15px rgba(0,0,0,0.5); }
        .mapping-row { display: grid; grid-template-columns: 1fr 100px 100px; gap: 10px; align-items: center; margin-bottom: 10px; }
        .mapping-label { text-align: left; font-weight: bold; }
        .mapping-button { font-size: 0.8em; padding: 6px 8px; }
        .mapping-display { background-color: #20232a; padding: 6px; border-radius: 4px; font-family: monospace; }
        .preset-actions { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px; }
        #applySelectedPresetBtn { background-color: #a2f279; }
        #saveCurrentAsPresetBtn { background-color: #61dafb; }
        #autotestStatusPanel { background-color: #20232a; padding: 12px; border-radius: 6px; }
        #autotestStatusPanel h5 { color: #61dafb; margin: 0 0 10px 0; font-size: 1.1em; text-align: left; }
        #statusProgressBar { width: 100%; -webkit-appearance: none; appearance: none; height: 8px; }
        #statusProgressBar::-webkit-progress-bar { background-color: #4a4f58; border-radius: 4px; }
        #statusProgressBar::-webkit-progress-value { background-color: #a2f279; border-radius: 4px; transition: width 0.3s ease; }
        .radio-selector-group { display: flex; flex-direction: column; gap: 8px; }
        .radio-selector-item input[type="radio"] { display: none; }
        .radio-selector-item label { display: block; padding: 10px; background-color: #4a4f58; color: #fff; border-radius: 5px; cursor: pointer; transition: background-color 0.3s, color 0.3s; text-align: left; padding-left: 35px; position: relative; }
        .radio-selector-item label::before { content: ''; position: absolute; left: 10px; top: 50%; transform: translateY(-50%); width: 18px; height: 18px; border: 2px solid #61dafb; border-radius: 50%; transition: border-color 0.3s; }
        .radio-selector-item label::after { content: ''; position: absolute; left: 14px; top: 50%; transform: translateY(-50%); width: 10px; height: 10px; background-color: #a2f279; border-radius: 50%; opacity: 0; transition: opacity 0.3s; }
        .radio-selector-item input[type="radio"]:checked + label { background-color: #61dafb; color: #282c34; font-weight: bold; }
        .radio-selector-item input[type="radio"]:checked + label::before { border-color: #282c34; }
        .radio-selector-item input[type="radio"]:checked + label::after { opacity: 1; }
        .dpad-container { display: grid; grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 1fr 1fr; gap: 5px; max-width: 150px; margin: 15px auto; }
        .dpad-btn { background-color: #61dafb; color: #282c34; border-radius: 5px; font-size: 2em; line-height: 1; padding: 5px; cursor: pointer; border: none; }
        .dpad-btn:hover { background-color: #a2f279; }
        #dpad-up { grid-column: 2; grid-row: 1; }
        #dpad-left { grid-column: 1; grid-row: 2; }
        #dpad-right { grid-column: 3; grid-row: 2; }
        #dpad-down { grid-column: 2; grid-row: 3; }
        #dpad-stop { grid-column: 2; grid-row: 2; background-color: #ff6347; color: white; }
        .dpad-input-group { display: grid; grid-template-columns: 1fr auto; gap: 10px; align-items: center; margin: 10px 0; }
        .dpad-input-group label { text-align: right; font-weight: bold; color: #a2f279; }
        .dpad-input-group input { width: 100%; box-sizing: border-box; background-color: #20232a; color: #fff; border: 1px solid #61dafb; border-radius: 5px; padding: 4px; }
        .sequence-step { display: grid; grid-template-columns: 1fr 100px auto; gap: 10px; align-items: center; background-color: #2a2f35; padding: 8px; border-radius: 6px; margin-bottom: 8px; transition: background-color: 0.3s; }
        .sequence-step.executing { background-color: #a2f279; color: #282c34; }
        .sequence-step.executing select, .sequence-step.executing input { color: #282c34; border-color: #282c34; }
        .sequence-step select, .sequence-step input { width: 100%; background-color: #20232a; color: #fff; border: 1px solid #61dafb; border-radius: 4px; padding: 5px; }
        .sequence-step .remove-step-btn { background-color: #ff6347; padding: 5px 10px; }
        #znTuningStatusPanel { background-color: #20232a; padding: 12px; border-radius: 6px; }
        #znTuningStatusPanel h5 { color: #61dafb; margin: 0 0 10px 0; font-size: 1.1em; text-align: left; }
        #znResultPanel { display: none; background-color: #20232a; padding: 12px; border-radius: 6px; margin-top: 15px; }
        #znResultPanel h5 { color: #61dafb; margin: 0 0 10px 0; text-align: left; }
        .result-grid { display: grid; grid-template-columns: auto 1fr; gap: 5px 15px; text-align: left; }
        .result-grid strong { color: #a2f279; }
        .result-grid span { font-weight: bold; color: #fff; }
        .apply-btn { background-color: #a2f279; margin-top: 10px; width: 100%; }
        #weights-budget { font-weight: bold; }
        #weights-budget.invalid { color: #ff6347; }
        #weights-budget.valid { color: #a2f279; }
        .ga-button-row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 15px; }
        .test-results-panel { display: none; background-color: #20232a; padding: 12px; border-radius: 6px; margin-top: 15px; }
        .test-results-panel h5 { color: #61dafb; margin: 0 0 10px 0; text-align: left; }
        #robot3d-container { width: 100%; height: 400px; border-radius: 8px; overflow: hidden; position: relative; border: 2px solid #61dafb; }
        .robot3d-controls { display: flex; justify-content: space-between; align-items: center; margin-top: 10px; }
        .robot3d-controls button { padding: 8px 16px; background-color: #61dafb; color: #282c34; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        .robot3d-controls button:hover { background-color: #a2f279; }
        .robot3d-info { background-color: #20232a; padding: 10px; border-radius: 6px; margin-top: 10px; }
        .robot3d-metrics { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; text-align: left; }
        .robot3d-metrics strong { color: #a2f279; }
    </style>
</head>
<body>
    <div id="emergency-banner">ZATRZYMANIE AWARYJNE</div>
    <div id="gamepad-mapping-modal" class="modal-backdrop">
        <div class="modal-content">
            <h2>Mapowanie Przyciskow Gamepada</h2>
            <div id="gamepad-mapping-list"></div>
            <button id="close-modal-btn" style="margin-top: 20px;">Zamknij</button>
        </div>
    </div>

    <h1>Robot PID - Panel Sterowania</h1>
    <div class="main-grid">
        <!-- 1. STEROWANIE -->
        <div class="card" id="controls-card">
            <h2>Sterowanie</h2>
            <div id="joystickWrapper"><canvas id="joystickCanvas"></canvas></div>
            <div class="control-row"><span class="control-label">Balansowanie</span><label class="switch"><input type="checkbox" id="balanceSwitch"><span class="slider round"></span></label></div>
            <div class="control-row"><span class="control-label">Trzymaj Pozycje</span><label class="switch"><input type="checkbox" id="holdPositionSwitch"><span class="slider round"></span></label></div>
            <div class="control-row"><span class="control-label">Tryb Predkosci</span><label class="switch"><input type="checkbox" id="speedModeSwitch"><span class="slider round"></span></label></div>
            <button id="open-gamepad-modal-btn" style="width: 100%; background-color:#f7b731; margin-top: 15px;">Mapowanie Przyciskow Gamepada</button>
            <button id="resetZeroBtn" style="margin-top:10px; width:100%;">Resetuj Osie</button>
            <div class="trim-controls"> <button id="trimMinusBtn">-</button> <span>Korekta Pionu (Pitch)</span> <button id="trimPlusBtn">+</button> </div>
            <button id="resetEncodersBtn" style="margin-top:10px; background-color:#f7b731; width: 100%;">Resetuj Enkodery</button>
            <button id="emergencyStopBtn">STOP AWARYJNY</button>
        </div>

        <!-- 2. STATUS ROBOTA -->
        <div class="card">
            <h2>Status Robota</h2>
            <button id="connectBleBtn" style="width: 100%; margin-bottom: 15px;">POLACZ Z ROBOTEM</button>
            <div class="status-grid">
                <strong>Polaczenie:</strong> <div><span id="connectionStatus" class="status-indicator status-disconnected"></span> <span id="connectionText">Rozlaczony</span></div>
                <strong>Gamepad:</strong> <span id="gamepadStatus" style="font-weight:bold; color: #f7b731;">Brak</span>
                <strong>Tryb Pracy:</strong> <span id="robotStateVal" style="font-weight:bold; color: #61dafb;">IDLE</span>
            </div>
            <div class="info-grid">
                <strong>Kat (Pitch):</strong> <div class="angle-display"><span id="angleVal">0.0 &deg;</span><div class="angle-indicator-wrapper"><div id="angleIndicator" class="angle-indicator-needle"></div></div></div>
                <strong>Kat (Yaw):</strong> <span id="yawVal">0.0 &deg;</span>
                <strong>Predkosc (imp/s):</strong> <span id="speedVal">0</span>
                <strong>Enkoder L:</strong> <span id="encoderLeftVal">0</span>
                <strong>Enkoder P:</strong> <span id="encoderRightVal">0</span>
            </div>
             <fieldset style="margin-top: 15px;">
                <legend>Diagnostyka</legend>
                <div style="display: grid; grid-template-columns: 1fr; gap: 10px;">
                    <button id="calibrateMpuBtn" style="width:100%; background-color:#f7b731;">Kalibruj MPU (DMP)</button>
                    <button id="calibrateZeroPointBtn" style="width:100%; background-color:#f7b731;">Znajdz Pion Automatycznie</button>
                </div>
            </fieldset>
        </div>

        <!-- 3. WIZUALIZACJA 3D ROBOTA -->
        <div class="card">
            <h2>Wizualizacja 3D Robota</h2>
            <div id="robot3d-container"></div>
            <div class="robot3d-controls">
                <button id="reset3dViewBtn">Resetuj Widok</button>
                <button id="toggle3dAnimationBtn">Wl./Wyl. Animacje</button>
                <button id="toggle3dMovementBtn">Start/Stop Ruchu</button>
            </div>
            <div class="robot3d-info">
                <div class="robot3d-metrics">
                    <strong>Przechyl:</strong> <span id="robot3d-pitch">0.0°</span>
                    <strong>Obrot kol:</strong> <span id="robot3d-wheel-speed">0 obr/min</span>
                    <strong>Pozycja X:</strong> <span id="robot3d-position-x">0.0 cm</span>
                    <strong>Pozycja Z:</strong> <span id="robot3d-position-z">0.0 cm</span>
                </div>
            </div>
        </div>

        <!-- 4. WYKRES TELEMETRYCZNY -->
        <div class="card">
            <button class="accordion-header" onclick="toggleAccordion(this)">Wykres Telemetryczny</button>
            <div class="accordion-content">
                <div id="chart-wrapper"><canvas id="telemetryChart"></canvas></div>
                <div class="chart-controls" id="chartControls"></div>
            </div>
        </div>

        <!-- 5. STEROWANIE AUTONOMICZNE -->
        <div class="card">
             <button class="accordion-header" onclick="toggleAccordion(this)">Sterowanie Autonomiczne</button>
            <div class="accordion-content">
               <fieldset>
                   <legend>Sterowanie Precyzyjne (D-Pad)</legend>
                   <div class="dpad-input-group">
                       <label for="dpadDistInput">Dystans (cm):</label>
                       <input type="number" id="dpadDistInput" value="20">
                   </div>
                   <div class="dpad-input-group">
                       <label for="dpadAngleInput">Kat (st.):</label>
                       <input type="number" id="dpadAngleInput" value="90">
                   </div>
                   <div class="dpad-container">
                       <button id="dpad-up" class="dpad-btn" data-dpad="up">&#8593;</button>
                       <button id="dpad-left" class="dpad-btn" data-dpad="left">&#8592;</button>
                       <button id="dpad-stop" class="dpad-btn" data-dpad="stop">&#215;</button>
                       <button id="dpad-right" class="dpad-btn" data-dpad="right">&#8594;</button>
                       <button id="dpad-down" class="dpad-btn" data-dpad="down">&#8595;</button>
                   </div>
               </fieldset>
               <fieldset style="margin-top: 15px;">
                   <legend>Kreator Sekwencji Ruchow</legend>
                   <div id="sequence-list"></div>
                   <button id="add-sequence-step-btn" style="width:100%; margin: 10px 0;">Dodaj Krok</button>
                   <div style="display:flex; gap:10px; justify-content:center;">
                       <button id="run-sequence-btn" style="background-color: #a2f279;">Uruchom</button>
                       <button id="stop-sequence-btn" style="background-color: #ff6347;" disabled>Zatrzymaj</button>
                       <button id="clear-sequence-btn" style="background-color: #f7b731;">Wyczysc</button>
                   </div>
               </fieldset>
           </div>
        </div>

        <!-- 6. KONFIGURACJA -->
        <div class="card">
            <h2>Konfiguracja</h2>
            <fieldset>
                <legend>Profile Ustawien PID</legend>
                <div class="profile-controls"> <select id="pidPresetSelect" style="width: 100%; padding: 5px;"></select> </div>
                <div class="preset-actions">
                    <button id="applySelectedPresetBtn">Zastosuj</button>
                    <button id="saveCurrentAsPresetBtn">Zapisz jako Nowy</button>
                </div>
                <button id="deleteSelectedPresetBtn" style="width:100%; margin-top: 10px; background-color: #ff6347;">Usun Wybrany Preset</button>
            </fieldset>
            <div id="allSettings">
                <button class="accordion-header" onclick="toggleAccordion(this)">1. Strojenie Joysticka</button>
                <div class="accordion-content">
                    <div class="setting-container"><label for="joystickSensitivityInput">Czulosc Globalna (%)<span class="help-icon">?</span></label><div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="joystickSensitivityInput" min="10" max="100" step="5" value="100"><button>+</button></div><div class="help-text">Mnoznik dla wszystkich wartosci z joysticka. Zmniejsz, aby robot byl mniej czuly.</div></div>
                    <div class="setting-container"><label for="expoJoystickInput">Expo Joysticka (%)<span class="help-icon">?</span></label><div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="expoJoystickInput" min="0" max="90" step="1" value="0"><button>+</button></div><div class="help-text">Dodaje krzywa wykladnicza. Wieksza wartosc = wieksza precyzja przy malych wychyleniach.</div></div>
                    <div class="setting-container"><label for="maxSpeedJoystickInput">Max. predkosc (imp/s)<span class="help-icon">?</span></label><div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="maxSpeedJoystickInput" min="200" max="4000" step="100" value="800"><button>+</button></div><div class="help-text">Maksymalna predkosc zadana w trybie predkosci przy pelnym wychyleniu joysticka.</div></div>
                    <div class="setting-container"><label for="joystickAngleSensitivityInput">Czulosc Kata (st.)<span class="help-icon">?</span></label><div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="joystickAngleSensitivityInput" min="1" max="30" step="0.5" value="10"><button>+</button></div><div class="help-text">Maksymalny kat pochylenia zadany w trybie kata przy pelnym wychyleniu joysticka.</div></div>
                    <div class="setting-container"><label for="turnFactorInput">Czulosc Skretu (%)<span class="help-icon">?</span></label><div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="turnFactorInput" min="0" max="100" step="5" value="25"><button>+</button></div><div class="help-text">Jak szybko robot ma sie obracac w miejscu przy maksymalnym wychyleniu joysticka w poziomie.</div></div>
                    <div class="setting-container"><label for="joystickDeadzoneInput">Strefa Martwa (%)<span class="help-icon">?</span></label><div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="joystickDeadzoneInput" min="0" max="50" step="1" value="0"><button>+</button></div><div class="help-text">Obszar wokol srodka joysticka, w ktorym ruch jest ignorowany.</div></div>
                </div>

                <button class="accordion-header" onclick="toggleAccordion(this)">2. PID Balansu (Podstawowy)</button>
                <div class="accordion-content">
                    <div class="setting-container"> <label for="balanceKpInput">Kp - Sila<span class="help-icon">?</span></label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="balanceKpInput" step="0.0001" value="97.1850"><button>+</button></div> <div class="help-text"><strong>Wplyw:</strong> Sztywnosc utrzymania pionu. Zwieksz dla szybszej reakcji na wychylenie. Zbyt duza wartosc powoduje oscylacje.</div> </div>
                    <div class="setting-container"> <label for="balanceKiInput">Ki - Korekta<span class="help-icon">?</span></label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="balanceKiInput" step="0.01" value="0.0"><button>+</button></div> <div class="help-text"><strong>Wplyw:</strong> Usuwa dlugotrwaly blad (np. gdy robot dryfuje). Zwiekszaj bardzo ostroznie, czesto nie jest potrzebny.</div> </div>
                    <div class="setting-container"> <label for="balanceKdInput">Kd - Tlumienie<span class="help-icon">?</span></label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="balanceKdInput" step="0.0001" value="3.0039"><button>+</button></div> <div class="help-text"><strong>Wplyw:</strong> Hamuje oscylacje i uspokaja robota. Przewiduje przyszly blad. Zbyt duza wartosc spowalnia reakcje.</div> </div>
                    <div class="setting-container"> <label for="balanceFilterAlphaInput">Filtr Pochodnej (%)<span class="help-icon">?</span></label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="balanceFilterAlphaInput" min="1" max="100" step="1" value="40"><button>+</button></div> <div class="help-text">Wygladza odczyt pochodnej, redukujac wplyw szumow. 100% = brak filtrowania. Zmniejsz, jesli robot jest nerwowy.</div> </div>
                </div>

                <button class="accordion-header" onclick="toggleAccordion(this)">3. PID Kaskadowy (Predkosc/Pozycja)</button>
                <div class="accordion-content">
                    <div class="parameter-group"><h5>PID Predkosci</h5>
                        <div class="setting-container"> <label for="speedKpInput">Kp - Reakcja</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="speedKpInput" step="0.01" value="0.0"><button>+</button></div> </div>
                        <div class="setting-container"> <label for="speedKiInput">Ki - Eliminacja bledu</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="speedKiInput" step="0.001" value="0.0"><button>+</button></div> </div>
                        <div class="setting-container"> <label for="speedKdInput">Kd - Tlumienie</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="speedKdInput" step="0.001" value="0.0"><button>+</button></div> </div>
                        <div class="setting-container"> <label for="maxTargetAngleInput">Max. kat z PID Predk. (st.)</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="maxTargetAngleInput" step="0.5" value="5.0"><button>+</button></div> </div>
                        <div class="setting-container"> <label for="speedDeadbandInput">Strefa martwa (imp/s)</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="speedDeadbandInput" step="1" value="5"><button>+</button></div> </div>
                    </div>
                     <div class="parameter-group"><h5>PID Pozycji</h5>
                        <div class="setting-container"> <label for="positionKpInput">Kp - Sila powrotu</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="positionKpInput" step="0.1" value="0.0"><button>+</button></div> </div>
                        <div class="setting-container"> <label for="positionKiInput">Ki - Korekta</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="positionKiInput" step="0.001" value="0.0"><button>+</button></div> </div>
                        <div class="setting-container"> <label for="positionKdInput">Kd - Hamowanie</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="positionKdInput" step="0.05" value="0.0"><button>+</button></div> </div>
                        <div class="setting-container"> <label for="maxTargetSpeedInput">Max. predkosc z PID Poz. (imp/s)</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="maxTargetSpeedInput" step="50" value="500"><button>+</button></div> </div>
                        <div class="setting-container"> <label for="positionDeadbandInput">Margines bledu (imp.)</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="positionDeadbandInput" step="1" value="5"><button>+</button></div> </div>
                    </div>
                </div>

                <button class="accordion-header" onclick="toggleAccordion(this)">4. PID Obrotu i Kursu</button>
                <div class="accordion-content">
                    <div class="parameter-group"><h5>PID Obrotu (Autonomiczny)</h5>
                        <div class="setting-container"> <label for="rotationKpInput">Kp - Sila obrotu</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="rotationKpInput" step="0.1" value="0.0"><button>+</button></div> </div>
                        <div class="setting-container"> <label for="rotationKdInput">Kd - Tlumienie</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="rotationKdInput" step="0.1" value="0.0"><button>+</button></div> </div>
                    </div>
                    <div class="parameter-group"><h5>PID Utrzymania Kursu (podczas jazdy prosto)</h5>
                        <div class="setting-container"> <label for="headingKpInput">Kp - Sila korekty</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="headingKpInput" step="0.05" value="0.0"><button>+</button></div> </div>
                        <div class="setting-container"> <label for="headingKiInput">Ki - Precyzja</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="headingKiInput" step="0.005" value="0.0"><button>+</button></div> </div>
                        <div class="setting-container"> <label for="headingKdInput">Kd - Tlumienie</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="headingKdInput" step="0.01" value="0.0"><button>+</button></div> </div>
                    </div>
                </div>

                <button class="accordion-header" onclick="toggleAccordion(this)">5. Parametry Sprzetowe i Mechaniczne</button>
                <div class="accordion-content">
                    <div class="setting-container"> <label for="wheelDiameterInput">Srednica kola (cm)</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="wheelDiameterInput" step="0.1" value="8.2"><button>+</button></div> </div>
                    <div class="setting-container"> <label for="trackWidthInput">Rozstaw kol (cm)</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="trackWidthInput" step="0.1" value="12.5"><button>+</button></div> </div>
                    <div class="setting-container"> <label for="encoderPprInput">Impulsy na obrot (PPR)</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="encoderPprInput" step="10" value="820"><button>+</button></div> </div>
                </div>

                <button class="accordion-header" onclick="toggleAccordion(this)">6. Konfiguracja Filtr Kalmana</button>
                <div class="accordion-content">
                    <div class="setting-container"><label for="kalmanQAngleInput">Q Angle (Szum Procesu - Kat)<span class="help-icon">?</span></label><div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="kalmanQAngleInput" min="0.0001" max="0.01" step="0.0001" value="0.001"><button>+</button></div><div class="help-text">Wspolczynnik zaufania do modelu predykcji kata. Wieksza wartosc = wiekszy szum procesu, filtr bedzie bardziej reagowal na akcelerometr.</div></div>
                    <div class="setting-container"><label for="kalmanQBiasInput">Q Bias (Szum Procesu - Bias)<span class="help-icon">?</span></label><div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="kalmanQBiasInput" min="0.0001" max="0.01" step="0.0001" value="0.003"><button>+</button></div><div class="help-text">Wspolczynnik zaufania do modelu predykcji dryfu zyroskopu. Wieksza wartosc = szybsza adaptacja do dryfu zyroskopu.</div></div>
                    <div class="setting-container"><label for="kalmanRMeasureInput">R Measure (Szum Pomiaru)<span class="help-icon">?</span></label><div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="kalmanRMeasureInput" min="0.001" max="0.1" step="0.001" value="0.03"><button>+</button></div><div class="help-text">Zaufanie do pomiarow akcelerometru. Wieksza wartosc = mniejsze zaufanie do akcelerometru, filtr bedzie bardziej poleganal na zyroskopie.</div></div>
                    <div class="pwm-info"><strong>Info:</strong> Filtr Kalmana laczy dane z akcelerometru (precyzyjny kat, ale podatny na wstrzasy) z zyroskopem (precyzyjna predkosc katowa, ale z dryfem). Parametry Q i R kontroluja, jak bardzo filtr ufa kazdemu zrodlu danych. <strong>Tip:</strong> Zwieksz Q_angle, jesli robot jest niestabilny, zwieksz R_measure, jesli akcelerometr jest zbyt szumny.</div>
                </div>

                <button class="accordion-header" onclick="toggleAccordion(this)">7. Kalibracja PWM Silnikow</button>
                <div class="accordion-content">
                    <div class="pwm-info"> <strong>Info:</strong> Uzyj przycisku <strong>"Auto"</strong>, aby automatycznie znalezc prog startowy silnika, lub <strong>"Testuj"</strong>, aby sprawdzic recznie wpisana wartosc. <strong>Wazne:</strong> Przed testem podnies robota, aby kola mogly sie swobodnie krecic! </div>
                     <div class="setting-container"> <label for="pwmTuneStartInput">Rozpocznij auto-szukanie od PWM</label> <div class="numeric-input-wrapper"> <button id="pwmTuneStartMinus">-</button> <input type="number" id="pwmTuneStartInput" min="1" max="800" step="1" value="600"> <button id="pwmTuneStartPlus">+</button> </div> </div> <hr style="border-color: #4a4f58; margin: 15px 0;">
                    <div class="manual-tune-row" data-motor="left" data-direction="fwd"> <div class="pwm-input-row"> <label>Lewy (Przod)</label> <div class="numeric-input-wrapper"><button class="tune-minus">-</button><input type="number" class="config-value tune-input" id="minPwmLeftFwdInput" min="0" max="1023" step="1" value="640"><button>+</button></div> </div> <div class="pwm-button-row"> <button class="test-btn">Testuj</button><button class="stop-btn">Stop</button><button class="auto-btn">Auto</button></div> </div>
                    <div class="manual-tune-row" data-motor="left" data-direction="bwd"> <div class="pwm-input-row"> <label>Lewy (Tyl)</label> <div class="numeric-input-wrapper"><button class="tune-minus">-</button><input type="number" class="config-value tune-input" id="minPwmLeftBwdInput" min="0" max="1023" step="1" value="640"><button>+</button></div> </div> <div class="pwm-button-row"> <button class="test-btn">Testuj</button><button class="stop-btn">Stop</button><button class="auto-btn">Auto</button></div> </div>
                    <div class="manual-tune-row" data-motor="right" data-direction="fwd"> <div class="pwm-input-row"> <label>Prawy (Przod)</label> <div class="numeric-input-wrapper"><button class="tune-minus">-</button><input type="number" class="config-value tune-input" id="minPwmRightFwdInput" min="0" max="1023" step="1" value="640"><button>+</button></div> </div> <div class="pwm-button-row"> <button class="test-btn">Testuj</button><button class="stop-btn">Stop</button><button class="auto-btn">Auto</button></div> </div>
                    <div class="manual-tune-row" data-motor="right" data-direction="bwd"> <div class="pwm-input-row"> <label>Prawy (Tyl)</label> <div class="numeric-input-wrapper"><button class="tune-minus">-</button><input type="number" class="config-value tune-input" id="minPwmRightBwdInput" min="0" max="1023" step="1" value="640"><button>+</button></div> </div> <div class="pwm-button-row"> <button class="test-btn">Testuj</button><button class="stop-btn">Stop</button><button class="auto-btn">Auto</button></div> </div>
                    <button id="manualTuneStopAll" style="width:100%; margin-top:15px; background-color:#ff6347;">ZATRZYMAJ WSZYSTKIE SILNIKI</button>
                </div>
            </div>
            <div class="button-group" style="display:flex; gap:10px; justify-content:center; margin-top:20px;">
                <button id="loadBtn">Wczytaj z Robota</button>
                <button id="saveBtn">Zapisz na Robocie</button>
            </div>
        </div>

        <!-- 7. AUTO STROJENIE -->
        <div class="card">
            <h2>Auto Strojenie</h2>

            <button class="accordion-header" onclick="toggleAccordion(this)">1: Pierwsze Strojenie (Odkrywanie Z-N)</button>
            <div class="accordion-content">
                <div class="setting-container">
                    <label>Cel Procedury<span class="help-icon">?</span></label>
                    <div class="help-text">Automatyczne znalezienie podstawowych, dzialajacych parametrow PID dla balansu (Kp, Kd). Robot sam wprowadzi sie w oscylacje, aby zbadac swoja fizyke. Wynik tego testu to idealny punkt startowy dla dalszej, precyzyjnej optymalizacji.</div>
                </div>
                <div id="znTuningStatusPanel">
                    <h5>Status Procedury Odkrywania</h5>
                    <div class="info-grid">
                        <strong>Status:</strong> <span id="znStatusText" style="font-weight: bold;">Bezczynny</span>
                        <strong>Testowane Kp:</strong> <span id="znKpTestVal">---</span>
                    </div>
                </div>

                <div id="znResultPanel">
                    <h5>Wynik Odkrywania</h5>
                    <div class="result-grid">
                        <strong>Wzmocnienie Krytyczne (Ku):</strong> <span id="znKuResult"></span>
                        <strong>Okres Krytyczny (Tu):</strong> <span id="znTuResult"></span>
                        <hr style="grid-column: 1 / -1; border-color: #4a4f58;">
                        <strong>Sugerowane Kp:</strong> <span id="znKpSuggest"></span>
                        <strong>Sugerowane Kd:</strong> <span id="znKdSuggest"></span>
                    </div>
                    <button id="applyZnResultsBtn" class="apply-btn">Zastosuj Sugerowane Wartosci</button>
                </div>

                <button id="znTuningActionBtn" style="width:100%; margin-top:15px; background-color: #f7b731;">Rozpocznij Odkrywanie</button>
                <button id="znTuningCancelBtn" style="width:100%; margin-top:10px; background-color:#ff6347; display:none;">Anuluj</button>
            </div>

            <button class="accordion-header" onclick="toggleAccordion(this)">2: Optymalizacja i Testy Wydajnosciowe (GA)</button>
            <div class="accordion-content">
                <div class="setting-container" style="margin-bottom: 15px;">
                    <label>Cel Optymalizacji/Testow<span class="help-icon">?</span></label>
                     <div class="help-text">Uruchomienie inteligentnej optymalizacji (algorytm genetyczny) dla wybranej petli regulacji (balans, predkosc lub pozycja) w celu znalezienia optymalnych nastaw PID.</div>
                </div>

                <div id="autotestSelector" class="radio-selector-group">
                    <div class="radio-selector-item">
                        <input type="radio" id="test-balance" name="autotest-type" value="balance" checked>
                        <label for="test-balance">Optymalizuj Petle Balansu (GA - Auto)</label>
                    </div>
                    <div class="radio-selector-item">
                        <input type="radio" id="test-speed" name="autotest-type" value="speed">
                        <label for="test-speed">Optymalizuj Petle Predkosci (GA - Interaktywnie)</label>
                    </div>
                    <div class="radio-selector-item">
                        <input type="radio" id="test-position" name="autotest-type" value="position">
                        <label for="test-position">Optymalizuj Petle Pozycji (GA - Interaktywnie)</label>
                    </div>
                </div>

                <div id="autotestOptions" style="margin-top: 15px;">
                     <div class="setting-container">
                        <label for="testDurationInput">Czas proby / zbierania danych (s)</label>
                        <div class="numeric-input-wrapper"><button>-</button><input type="number" id="testDurationInput" step="0.5" value="5.0" min="1" max="20"><button>+</button></div>
                    </div>
                    <hr style="border-color: #4a4f58; margin: 15px 0;">

                    <!-- Panel dla Optymalizacji Genetycznej Balansu -->
                    <div id="balanceOptionsPanel">
                         <fieldset>
                            <legend>Priorytety Optymalizacji (Budzet: <span id="weights-budget">10.0</span> pkt)</legend>
                            <div class="setting-container">
                                <label>Waga Stabilnosci (S)<span class="help-icon">?</span></label>
                                <div class="numeric-input-wrapper"><button>-</button><input type="number" class="weight-input" id="weightStability" step="0.5" value="4.0" min="0" max="10"><button>+</button></div>
                                <div class="help-text">Zwieksz, jesli chcesz, aby robot minimalizowal srednie odchylenie od zera w czasie.</div>
                            </div>
                            <div class="setting-container">
                                <label>Waga Spokoju (C)<span class="help-icon">?</span></label>
                                <div class="numeric-input-wrapper"><button>-</button><input type="number" class="weight-input" id="weightStillness" step="0.5" value="3.0" min="0" max="10"><button>+</button></div>
                                <div class="help-text">Zwieksz, jesli priorytetem jest, aby robot stal idealnie nieruchomo, bez zbednych, czestych oscylacji.</div>
                            </div>
                             <div class="setting-container">
                                <label>Waga Przekroczenia (P)<span class="help-icon">?</span></label>
                                <div class="numeric-input-wrapper"><button>-</button><input type="number" class="weight-input" id="weightOvershoot" step="0.5" value="2.0" min="0" max="10"><button>+</button></div>
                                <div class="help-text">Zwieksz, aby surowo karac nawet chwilowe, duze wychylenia od zera.</div>
                            </div>
                             <div class="setting-container">
                                <label>Waga Wysilku (W)<span class="help-icon">?</span></label>
                                <div class="numeric-input-wrapper"><button>-</button><input type="number" class="weight-input" id="weightEffort" step="0.5" value="1.0" min="0" max="10"><button>+</button></div>
                                <div class="help-text">Zwieksz, aby zminimalizowac agresywnosc i zuzycie energii przez silniki.</div>
                            </div>
                        </fieldset>
                    </div>
                    <!-- Panel dla Strojenia Pozycji -->
                    <div id="positionTestOptionsPanel" style="display: none;">
                        <fieldset>
                            <legend>Parametry Strojenia Petli Pozycji</legend>
                             <div class="setting-container">
                                <label for="positionTestImpulseInput">Sila impulsu (PWM)</label>
                                <div class="numeric-input-wrapper"><button>-</button><input type="number" id="positionTestImpulseInput" step="10" value="700" min="200" max="1023"><button>+</button></div>
                            </div>
                        </fieldset>
                    </div>
                     <!-- Panel dla Strojenia Predkosci -->
                    <div id="speedTestOptionsPanel" style="display: none;">
                        <fieldset>
                             <legend>Parametry Strojenia Petli Predkosci</legend>
                             <div class="setting-container">
                                <label for="speedTestDistanceInput">Dystans docelowy (cm)</label>
                                <div class="numeric-input-wrapper"><button>-</button><input type="number" id="speedTestDistanceInput" step="10" value="100" min="10" max="500"><button>+</button></div>
                            </div>
                            <div class="setting-container">
                                <label for="speedTestSpeedInput">Predkosc docelowa (cm/s)</label>
                                <div class="numeric-input-wrapper"><button>-</button><input type="number" id="speedTestSpeedInput" step="5" value="50" min="10" max="200"><button>+</button></div>
                            </div>
                        </fieldset>
                    </div>
                     <!-- Panel wspolny dla wszystkich testow GA -->
                    <fieldset style="margin-top: 15px;">
                        <legend>Parametry Algorytmu Genetycznego</legend>
                        <div class="setting-container">
                            <label for="gaGenerationsInput">Liczba pokolen<span class="help-icon">?</span></label>
                            <div class="numeric-input-wrapper">
                                <button>-</button>
                                <input type="number" id="gaGenerationsInput" min="2" max="50" step="1" value="10">
                                <button>+</button>
                            </div>
                            <div class="help-text">Ile cykli ewolucji ma przejsc algorytm. Wiecej = potencjalnie lepszy wynik, ale dluzszy czas.</div>
                        </div>
                        <div class="setting-container">
                            <label for="gaPopulationInput">Liczba osobnikow<span class="help-icon">?</span></label>
                            <div class="numeric-input-wrapper">
                                <button>-</button>
                                <input type="number" id="gaPopulationInput" min="4" max="20" step="1" value="10">
                                <button>+</button>
                            </div>
                            <div class="help-text">Ile rozwiazan (zestawow PID) bedzie testowanych w kazdym pokoleniu.</div>
                        </div>
                    </fieldset>
                </div>

                <div id="autotestStatusPanel" style="margin-top:15px;">
                    <h5>Status Sesji Optymalizacji</h5>
                    <div class="info-grid">
                        <strong>Pokolenie / Osobnik:</strong> <span id="statusGeneration">---</span>
                        <strong>Najlepszy wynik ogolnie:</strong> <span id="statusBestScore" style="font-weight: bold; color: #a2f279;">---</span>
                        <strong>Najlepsze Znalezione:</strong> <span id="statusBestPhenotype" style="font-weight: bold; color: #61dafb;">---</span>
                        <hr style="grid-column: 1 / -1; border-color: #4a4f58; margin: 2px 0;">
                        <strong>Testowane Parametry:</strong> <span id="statusCurrentPhenotype" style="font-weight: bold; color: #f7b731;">---</span>
                        <strong>Ostatni wynik:</strong> <span id="statusLastScore" style="font-weight: bold; color: #f7b731;">---</span>
                        <hr style="grid-column: 1 / -1; border-color: #4a4f58; margin: 2px 0;">
                        <strong>Postep Generacji:</strong>
                        <div>
                            <progress id="statusProgressBar" value="0" max="100"></progress>
                            <span id="statusProgressText" style="font-size:0.9em;">Gotowy do rozpoczecia...</span>
                        </div>
                        <strong>Status:</strong> <span id="statusStateText" style="font-weight: bold;">Bezczynny</span>
                    </div>
                </div>
                
                <div id="gaResultsPanel" class="test-results-panel" style="margin-top: 15px;">
                    <h5>Wyniki Sesji Optymalizacji</h5>
                    <div class="result-grid">
                        <strong>Najlepsza Ocena:</strong> <span id="gaFinalScore"></span>
                        <strong>Znalezione Kp:</strong> <span id="gaFinalKp"></span>
                        <strong>Znalezione Ki:</strong> <span id="gaFinalKi"></span>
                        <strong>Znalezione Kd:</strong> <span id="gaFinalKd"></span>
                    </div>
                    <button id="applyGaResultsBtn" class="apply-btn">Zastosuj do Panelu</button>
                </div>


                <div id="autotestControls" style="margin-top: 15px;">
                    <div class="ga-button-row">
                        <button id="autotestActionBtn" style="width:100%;">Rozpocznij Sesje Strojenia</button>
                        <button id="ga_stop_btn" style="background-color: #ff6347; display: none;">Zatrzymaj Sesje</button>
                    </div>
                </div>
            </div>

            <button class="accordion-header" onclick="toggleAccordion(this)">3: Charakteryzacja Systemu (Petle Kaskadowe)</button>
             <div class="accordion-content">
                <div class="setting-container">
                    <label>Cel Procedury<span class="help-icon">?</span></label>
                    <div class="help-text">Przeprowadzenie testu odpowiedzi skokowej w celu automatycznego znalezienia bezpiecznych, startowych parametrow dla petli predkosci. Wynik tego testu jest punktem wyjsciowym do recznego strojenia petli kaskadowych.</div>
                </div>
                 <div class="setting-container">
                    <label for="stepResponseAngleInput">Kat "pchniecia" (st.)</label>
                    <div class="numeric-input-wrapper"><button>-</button><input type="number" id="stepResponseAngleInput" step="0.1" value="2.0" min="0.5" max="5"><button>+</button></div>
                </div>
                <button id="startStepResponseBtn" style="width:100%; margin-top:10px; background-color: #f7b731;">Uruchom Analize</button>
                <div id="stepResponseResultPanel" class="test-results-panel">
                    <h5>Sugerowane Nastawy Startowe</h5>
                    <div class="result-grid">
                        <strong>Sugerowane Kp_s:</strong> <span id="srKpSuggest"></span>
                        <strong>Sugerowane Ki_s:</strong> <span id="srKiSuggest"></span>
                        <strong>Sugerowane Kd_s:</strong> <span id="srKdSuggest"></span>
                    </div>
                    <button id="applyStepResponseResultsBtn" class="apply-btn">Zastosuj Sugerowane Wartosci</button>
                </div>
             </div>
        </div>

        <!-- 8. LOGI -->
        <div class="card" id="log-card" style="grid-column: 1 / -1;">
            <h2>Logi Systemowe</h2>
            <div id="log-history"></div>
            <div style="margin-top: 10px; display: flex; gap: 10px; justify-content: center; align-items: center;">
                <button onclick="clearLogs()" style="background-color: #f7b731;">Wyczysc Logi</button>
            </div>
        </div>
    </div>

<script>
    // =======================================================================================
    // WERSJA 18.0 (Kalman Filter Integration)
    // =======================================================================================

    // === DEKLARACJE ZMIENNYCH GLOBALNYCH ===
    let isApplyingConfig = false;
    let lastKnownRobotState = 'IDLE';
    let isSequenceRunning = false;
    let currentSequenceStep = 0;
    const MAX_SEQUENCE_STEPS = 10;
    const parameterMapping = {
        'balanceKpInput': 'kp_b', 'balanceKiInput': 'ki_b', 'balanceKdInput': 'kd_b',
        'balanceFilterAlphaInput': 'balance_pid_derivative_filter_alpha',
        'joystickAngleSensitivityInput': 'joystick_angle_sensitivity',
        'speedKpInput': 'kp_s', 'speedKiInput': 'ki_s', 'speedKdInput': 'kd_s',
        'maxTargetAngleInput': 'max_target_angle_from_speed_pid', 'speedDeadbandInput': 'speed_pid_deadband',
        'positionKpInput': 'kp_p', 'positionKiInput': 'ki_p', 'positionKdInput': 'kd_p',
        'maxTargetSpeedInput': 'max_target_speed_from_pos_pid', 'positionDeadbandInput': 'position_pid_deadband',
        'rotationKpInput': 'kp_r', 'rotationKdInput': 'kd_r',
        'headingKpInput': 'kp_h', 'headingKiInput': 'ki_h', 'headingKdInput': 'kd_h',
        'joystickSensitivityInput': 'joystick_sensitivity', 'expoJoystickInput': 'expo_joystick', 'maxSpeedJoystickInput': 'max_speed_joystick',
        'turnFactorInput': 'turn_factor', 'joystickDeadzoneInput': 'joystick_deadzone',
        'wheelDiameterInput': 'wheel_diameter_cm', 'trackWidthInput': 'track_width_cm', 'encoderPprInput': 'encoder_ppr',
        'minPwmLeftFwdInput': 'min_pwm_left_fwd', 'minPwmLeftBwdInput': 'min_pwm_left_bwd',
        'minPwmRightFwdInput': 'min_pwm_right_fwd', 'minPwmRightBwdInput': 'min_pwm_right_bwd',
        'kalmanQAngleInput': 'kalman_q_angle', 'kalmanQBiasInput': 'kalman_q_bias', 'kalmanRMeasureInput': 'kalman_r_measure'
    };

    // === INICJALIZACJA APLIKACJI ===
    document.addEventListener('DOMContentLoaded', () => {
        initJoystick();
        setupChartControls();
        populatePresetSelect();
        setupNumericInputs();
        setupEventListeners();
        setupManualTuneButtons();
        setupGamepadMappingModal();
        setupAutoTestEventListeners();
        setupDpadControls();
        setupSequenceControls();
        setupZnTuningControls();
        setupCharacterizationControls();
        loadGamepadMappings();
        renderMappingModal();
        pollGamepad();
        window.addEventListener('resize', initJoystick);
        renderAutotestOptions();
        init3DVisualization();
        animate3D();
    });

    // === KOMUNIKACJA BLUETOOTH LOW ENERGY (BLE) ===
    let bleDevice, rxCharacteristic, txCharacteristic;
    const SERVICE_UUID = "4fafc201-1fb5-459e-8fcc-c5c9c331914b";
    const RX_UUID = "beb5483e-36e1-4688-b7f5-ea07361b26a9";
    const TX_UUID = "beb5483e-36e1-4688-b7f5-ea07361b26a8";
    let bleBuffer = '';
    const bleChunks = new Map(); // id -> { total, parts: Map<i,string> }
    let bleMessageQueue = [];
    let isSendingBleMessage = false;
    const BLE_SEND_INTERVAL = 20;
    let bleConnectionRetries = 0;
    const MAX_BLE_RETRIES = 3;
    let bleRetryTimeout = null;

    // === KONTROLERY UZYTKOWNIKA (JOYSTICK, GAMEPAD) ===
    let joystickCenter, joystickRadius, knobRadius, isDragging = false;
    let lastJoystickSendTime = 0;
    const JOYSTICK_SEND_INTERVAL = 20;
    let gamepadIndex = null;
    let lastGamepadState = [];
    let gamepadMappings = {};
    const GAMEPAD_MAPPING_KEY = 'pid_gamepad_mappings_v3';
    let isMappingButton = false;
    let actionToMap = null;
    const CUSTOM_PRESET_PREFIX = 'pid_custom_preset_v3_';

    // === KONFIGURACJE I PRESETY ===
    const availableActions = {
        'toggle_balance': { label: 'Wlacz/Wylacz Balansowanie', elementId: 'balanceSwitch' },
        'toggle_hold_position': { label: 'Wlacz/Wylacz Trzymanie Pozycji', elementId: 'holdPositionSwitch' },
        'toggle_speed_mode': { label: 'Wlacz/Wylacz Tryb Predkosci', elementId: 'speedModeSwitch' },
        'emergency_stop': { label: 'STOP AWARYJNY', elementId: 'emergencyStopBtn' },
        'reset_zero': { label: 'Resetuj Osie', elementId: 'resetZeroBtn' },
        'trim_plus': { label: 'Korekta Pionu (+)', elementId: 'trimPlusBtn' },
        'trim_minus': { label: 'Korekta Pionu (-)', elementId: 'trimMinusBtn' },
        'trigger_next_individual': { label: 'Uruchom Test Nastepnego Osobnika', elementId: 'autotestActionBtn' }
    };
    const availableTelemetry = {
        'pitch': { label: 'Pitch (Kat)', color: '#61dafb' },
        'yaw': { label: 'Yaw (Kurs)', color: '#f368e0' },
        'speed': { label: 'Predkosc', color: '#f7b731'},
        'target_speed': { label: 'Predkosc Zadana', color: '#a2f279' },
        'output': { label: 'Wyjscie PID', color: '#ff6347'}
    };
    const builtInPresetsData = {
        '1': { name: "1. PID Zbalansowany (Startowy)", params: { balanceKpInput: 97.1850, balanceKiInput: 0.0, balanceKdInput: 3.0039 }},
        '2': { name: "2. PID Mieciutki (Plynny)", params: { balanceKpInput: 80.0, balanceKiInput: 0.0, balanceKdInput: 2.8 }},
        '3': { name: "3. PID Agresywny (Sztywny)", params: { balanceKpInput: 110.0, balanceKiInput: 0.0, balanceKdInput: 4.0 }}
    };

    // === FUNKCJE OBSLUGI JOYSTICKA ===
    function initJoystick() { const wrapper = document.getElementById('joystickWrapper'); const size = wrapper.clientWidth; const joystickCanvas = document.getElementById('joystickCanvas'); const joystickCtx = joystickCanvas.getContext('2d'); joystickCanvas.width = size; joystickCanvas.height = size; joystickCenter = { x: size / 2, y: size / 2 }; joystickRadius = size / 2 * 0.75; knobRadius = size / 2 * 0.25; drawJoystick(joystickCtx, joystickCenter.x, joystickCenter.y); }
    function drawJoystick(ctx, x, y) { ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); ctx.beginPath(); ctx.arc(joystickCenter.x, joystickCenter.y, joystickRadius, 0, 2 * Math.PI); ctx.fillStyle = 'rgba(255, 255, 255, 0.1)'; ctx.fill(); ctx.beginPath(); ctx.arc(x, y, knobRadius, 0, 2 * Math.PI); ctx.fillStyle = '#61dafb'; ctx.fill(); }
    function handleJoystickStart(event) { event.preventDefault(); isDragging = true; }
    function handleJoystickMove(event) { if (!isDragging) return; event.preventDefault(); const joystickCanvas = document.getElementById('joystickCanvas'); const joystickCtx = joystickCanvas.getContext('2d'); let { x, y } = getJoystickPosition(event); const dx = x - joystickCenter.x; const dy = y - joystickCenter.y; const distance = Math.sqrt(dx * dx + dy * dy); if (distance > joystickRadius) { x = joystickCenter.x + (dx / distance) * joystickRadius; y = joystickCenter.y + (dy / distance) * joystickRadius; } drawJoystick(joystickCtx, x, y); const now = Date.now(); if (now - lastJoystickSendTime > JOYSTICK_SEND_INTERVAL) { const joyX = (x - joystickCenter.x) / joystickRadius; const joyY = -(y - joystickCenter.y) / joystickRadius; sendBleMessage({ type: 'joystick', x: joyX, y: joyY }); lastJoystickSendTime = now; } }
    function getJoystickPosition(event) { const rect = document.getElementById('joystickCanvas').getBoundingClientRect(); const touch = event.touches ? event.touches[0] : event; return { x: touch.clientX - rect.left, y: touch.clientY - rect.top }; }
    function handleJoystickEnd(event) { if (!isDragging) return; event.preventDefault(); isDragging = false; const joystickCanvas = document.getElementById('joystickCanvas'); const joystickCtx = joystickCanvas.getContext('2d'); drawJoystick(joystickCtx, joystickCenter.x, joystickCenter.y); sendBleMessage({ type: 'joystick', x: 0, y: 0 }); }

    // === FUNKCJE OBSLUGI GAMEPADA ===
    function pollGamepad() { if (gamepadIndex !== null) { const gp = navigator.getGamepads()[gamepadIndex]; if (!gp) return; if (isMappingButton && actionToMap) { gp.buttons.forEach((button, i) => { if (button.pressed && !lastGamepadState[i]) { Object.keys(gamepadMappings).forEach(key => { if (gamepadMappings[key] === actionToMap) delete gamepadMappings[key]; }); gamepadMappings[i] = actionToMap; saveGamepadMappings(); addLogMessage(`[UI] Akcja '${availableActions[actionToMap].label}' przypisana do przycisku ${i}.`, 'success'); isMappingButton = false; actionToMap = null; renderMappingModal(); } }); } else { gp.buttons.forEach((button, i) => { if (button.pressed && !lastGamepadState[i]) { const action = gamepadMappings[i]; if (action && availableActions[action]) { const element = document.getElementById(availableActions[action].elementId); if (element && !element.disabled) { element.click(); flashElement(element); } } } }); } lastGamepadState = gp.buttons.map(b => b.pressed); let x = gp.axes[0] || 0; let y = gp.axes[1] || 0; if (Math.abs(x) < 0.15) x = 0; if (Math.abs(y) < 0.15) y = 0; sendBleMessage({ type: 'joystick', x: x, y: -y }); } requestAnimationFrame(pollGamepad); }
    window.addEventListener('gamepadconnected', (e) => { gamepadIndex = e.gamepad.index; document.getElementById('gamepadStatus').textContent = 'Polaczony'; document.getElementById('gamepadStatus').style.color = '#a2f279'; addLogMessage(`[UI] Gamepad polaczony: ${e.gamepad.id}`, 'success'); });
    window.addEventListener('gampaddisconnected', (e) => { gamepadIndex = null; document.getElementById('gamepadStatus').textContent = 'Brak'; document.getElementById('gamepadStatus').style.color = '#f7b731'; addLogMessage('[UI] Gamepad rozlaczony.', 'warn'); });
    function startMapping(action, buttonElement) { if (gamepadIndex === null) { addLogMessage("Podlacz gamepada, aby rozpoczac mapowanie!", "warn"); return; } isMappingButton = true; actionToMap = action; document.querySelectorAll('.mapping-button').forEach(btn => btn.textContent = "Przypisz"); buttonElement.textContent = "Czekam..."; addLogMessage(`[UI] Nasluchiwanie na przycisk dla akcji: ${availableActions[action].label}...`, "info"); }
    function renderMappingModal() { const list = document.getElementById('gamepad-mapping-list'); list.innerHTML = ''; for (const [action, config] of Object.entries(availableActions)) { const row = document.createElement('div'); row.className = 'mapping-row'; const buttonIndex = Object.keys(gamepadMappings).find(key => gamepadMappings[key] === action); row.innerHTML = `<span class="mapping-label">${config.label}</span><span class="mapping-display">${buttonIndex !== undefined ? `Przycisk ${buttonIndex}` : 'Brak'}</span><button class="mapping-button" data-action="${action}">Przypisz</button>`; list.appendChild(row); } list.querySelectorAll('.mapping-button').forEach(button => { button.addEventListener('click', (e) => { const action = e.target.dataset.action; startMapping(action, e.target); }); }); }

    // === FUNKCJE POMOCNICZE I UI ===
    const debounce = (func, delay) => { let timeout; return function(...args) { const context = this; clearTimeout(timeout); timeout = setTimeout(() => func.apply(context, args), delay); }; };
    const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));
    function addLogMessage(message, level = 'info') { const logHistory = document.getElementById('log-history'); if (!logHistory) return; const timestamp = new Date().toLocaleTimeString(); let color = '#fff'; if (level === 'error') color = '#ff6347'; else if (level === 'warn') color = '#f7b731'; else if (level === 'success') color = '#a2f279'; const logEntry = document.createElement('div'); logEntry.style.color = color; logEntry.textContent = `[${timestamp}] ${message}`; logHistory.prepend(logEntry); while (logHistory.children.length > 200) { logHistory.removeChild(logHistory.lastChild); } }
    function clearLogs() { document.getElementById('log-history').innerHTML = ''; }
    function toggleAccordion(header) { const content = header.nextElementSibling; header.classList.toggle('active'); if (content.style.maxHeight && content.style.maxHeight !== '0px') { content.style.maxHeight = '0px'; content.style.padding = '0px 15px'; } else { content.style.maxHeight = content.scrollHeight + 30 + "px"; content.style.padding = '15px'; } }
    function updateAccordionHeight(content) { if (content && content.style.maxHeight !== '0px') { content.style.maxHeight = content.scrollHeight + 30 + 'px'; } }

    // === GLOWNA LOGIKA BLE ===
    async function connectBLE() { addLogMessage('[UI] Prosze o wybranie urzadzenia Bluetooth...', 'info'); try { bleDevice = await navigator.bluetooth.requestDevice({ filters: [{ name: 'RoboBala' }], optionalServices: [SERVICE_UUID] }); addLogMessage(`[UI] Laczenie z ${bleDevice.name}...`, 'info'); document.getElementById('connectBleBtn').disabled = true; document.getElementById('connectionText').textContent = 'Laczenie...'; bleDevice.addEventListener('gattserverdisconnected', onDisconnected); const server = await bleDevice.gatt.connect(); const service = await server.getPrimaryService(SERVICE_UUID); rxCharacteristic = await service.getCharacteristic(RX_UUID); txCharacteristic = await service.getCharacteristic(TX_UUID); await txCharacteristic.startNotifications(); txCharacteristic.addEventListener('characteristicvaluechanged', handleBleNotification); document.getElementById('connectionStatus').className = 'status-indicator status-ok'; document.getElementById('connectionText').textContent = 'Polaczony'; addLogMessage('[UI] Polaczono!', 'success');
        bleConnectionRetries = 0;
        if (bleRetryTimeout) {
            clearTimeout(bleRetryTimeout);
            bleRetryTimeout = null;
        }
            // NOWA ZMIANA: Automatyczne zadanie o stan po polaczeniu
            setTimeout(() => { 
                addLogMessage('[UI] Synchronizuje stan z robotem...', 'info'); 
                sendBleMessage({ type: 'request_full_config' }); 
            }, 500); 
        } catch (error) { addLogMessage(`[UI] Blad polaczenia BLE: ${error}`, 'error'); document.getElementById('connectionStatus').className = 'status-indicator status-error'; document.getElementById('connectionText').textContent = 'Blad polaczenia'; document.getElementById('connectBleBtn').disabled = false; } }
    function onDisconnected() {
        addLogMessage('[UI] Rozlaczono z robotem.', 'warn');
        document.getElementById('connectionStatus').className = 'status-indicator status-disconnected';
        document.getElementById('connectionText').textContent = 'Rozlaczony';
        ['balanceSwitch', 'holdPositionSwitch', 'speedModeSwitch'].forEach(id => {
            const el = document.getElementById(id);
            if (el) el.checked = false;
        });
        document.getElementById('connectBleBtn').disabled = false;
        rxCharacteristic = null;
        txCharacteristic = null;
        bleMessageQueue = [];
        isSendingBleMessage = false;

        if (bleConnectionRetries < MAX_BLE_RETRIES) {
            bleConnectionRetries++;
            addLogMessage(`[UI] Proba ponownego polaczenia ${bleConnectionRetries}/${MAX_BLE_RETRIES}...`, 'info');
            bleRetryTimeout = setTimeout(() => {
                if (!rxCharacteristic) {
                    connectBLE();
                }
            }, 2000 * bleConnectionRetries);
        } else {
            addLogMessage('[UI] Przekroczono limit prob polaczenia.', 'error');
            bleConnectionRetries = 0;
        }
    }
    function handleBleNotification(event) {
        const value = event.target.value;
        const decoder = new TextDecoder('utf-8');
        bleBuffer += decoder.decode(value);
        let newlineIndex;
        while ((newlineIndex = bleBuffer.indexOf('\n')) !== -1) {
            const line = bleBuffer.substring(0, newlineIndex).trim();
            bleBuffer = bleBuffer.substring(newlineIndex + 1);
            if (line) {
                try {
                    const data = JSON.parse(line);
                    if (data.type === 'chunk' && data.id !== undefined) {
                        let entry = bleChunks.get(data.id);
                        if (!entry) { entry = { total: data.total || 0, parts: new Map() }; bleChunks.set(data.id, entry); }
                        entry.parts.set(data.i, data.data || '');
                        entry.total = data.total || entry.total;
                        if (entry.parts.size === entry.total && entry.total > 0) {
                            let combined = '';
                            for (let i = 0; i < entry.total; i++) { combined += entry.parts.get(i) || ''; }
                            bleChunks.delete(data.id);
                            try {
                                const fullMsg = JSON.parse(combined);
                                processCompleteMessage(fullMsg);
                            } catch (e) {
                                addLogMessage(`[UI] Blad skladania chunkow: ${e}`, 'error');
                            }
                        }
                    } else {
                        processCompleteMessage(data);
                    }
                } catch (e) { addLogMessage(`[UI] Blad parsowania JSON: ${e}. Dane: ${line}`, 'error'); }
            }
        }
    }
    async function _sendRawBleMessage(message) { if (!rxCharacteristic) return; try { const encoder = new TextEncoder(); await rxCharacteristic.writeValueWithoutResponse(encoder.encode(JSON.stringify(message) + '\n')); } catch (error) { addLogMessage(`[UI] Blad wysylania danych BLE: ${error}`, 'error'); } }
    async function processBleQueue() { if (isSendingBleMessage || bleMessageQueue.length === 0 || !rxCharacteristic) { return; } isSendingBleMessage = true; const message = bleMessageQueue.shift(); await _sendRawBleMessage(message); setTimeout(() => { isSendingBleMessage = false; processBleQueue(); }, BLE_SEND_INTERVAL); }
    function sendBleMessage(message) { bleMessageQueue.push(message); processBleQueue(); }

    // === PRZETWARZANIE WIADOMOSCI Z ROBOTA ===
    function processCompleteMessage(data) {
        if (!data || !data.type) return;

        const previousState = lastKnownRobotState;
        if (data.robot_state) {
            lastKnownRobotState = data.robot_state;
        }
        
        if (isOptimizationSessionRunning && data.type === 'telemetry') {
            // Jeśli trwa automatyczny test balansu, zbieraj WSZYSTKIE pakiety telemetryczne
            if (isBalanceTestRunning) {
                // Dodajemy sztuczny obiekt 'trial', aby funkcja oceny działała poprawnie
                const enrichedData = {
                    ...data,
                    trial: { elapsed_ms: (Date.now() - (individualStartTime || Date.now())) }
                };
                telemetryForCurrentTest.push(enrichedData);
            } 
            // Dla innych (interaktywnych) testów, wymagaj znacznika 'trial' od robota
            else if (data.trial?.id) {
                telemetryForCurrentTest.push(data);
            }
        }

        if (isCharacterizationRunning && data.type === 'telemetry' && data.speed !== undefined) {
            telemetryForCharacterization.push({ speed: data.speed, time: (Date.now() - characterizationStartTime) / 1000.0 });
        }

        switch (data.type) {
            case 'telemetry':
                updateTelemetryUI(data);
                updateChart(data);
                if (isSequenceRunning) {
                    checkAndExecuteNextSequenceStep(previousState);
                }
                if (isZnTuningRunning && data.output !== undefined) {
                    document.getElementById('znKpTestVal').textContent = data.output.toFixed(2);
                }
                break;
            case 'full_config':
                if (data.states) {
                    isApplyingConfig = true; 
                    document.getElementById('balanceSwitch').checked = data.states.balancing;
                    document.getElementById('holdPositionSwitch').checked = data.states.holding_pos;
                    document.getElementById('speedModeSwitch').checked = data.states.speed_mode;
                    isApplyingConfig = false;
                }
                if (data.params) {
                    isApplyingConfig = true;
                    applyFullConfig(data.params);
                    isApplyingConfig = false;
                    addLogMessage('[UI] Konfiguracja i stan zsynchronizowane.', 'success');
                }
                break;
            case 'log':
                addLogMessage(`[ROBOT] ${data.message}`, data.level);
                break;
            case 'single_pwm_result':
                if (data.params) {
                    const p = data.params;
                    const inputId = `minPwm${p.motor.charAt(0).toUpperCase() + p.motor.slice(1)}${p.direction.charAt(0).toUpperCase() + p.direction.slice(1)}Input`;
                    document.getElementById(inputId).value = p.value;
                    addLogMessage(`[UI] Auto-strojenie dla ${p.motor} ${p.direction} zakonczone. Wynik: ${p.value}`, 'success');
                    const row = document.querySelector(`.manual-tune-row[data-motor="${p.motor}"][data-direction="${p.direction}"]`);
                    if (row) {
                        const autoBtn = row.querySelector('.auto-btn');
                        if (autoBtn) {
                            autoBtn.disabled = false;
                            autoBtn.textContent = 'Auto';
                        }
                    }
                }
                break;
            case 'zn_tuning_result':
                if (data.ku !== undefined && data.tu !== undefined) {
                    handleZnTuningResult(data.ku, data.tu);
                }
                break;
            case 'ack':
                break;
        }
    }
    function applyFullConfig(params) {
        for (const [inputId, snakeKey] of Object.entries(parameterMapping)) {
            const input = document.getElementById(inputId);
            if (input && params[snakeKey] !== undefined) {
                let value = params[snakeKey];
                if (['turn_factor', 'expo_joystick', 'joystick_sensitivity', 'joystick_deadzone', 'balance_pid_derivative_filter_alpha'].includes(snakeKey)) {
                     value = (value * 100);
                }
                input.value = value;
            }
        }
    }
    function updateTelemetryUI(data) {
        if (data.robot_state !== undefined) document.getElementById('robotStateVal').textContent = data.robot_state;
        if (data.pitch !== undefined) {
            document.getElementById('angleVal').textContent = data.pitch.toFixed(1) + ' \u00B0';
            document.getElementById('angleIndicator').style.transform = `rotate(${data.pitch}deg)`;
            currentPitch3D = data.pitch;
            document.getElementById('robot3d-pitch').textContent = data.pitch.toFixed(1) + '°';
        }
        if (data.yaw !== undefined) {
            document.getElementById('yawVal').textContent = data.yaw.toFixed(1) + ' \u00B0';
            currentYaw3D = data.yaw;
        }
        if (data.speed !== undefined) {
            document.getElementById('speedVal').textContent = parseFloat(data.speed).toFixed(0);
            const ppr = parseFloat(document.getElementById('encoderPprInput').value) || 820;
            const wheelRpm = (parseFloat(data.speed) / ppr) * 60;
            document.getElementById('robot3d-wheel-speed').textContent = wheelRpm.toFixed(0) + ' obr/min';
        }
        if (data.encoder_left !== undefined) {
            currentEncoderLeft = data.encoder_left;
            document.getElementById('encoderLeftVal').textContent = data.encoder_left;
        }
        if (data.encoder_right !== undefined) {
            currentEncoderRight = data.encoder_right;
            document.getElementById('encoderRightVal').textContent = data.encoder_right;
        }
        if (data.states && !isApplyingConfig) {
            isApplyingConfig = true;
            document.getElementById('balanceSwitch').checked = data.states.balancing;
            document.getElementById('holdPositionSwitch').checked = data.states.holding_pos;
            document.getElementById('speedModeSwitch').checked = data.states.speed_mode;
            isApplyingConfig = false;
        }
        const emergencyBanner = document.getElementById('emergency-banner');
        if (emergencyBanner) emergencyBanner.style.display = data.emergency_stop ? 'block' : 'none';
    }

    // === OBSLUGA WYKRESU ===
    const telemetryChart = new Chart(document.getElementById('telemetryChart'), { type: 'line', data: { labels: Array(100).fill(''), datasets: [] }, options: { animation: false, responsive: true, maintainAspectRatio: false, scales: { x: { display: false }, y: { type: 'linear', display: true, position: 'left', ticks: { color: '#61dafb' }, title: { display: true, text: 'Wartosc', color: '#61dafb' } } }, plugins: { legend: { labels: { color: '#fff' } } } } });
    function updateChart(data) {
        const chartData = telemetryChart.data;
        if (chartData.labels.length >= 100) chartData.labels.shift();
        chartData.labels.push('');
        for (const [key, value] of Object.entries(data)) {
            if (availableTelemetry[key] && value !== undefined) {
                let dataset = chartData.datasets.find(ds => ds.label === availableTelemetry[key].label);
                if (!dataset) continue;
                if (dataset.data.length >= 100) dataset.data.shift();
                dataset.data.push(value);
            }
        }
        chartData.datasets.forEach(ds => { if (ds.data.length < chartData.labels.length) { if (ds.data.length >= 100) ds.data.shift(); ds.data.push(null); } });
        telemetryChart.update('none');
    }
    function setupChartControls() {
        const container = document.getElementById('chartControls');
        container.innerHTML = '';
        Object.keys(availableTelemetry).forEach((key) => {
            const label = document.createElement('label'), checkbox = document.createElement('input');
            checkbox.type = 'checkbox'; checkbox.value = key; checkbox.checked = (key === 'pitch');
            checkbox.addEventListener('change', (e) => {
                const varName = e.target.value;
                if (e.target.checked) { if (!telemetryChart.data.datasets.find(ds => ds.label === availableTelemetry[varName].label)) { telemetryChart.data.datasets.push({ label: availableTelemetry[varName].label, data: Array(telemetryChart.data.labels.length).fill(null), borderColor: availableTelemetry[varName].color, fill: false, tension: 0.1, pointRadius: 0 }); } } else { const datasetIndex = telemetryChart.data.datasets.findIndex(ds => ds.label === availableTelemetry[varName].label); if (datasetIndex > -1) telemetryChart.data.datasets.splice(datasetIndex, 1); }
                telemetryChart.update();
            });
            label.appendChild(checkbox); label.append(` ${availableTelemetry[key].label}`); container.appendChild(label);
            if (checkbox.checked) checkbox.dispatchEvent(new Event('change'));
        });
    }

    // === ZARZADZANIE PRESETAMI ===
    function populatePresetSelect() { const select = document.getElementById('pidPresetSelect'); select.innerHTML = ''; for (const [index, preset] of Object.entries(builtInPresetsData)) { const option = document.createElement('option'); option.value = index; option.textContent = preset.name; select.appendChild(option); } for (let i = 0; i < localStorage.length; i++) { const key = localStorage.key(i); if (key.startsWith(CUSTOM_PRESET_PREFIX)) { const presetName = key.substring(CUSTOM_PRESET_PREFIX.length); const option = document.createElement('option'); option.value = key; option.textContent = `Wlasny: ${presetName}`; select.appendChild(option); } } }
    async function applySelectedPreset() { const select = document.getElementById('pidPresetSelect'); const selectedValue = select.value; let presetData; if (selectedValue.startsWith(CUSTOM_PRESET_PREFIX)) { presetData = JSON.parse(localStorage.getItem(selectedValue)); } else { presetData = builtInPresetsData[selectedValue]?.params; } if (presetData) { isApplyingConfig = true; for (const [key, value] of Object.entries(presetData)) { const input = document.getElementById(key); if (input) { input.value = value; } } isApplyingConfig = false; addLogMessage('[UI] Zastosowano wartosci presetu. Zapisz na robocie, aby wyslac.', 'info'); } }
    function saveCurrentAsPreset() { const presetName = prompt("Podaj nazwe dla nowego presetu:", ""); if (presetName && presetName.trim() !== "") { const presetData = {}; Object.keys(parameterMapping).forEach(inputId => { const input = document.getElementById(inputId); if (input) { presetData[inputId] = parseFloat(input.value); } }); localStorage.setItem(CUSTOM_PRESET_PREFIX + presetName.trim(), JSON.stringify(presetData)); addLogMessage(`[UI] Zapisano wlasny preset '${presetName.trim()}'.`, 'success'); populatePresetSelect(); } }
    function deleteSelectedPreset() { const select = document.getElementById('pidPresetSelect'); const selectedValue = select.value; if (!selectedValue.startsWith(CUSTOM_PRESET_PREFIX)) { addLogMessage('[UI] Nie mozna usunac wbudowanego presetu.', 'warn'); return; } if (confirm(`Czy na pewno chcesz usunac preset '${selectedValue.substring(CUSTOM_PRESET_PREFIX.length)}'?`)) { localStorage.removeItem(selectedValue); addLogMessage(`[UI] Usunieto preset.`, 'info'); populatePresetSelect(); } }

    // === OGOLNA OBSLUGA EVENTOW UI ===
    function setupNumericInputs() {
        document.querySelectorAll('.numeric-input-wrapper').forEach(wrapper => {
            const container = wrapper.closest('.setting-container') || wrapper.closest('.pwm-input-row');
            if (!container) return;
            const input = container.querySelector('input[type=number]');
            const minusBtn = wrapper.querySelector('button:first-child');
            const plusBtn = wrapper.querySelector('button:last-child');
            if (!input || !minusBtn || !plusBtn || input.disabled) return;
            const step = parseFloat(input.step) || 1;
            const isFloat = input.step.includes('.');
            const updateValue = (amount) => {
                let current = parseFloat(input.value);
                if (isNaN(current)) current = 0;
                let newValue = current + amount;
                if (isFloat) {
                    const dp = (step.toString().split('.')[1] || '').length;
                    newValue = parseFloat(newValue.toFixed(dp));
                }
                const min = parseFloat(input.min);
                const max = parseFloat(input.max);
                if (!isNaN(min)) newValue = Math.max(min, newValue);
                if (!isNaN(max)) newValue = Math.min(max, newValue);
                input.value = newValue;
                input.dispatchEvent(new Event('change', { bubbles: true }));
            };
            minusBtn.addEventListener('click', () => updateValue(-step));
            plusBtn.addEventListener('click', () => updateValue(step));
        });
    }
    function sendFullConfigToRobot() { const params = {}; for (const [inputId, snakeKey] of Object.entries(parameterMapping)) { const input = document.getElementById(inputId); if (input) { let value = parseFloat(input.value); if (['turn_factor', 'expo_joystick', 'joystick_sensitivity', 'joystick_deadzone', 'balance_pid_derivative_filter_alpha'].includes(snakeKey)) { value /= 100.0; } params[snakeKey] = value; } } addLogMessage('[UI] Wysylam pelna konfiguracje do robota...', 'info'); sendBleMessage({ type: 'full_config', params }); }
    function setupEventListeners() {
        const sendSingleParam = (inputId, value) => { if (isApplyingConfig) return; const snakeKey = parameterMapping[inputId]; if (snakeKey) { if (['turn_factor', 'expo_joystick', 'joystick_sensitivity', 'joystick_deadzone', 'balance_pid_derivative_filter_alpha'].includes(snakeKey)) { value /= 100.0; } sendBleMessage({ type: 'set_param', key: snakeKey, value: value }); } };
        const debouncedSendSingleParam = debounce(sendSingleParam, 400);
        document.querySelectorAll('.config-value').forEach(input => { input.addEventListener('change', (e) => { debouncedSendSingleParam(e.target.id, parseFloat(e.target.value)); }); });
        document.getElementById('joystickCanvas').addEventListener('mousedown', handleJoystickStart); document.addEventListener('mousemove', handleJoystickMove); document.addEventListener('mouseup', handleJoystickEnd); document.getElementById('joystickCanvas').addEventListener('touchstart', handleJoystickStart, { passive: false }); document.addEventListener('touchmove', handleJoystickMove, { passive: false }); document.addEventListener('touchend', handleJoystickEnd); document.addEventListener('touchcancel', handleJoystickEnd);
        document.getElementById('connectBleBtn').addEventListener('click', connectBLE);
        ['balanceSwitch', 'holdPositionSwitch', 'speedModeSwitch'].forEach(id => { 
            document.getElementById(id).addEventListener('change', (e) => { 
                if (isApplyingConfig) return; // IGNORUJ zmiane, jesli jest wynikiem synchronizacji
                const typeMap = { 'balanceSwitch': 'balance_toggle', 'holdPositionSwitch': 'hold_position_toggle', 'speedModeSwitch': 'speed_mode_toggle' }; 
                sendBleMessage({ type: typeMap[id], enabled: e.target.checked }); 
            }); 
        });
        const toolButtons = { 'resetZeroBtn': { type: 'reset_zero' }, 'trimPlusBtn': { type: 'adjust_zero', value: 1 }, 'trimMinusBtn': { type: 'adjust_zero', value: -1 }, 'resetEncodersBtn': { type: 'reset_encoders' }, 'emergencyStopBtn': { type: 'emergency_stop' } };
        for (const [id, msg] of Object.entries(toolButtons)) { document.getElementById(id)?.addEventListener('click', () => sendBleMessage(msg)); }

        document.getElementById('saveBtn').addEventListener('click', () => { if (confirm("Czy na pewno chcesz trwale zapisac biezaca konfiguracje znajdujaca sie na robocie do jego pamieci EEPROM?")) { sendBleMessage({ type: 'save_tunings' }); } });
        document.getElementById('loadBtn').addEventListener('click', () => { if (confirm("UWAGA! Spowoduje to nadpisanie wszystkich niezapisanych zmian w panelu. Kontynuowac?")) { sendBleMessage({ type: 'request_full_config' }); } });
        document.getElementById('calibrateMpuBtn')?.addEventListener('click', () => sendBleMessage({ type: 'calibrate_mpu' }));
        document.getElementById('calibrateZeroPointBtn')?.addEventListener('click', () => {
             if (confirm("Upewnij sie, ze robot stoi na idealnie plaskiej powierzchni. Robot bedzie balansowal przez 10 sekund w celu znalezienia dokladnego punktu rownowagi. Kontynuowac?")) {
                sendBleMessage({ type: 'calibrate_zero_point' });
             }
        });
        document.getElementById('applySelectedPresetBtn').addEventListener('click', applySelectedPreset); document.getElementById('saveCurrentAsPresetBtn').addEventListener('click', saveCurrentAsPreset); document.getElementById('deleteSelectedPresetBtn').addEventListener('click', deleteSelectedPreset);
        document.querySelectorAll('.help-icon').forEach(icon => { icon.addEventListener('click', (e) => { e.stopPropagation(); const container = icon.closest('.setting-container'); const helpText = container.querySelector('.help-text'); if (helpText) { helpText.classList.toggle('visible'); const accordionContent = container.closest('.accordion-content'); if (accordionContent) updateAccordionHeight(accordionContent); } }); });
    }
    function setupManualTuneButtons() { document.querySelectorAll('.manual-tune-row').forEach(row => { const motor = row.dataset.motor; const direction = row.dataset.direction; const input = row.querySelector('.tune-input'); const testBtn = row.querySelector('.test-btn'); const stopBtn = row.querySelector('.stop-btn'); const autoBtn = row.querySelector('.auto-btn'); testBtn.addEventListener('click', () => { sendBleMessage({ type: 'manual_tune_motor', motor, direction, pwm: parseInt(input.value) }); }); stopBtn.addEventListener('click', () => { sendBleMessage({ type: 'manual_tune_motor', motor, direction, pwm: 0 }); }); autoBtn.addEventListener('click', (e) => { if (confirm("UWAGA! Upewnij sie, ze robot jest uniesiony, a kola moga sie swobodnie obracac. Kontynuowac?")) { const startValue = parseInt(document.getElementById('pwmTuneStartInput').value); sendBleMessage({ type: 'autotune_single_pwm', motor, direction, start_pwm: startValue }); e.target.disabled = true; e.target.textContent = 'Szukanie...'; addLogMessage(`[UI] Rozpoczynam auto-strojenie dla ${motor} ${direction}...`, 'info'); } }); }); document.getElementById('manualTuneStopAll').addEventListener('click', () => { sendBleMessage({ type: 'manual_tune_stop_all' }); }); }
    function setupGamepadMappingModal() { document.getElementById('open-gamepad-modal-btn').addEventListener('click', () => { document.getElementById('gamepad-mapping-modal').style.display = 'flex'; }); document.getElementById('close-modal-btn').addEventListener('click', () => { document.getElementById('gamepad-mapping-modal').style.display = 'none'; }); }
    function flashElement(element) { if (!element) return; const target = element.tagName === 'INPUT' ? element.closest('.switch') || element.closest('.control-row') || element : element; target.classList.add('gamepad-flash'); setTimeout(() => target.classList.remove('gamepad-flash'), 300); }
    function loadGamepadMappings() { const saved = localStorage.getItem(GAMEPAD_MAPPING_KEY); gamepadMappings = saved ? JSON.parse(saved) : {}; }
    function saveGamepadMappings() { localStorage.setItem(GAMEPAD_MAPPING_KEY, JSON.stringify(gamepadMappings)); }

    // === STEROWANIE AUTONOMICZNE (D-PAD I SEKWENCJE) ===
    function setupDpadControls() { document.querySelectorAll('.dpad-btn').forEach(btn => { btn.addEventListener('click', (e) => { const action = e.currentTarget.dataset.dpad; if (action === 'up') sendBleMessage({ type: 'execute_move', distance_cm: parseFloat(document.getElementById('dpadDistInput').value) }); else if (action === 'down') sendBleMessage({ type: 'execute_move', distance_cm: -parseFloat(document.getElementById('dpadDistInput').value) }); else if (action === 'left') sendBleMessage({ type: 'execute_rotate', angle_deg: -parseFloat(document.getElementById('dpadAngleInput').value) }); else if (action === 'right') sendBleMessage({ type: 'execute_rotate', angle_deg: parseFloat(document.getElementById('dpadAngleInput').value) }); else if (action === 'stop') sendBleMessage({ type: 'command_stop' }); }); }); }
    function setupSequenceControls() { document.getElementById('add-sequence-step-btn').addEventListener('click', addSequenceStep); document.getElementById('run-sequence-btn').addEventListener('click', runSequence); document.getElementById('stop-sequence-btn').addEventListener('click', stopSequenceExecution); document.getElementById('clear-sequence-btn').addEventListener('click', clearSequence); }
    function addSequenceStep() { const list = document.getElementById('sequence-list'); if (list.children.length >= MAX_SEQUENCE_STEPS) return; const stepDiv = document.createElement('div'); stepDiv.className = 'sequence-step'; stepDiv.innerHTML = ` <select class="sequence-type"> <option value="move_fwd">Przod (cm)</option><option value="move_bwd">Tyl (cm)</option> <option value="rotate_r">Obrot Prawo (st.)</option><option value="rotate_l">Obrot Lewo (st.)</option> </select> <input type="number" class="sequence-value" value="20"> <button class="remove-step-btn">&times;</button> `; list.appendChild(stepDiv); updateAccordionHeight(list.closest('.accordion-content')); stepDiv.querySelector('.remove-step-btn').addEventListener('click', () => { stepDiv.remove(); updateAccordionHeight(list.closest('.accordion-content')); }); }
    function runSequence() { if (isSequenceRunning) return; if (lastKnownRobotState !== 'TRZYMA_POZYCJE' && lastKnownRobotState !== 'BALANSUJE') { addLogMessage(`[UI] Nie mozna rozpoczac sekwencji. Robot w stanie '${lastKnownRobotState}'.`, 'error'); return; } const steps = document.querySelectorAll('.sequence-step'); if (steps.length === 0) return; isSequenceRunning = true; currentSequenceStep = 0; updateSequenceUI(); addLogMessage(`[UI] Rozpoczeto sekwencje z ${steps.length} krokow.`, 'info'); executeNextSequenceStep(); }
    function stopSequenceExecution() { if (!isSequenceRunning) return; isSequenceRunning = false; sendBleMessage({ type: 'command_stop' }); updateSequenceUI(); addLogMessage('[UI] Sekwencja zatrzymana.', 'warn'); }
    function clearSequence() { if (isSequenceRunning) stopSequenceExecution(); const list = document.getElementById('sequence-list'); list.innerHTML = ''; updateAccordionHeight(list.closest('.accordion-content')); }
    function updateSequenceUI() { document.querySelectorAll('.sequence-step').forEach((step, index) => { step.classList.toggle('executing', isSequenceRunning && index === currentSequenceStep); }); document.getElementById('run-sequence-btn').disabled = isSequenceRunning; document.getElementById('add-sequence-step-btn').disabled = isSequenceRunning; document.getElementById('clear-sequence-btn').disabled = isSequenceRunning; document.getElementById('stop-sequence-btn').disabled = !isSequenceRunning; }
    function checkAndExecuteNextSequenceStep(previousState) {
        const wasWorking = ['RUCH_AUTONOMICZNY', 'OBROT_AUTONOMICZNY'].includes(previousState);
        const isReady = ['TRZYMA_POZYCJE', 'BALANSUJE'].includes(lastKnownRobotState);
        if (isSequenceRunning && wasWorking && isReady) {
            addLogMessage(`[UI] Krok ${currentSequenceStep + 1} zakonczony.`, 'info');
            currentSequenceStep++;
            executeNextSequenceStep();
        }
    }
    function executeNextSequenceStep() { const steps = document.querySelectorAll('.sequence-step'); if (!isSequenceRunning || currentSequenceStep >= steps.length) { if (isSequenceRunning) { isSequenceRunning = false; addLogMessage('[UI] Sekwencja ukonczona.', 'success'); } updateSequenceUI(); return; } updateSequenceUI(); const stepNode = steps[currentSequenceStep]; const type = stepNode.querySelector('.sequence-type').value; const value = parseFloat(stepNode.querySelector('.sequence-value').value); let command = {}; switch (type) { case 'move_fwd': command = { type: 'execute_move', distance_cm: value }; break; case 'move_bwd': command = { type: 'execute_move', distance_cm: -value }; break; case 'rotate_r': command = { type: 'execute_rotate', angle_deg: value }; break; case 'rotate_l': command = { type: 'execute_rotate', angle_deg: -value }; break; } addLogMessage(`[UI] Wysylanie kroku ${currentSequenceStep + 1}/${steps.length}: ${command.type}(${value}).`, 'info'); sendBleMessage(command); }

    // --- SEKCJA STROJENIA KROK 1: ZIEGLER-NICHOLS ---
    let isZnTuningRunning = false;
    let znResults = { ku: 0, tu: 0 };
    function setupZnTuningControls() {
        const actionBtn = document.getElementById('znTuningActionBtn');
        const cancelBtn = document.getElementById('znTuningCancelBtn');
        const applyBtn = document.getElementById('applyZnResultsBtn');
        actionBtn.addEventListener('click', () => { if (!isZnTuningRunning) { if (lastKnownRobotState !== 'BALANSUJE' && lastKnownRobotState !== 'TRZYMA_POZYCJE') { addLogMessage('[UI] BLAD: Aby rozpoczac strojenie, robot musi byc w stanie balansu.', 'error'); return; } if (confirm("UWAGA! Ta procedura wprowadzi robota w kontrolowane oscylacje. Upewnij sie, ze ma wystarczajaco duzo miejsca. Kontynuowac?")) { startZnTuning(); } } });
        cancelBtn.addEventListener('click', () => { if (isZnTuningRunning) { cancelZnTuning(); } });
        applyBtn.addEventListener('click', () => { if (znResults.ku > 0 && znResults.tu > 0) { applyZnResults(); } });
    }
    function startZnTuning() { isZnTuningRunning = true; document.getElementById('znStatusText').textContent = "Rozpoczynanie..."; document.getElementById('znTuningActionBtn').disabled = true; document.getElementById('znTuningCancelBtn').style.display = 'block'; document.getElementById('znResultPanel').style.display = 'none'; addLogMessage('[UI] Wysylam polecenie rozpoczecia strojenia Z-N do robota...', 'info'); sendBleMessage({ type: 'start_zn_tuning' }); }
    function cancelZnTuning() { isZnTuningRunning = false; document.getElementById('znStatusText').textContent = "Anulowanie..."; addLogMessage('[UI] Wysylam polecenie anulowania strojenia do robota...', 'warn'); sendBleMessage({ type: 'cancel_tuning' }); resetZnTuningUI(); }
    function resetZnTuningUI() { isZnTuningRunning = false; document.getElementById('znStatusText').textContent = "Bezczynny"; document.getElementById('znKpTestVal').textContent = "---"; document.getElementById('znTuningActionBtn').disabled = false; document.getElementById('znTuningActionBtn').textContent = "Rozpocznij Odkrywanie"; document.getElementById('znTuningCancelBtn').style.display = 'none'; }
    function handleZnTuningResult(ku, tu) { addLogMessage(`[UI] Otrzymano wynik strojenia Z-N: Ku=${ku.toFixed(4)}, Tu=${tu.toFixed(4)}`, 'success'); resetZnTuningUI(); znResults = { ku, tu }; const resultPanel = document.getElementById('znResultPanel'); resultPanel.style.display = 'block'; const kp = 0.6 * ku; const kd = kp * tu / 8; document.getElementById('znKuResult').textContent = ku.toFixed(4); document.getElementById('znTuResult').textContent = tu.toFixed(4) + " s"; document.getElementById('znKpSuggest').textContent = kp.toFixed(4); document.getElementById('znKdSuggest').textContent = kd.toFixed(4); updateAccordionHeight(resultPanel.closest('.accordion-content')); }
    function applyZnResults() { const { ku, tu } = znResults; if (ku <= 0 || tu <= 0) return; const kp = 0.6 * ku; const kd = kp * tu / 8; isApplyingConfig = true; document.getElementById('balanceKpInput').value = kp.toFixed(4); document.getElementById('balanceKiInput').value = 0.0; document.getElementById('balanceKdInput').value = kd.toFixed(4); isApplyingConfig = false; document.getElementById('balanceKpInput').dispatchEvent(new Event('change', { bubbles: true })); document.getElementById('balanceKiInput').dispatchEvent(new Event('change', { bubbles: true })); document.getElementById('balanceKdInput').dispatchEvent(new Event('change', { bubbles: true })); addLogMessage('[UI] Zastosowano sugerowane wartosci Kp i Kd. Ki ustawiono na 0.', 'info'); }

    // --- SEKCJA STROJENIA KROK 2: OPTYMALIZACJA I TESTY (GA) ---
    let isOptimizationSessionRunning = false;
    let currentOptimizationMode = 'balance';
    let currentGeneration = 0;
    let currentIndividualIndex = -1;
    let currentPopulation = [];
    let evaluatedPopulation = [];
    let bestOverallScore = -Infinity;
    let bestOverallPhenotype = null;
    let finalBestPhenotypeFromGA = null;
    let telemetryForCurrentTest = [];
    let safeStartParams = {};
    let trialTimeout = null;
    let isBalanceTestRunning = false;
    let individualStartTime = 0;
    
    function setupAutoTestEventListeners() {
        document.querySelectorAll('input[name="autotest-type"]').forEach(radio => radio.addEventListener('change', renderAutotestOptions));
        document.getElementById('autotestActionBtn').addEventListener('click', handleAutotestAction);
        document.getElementById('ga_stop_btn').addEventListener('click', cancelOptimizationSession);
        document.querySelectorAll('.weight-input').forEach(input => input.addEventListener('change', updateWeightsBudget));
        document.getElementById('applyGaResultsBtn').addEventListener('click', applyGaResults);
        updateWeightsBudget();
    }
    
    function handleAutotestAction() {
        if (isOptimizationSessionRunning) {
            if(currentOptimizationMode !== 'balance') {
                testNextIndividualInteractive();
            }
        } else {
            startOptimizationSession();
        }
    }

    async function startOptimizationSession() {
        if (lastKnownRobotState !== 'BALANSUJE' && lastKnownRobotState !== 'TRZYMA_POZYCJE') {
            addLogMessage(`[GA] Blad: Robot musi byc w stanie 'BALANSUJE', a jest w '${lastKnownRobotState}'.`, 'error');
            return;
        }

        isOptimizationSessionRunning = true;
        currentOptimizationMode = document.querySelector('input[name="autotest-type"]:checked').value;
        currentGeneration = 1;
        currentIndividualIndex = -1;
        bestOverallScore = -Infinity;
        bestOverallPhenotype = null;
        finalBestPhenotypeFromGA = null;
        evaluatedPopulation = [];
        
        if (currentOptimizationMode === 'balance') {
            safeStartParams = { kp_b: parseFloat(document.getElementById('balanceKpInput').value), ki_b: 0, kd_b: parseFloat(document.getElementById('balanceKdInput').value) };
        } else if (currentOptimizationMode === 'speed') {
            safeStartParams = { kp_s: parseFloat(document.getElementById('speedKpInput').value), ki_s: parseFloat(document.getElementById('speedKiInput').value), kd_s: parseFloat(document.getElementById('speedKdInput').value) };
        } else if (currentOptimizationMode === 'position') {
            safeStartParams = { kp_p: parseFloat(document.getElementById('positionKpInput').value), ki_p: parseFloat(document.getElementById('positionKiInput').value), kd_p: parseFloat(document.getElementById('positionKdInput').value) };
        }
        
        const populationSize = parseInt(document.getElementById('gaPopulationInput').value);
        currentPopulation = createInitialPopulation(populationSize);

        addLogMessage(`[GA] Rozpoczeto sesje strojenia dla petli: ${currentOptimizationMode}.`, 'success');
        document.getElementById('ga_stop_btn').style.display = 'inline-block';
        document.getElementById('autotestActionBtn').disabled = true;
        document.getElementById('gaResultsPanel').style.display = 'none';
        updateStatus('Inicjalizacja...', 0);
        document.getElementById('statusGeneration').textContent = `1 / ${parseInt(document.getElementById('gaGenerationsInput').value)}`;

        if (currentOptimizationMode === 'balance') {
            document.getElementById('autotestActionBtn').style.display = 'none';
            runFullBalanceGA();
        } else {
            document.getElementById('autotestActionBtn').textContent = `Testuj Osobnika 1/${populationSize}`;
            document.getElementById('autotestActionBtn').disabled = false;
            updateStatus(`Gotowy do testu osobnika 1`, 0);
        }
    }
    
    async function runFullBalanceGA() {
        addLogMessage(`[GA-Auto] Rozpoczeto automatyczna optymalizacje petli balansu.`, 'info');
        isBalanceTestRunning = true;
        const totalGenerations = parseInt(document.getElementById('gaGenerationsInput').value);

        for (let gen = 0; gen < totalGenerations; gen++) {
            if (!isOptimizationSessionRunning) break;
            currentGeneration = gen + 1;
            document.getElementById('statusGeneration').textContent = `${currentGeneration} / ${totalGenerations}`;
            evaluatedPopulation = [];
            
            for (let ind = 0; ind < currentPopulation.length; ind++) {
                if (!isOptimizationSessionRunning) break;
                
                await waitForRobotIdle();
                if (!isOptimizationSessionRunning) break;

                const individual = currentPopulation[ind];
                telemetryForCurrentTest = [];
                individualStartTime = Date.now();

                updateStatus(`Testowanie osobnika ${ind + 1}/${currentPopulation.length}`, (ind / currentPopulation.length) * 100);
                
                updateCurrentPhenotypeStatus(individual);

                await applyPhenotype(individual);
                await sleep(500);
                
                const testDuration = parseFloat(document.getElementById('testDurationInput').value) * 1000;
                await sleep(testDuration);

                processTestResult(individual);
            }
             if (!isOptimizationSessionRunning) break;
            
            createNewGeneration();
        }
        
        finishOptimizationSession();
    }

    async function testNextIndividualInteractive() {
        if (!isOptimizationSessionRunning || currentIndividualIndex >= currentPopulation.length - 1) return;
        
        await waitForRobotIdle();

        currentIndividualIndex++;
        const individual = currentPopulation[currentIndividualIndex];
        telemetryForCurrentTest = [];
        
        addLogMessage(`[GA-Inter] Przygotowanie do testu osobnika ${currentIndividualIndex + 1}...`);
        document.getElementById('autotestActionBtn').disabled = true;
        updateStatus(`Testowanie osobnika ${currentIndividualIndex + 1}...`, (currentIndividualIndex / currentPopulation.length) * 100);

        updateCurrentPhenotypeStatus(individual);

        await applyPhenotype(individual);
        await sleep(300);

        if (currentOptimizationMode === 'speed') {
            const distance = parseFloat(document.getElementById('speedTestDistanceInput').value);
            const speed = parseFloat(document.getElementById('speedTestSpeedInput').value);
            sendBleMessage({ type: 'execute_speed_test_run', distance_cm: distance, speed_cmps: speed });
        } else if (currentOptimizationMode === 'position') {
            const impulse = parseInt(document.getElementById('positionTestImpulseInput').value);
            sendBleMessage({ type: 'execute_position_test_impulse', impulse_power: impulse });
        }

        const trialTime = parseFloat(document.getElementById('testDurationInput').value) * 1000;
        trialTimeout = setTimeout(handleInteractiveTrialEnd, trialTime + 1000); // +1s bufor
    }
    
    async function handleInteractiveTrialEnd() {
        if (!isOptimizationSessionRunning) return;
        addLogMessage('[GA-Inter] Czas na zbieranie danych uplynal. Zatrzymuje robota i analizuje...', 'info');
        sendBleMessage({ type: 'command_stop' });
        
        await waitForRobotIdle();

        processTestResult(currentPopulation[currentIndividualIndex]);

        const populationSize = currentPopulation.length;
        if (currentIndividualIndex < populationSize - 1) {
            document.getElementById('autotestActionBtn').textContent = `Testuj Osobnika ${currentIndividualIndex + 2}/${populationSize}`;
            document.getElementById('autotestActionBtn').disabled = false;
            updateStatus('Gotowy na nastepna probe');
        } else {
            const totalGenerations = parseInt(document.getElementById('gaGenerationsInput').value);
            if(currentGeneration < totalGenerations){
                 document.getElementById('autotestActionBtn').textContent = `Rozpocznij Pokolenie ${currentGeneration + 1}`;
                 document.getElementById('autotestActionBtn').disabled = false;
                 document.getElementById('autotestActionBtn').onclick = () => {
                     createNewGeneration();
                     currentIndividualIndex = -1;
                     document.getElementById('statusGeneration').textContent = `${currentGeneration} / ${totalGenerations}`;
                     document.getElementById('autotestActionBtn').textContent = `Testuj Osobnika 1/${populationSize}`;
                     document.getElementById('autotestActionBtn').onclick = handleAutotestAction;
                     handleAutotestAction();
                 };
                 updateStatus('Pokolenie zakonczone');
            } else {
                finishOptimizationSession();
            }
        }
    }
    
    function processTestResult(individual) {
        let score = 0.0;
        if (telemetryForCurrentTest.length > 10) {
            if (currentOptimizationMode === 'balance') {
                 const weights = { stability: parseFloat(document.getElementById('weightStability').value), stillness: parseFloat(document.getElementById('weightStillness').value), overshoot: parseFloat(document.getElementById('weightOvershoot').value), effort: parseFloat(document.getElementById('weightEffort').value) };
                score = evaluateBalanceFitness(telemetryForCurrentTest, weights);
            } else if (currentOptimizationMode === 'speed') {
                score = evaluateSpeedFitness(telemetryForCurrentTest);
            } else if (currentOptimizationMode === 'position') {
                score = evaluatePositionFitness(telemetryForCurrentTest);
            }
        }
        
        individual.score = score;
        evaluatedPopulation.push(individual);
        updateScores(score, individual);
    }

    function cancelOptimizationSession() {
        if (!isOptimizationSessionRunning) return;
        isOptimizationSessionRunning = false;
        isBalanceTestRunning = false;
        clearTimeout(trialTimeout);
        applyPhenotype(safeStartParams);
        addLogMessage('[GA] Sesja strojenia anulowana przez uzytkownika.', 'warn');
        resetGAUI();
    }
    
    function finishOptimizationSession() {
        if (!isOptimizationSessionRunning) return;
        isOptimizationSessionRunning = false;
        isBalanceTestRunning = false;
        finalBestPhenotypeFromGA = bestOverallPhenotype;
        addLogMessage('[GA] Sesja optymalizacji zakonczona!', 'success');
        
        if(finalBestPhenotypeFromGA){
            addLogMessage(`[GA] Najlepsze znalezione parametry zapisane.`, 'info');
            displayFinalGAResults();
        }
        
        resetGAUI();
        applyPhenotype(safeStartParams);
    }

    function resetGAUI() {
        document.getElementById('ga_stop_btn').style.display = 'none';
        document.getElementById('autotestActionBtn').style.display = 'inline-block';
        document.getElementById('autotestActionBtn').disabled = false;
        document.getElementById('autotestActionBtn').onclick = handleAutotestAction;
        renderAutotestOptions();
        updateStatus('Bezczynny', 0);
        document.getElementById('statusGeneration').textContent = '---';
        document.getElementById('statusBestScore').textContent = '---';
        document.getElementById('statusLastScore').textContent = '---';
        document.getElementById('statusBestPhenotype').textContent = '---';
        document.getElementById('statusCurrentPhenotype').textContent = '---';
    }
    
    async function waitForRobotIdle() {
        if (['BALANSUJE', 'TRZYMA_POZYCJE'].includes(lastKnownRobotState)) {
            return;
        }
        addLogMessage('[GA] Oczekiwanie na ustabilizowanie sie robota...', 'info');
        while(!['BALANSUJE', 'TRZYMA_POZYCJE'].includes(lastKnownRobotState)) {
            if(!isOptimizationSessionRunning) return;
            await sleep(200);
        }
        addLogMessage('[GA] Robot jest stabilny. Kontynuacja...', 'success');
        await sleep(500);
    }

    function updateStatus(stateText, progress = -1) {
        document.getElementById('statusStateText').textContent = stateText;
        if(progress !== -1) {
            document.getElementById('statusProgressBar').value = progress;
            document.getElementById('statusProgressText').textContent = `${stateText} (${progress.toFixed(0)}%)`;
        }
    }

    function updateCurrentPhenotypeStatus(phenotype) {
        let phenotypeText = '';
        if (currentOptimizationMode === 'balance') phenotypeText = `Kp: ${phenotype.kp_b.toFixed(3)}, Kd: ${phenotype.kd_b.toFixed(3)}`;
        else if (currentOptimizationMode === 'speed') phenotypeText = `Kp: ${phenotype.kp_s.toFixed(3)}, Ki: ${phenotype.ki_s.toFixed(3)}, Kd: ${phenotype.kd_s.toFixed(3)}`;
        else if (currentOptimizationMode === 'position') phenotypeText = `Kp: ${phenotype.kp_p.toFixed(3)}, Ki: ${phenotype.ki_p.toFixed(3)}, Kd: ${phenotype.kd_p.toFixed(3)}`;
        document.getElementById('statusCurrentPhenotype').textContent = phenotypeText;
    }
    
    function updateScores(lastScore, phenotype) {
        document.getElementById('statusLastScore').textContent = lastScore.toFixed(4);
        if (lastScore > bestOverallScore) {
            bestOverallScore = lastScore;
            bestOverallPhenotype = phenotype;
            document.getElementById('statusBestScore').textContent = bestOverallScore.toFixed(4);
            
            let phenotypeText = '';
            if (currentOptimizationMode === 'balance') phenotypeText = `Kp: ${phenotype.kp_b.toFixed(3)}, Kd: ${phenotype.kd_b.toFixed(3)}`;
            else if (currentOptimizationMode === 'speed') phenotypeText = `Kp: ${phenotype.kp_s.toFixed(3)}, Ki: ${phenotype.ki_s.toFixed(3)}, Kd: ${phenotype.kd_s.toFixed(3)}`;
            else if (currentOptimizationMode === 'position') phenotypeText = `Kp: ${phenotype.kp_p.toFixed(3)}, Ki: ${phenotype.ki_p.toFixed(3)}, Kd: ${phenotype.kd_p.toFixed(3)}`;
            document.getElementById('statusBestPhenotype').textContent = phenotypeText;
        }
    }

    function createInitialPopulation(size) {
        let population = [];
        let baseParams = {};
        
        switch (currentOptimizationMode) {
            case 'balance':
                baseParams = { kp_b: parseFloat(document.getElementById('balanceKpInput').value), ki_b: 0, kd_b: parseFloat(document.getElementById('balanceKdInput').value) };
                population.push(baseParams);
                for (let i = 1; i < size; i++) population.push({ kp_b: Math.max(0, baseParams.kp_b * (1 + (Math.random() - 0.5) * 0.4)), ki_b: 0, kd_b: Math.max(0, baseParams.kd_b * (1 + (Math.random() - 0.5) * 0.4)) });
                break;
            case 'speed':
                baseParams = { kp_s: parseFloat(document.getElementById('speedKpInput').value), ki_s: parseFloat(document.getElementById('speedKiInput').value), kd_s: parseFloat(document.getElementById('speedKdInput').value) };
                population.push(baseParams);
                for (let i = 1; i < size; i++) population.push({ kp_s: Math.max(0, baseParams.kp_s * (1 + (Math.random() - 0.5) * 0.8)), ki_s: Math.max(0, baseParams.ki_s * (1 + (Math.random() - 0.5) * 0.8)), kd_s: Math.max(0, baseParams.kd_s * (1 + (Math.random() - 0.5) * 0.8)) });
                break;
            case 'position':
                baseParams = { kp_p: parseFloat(document.getElementById('positionKpInput').value), ki_p: parseFloat(document.getElementById('positionKiInput').value), kd_p: parseFloat(document.getElementById('positionKdInput').value) };
                population.push(baseParams);
                for (let i = 1; i < size; i++) population.push({ kp_p: Math.max(0, baseParams.kp_p * (1 + (Math.random() - 0.5) * 0.8)), ki_p: Math.max(0, baseParams.ki_p * (1 + (Math.random() - 0.5) * 0.8)), kd_p: Math.max(0, baseParams.kd_p * (1 + (Math.random() - 0.5) * 0.8)) });
                break;
        }
        return population;
    }

    function createNewGeneration() {
        addLogMessage(`[GA] Tworzenie nowej generacji ${currentGeneration + 1}...`);
        const populationSize = currentPopulation.length;
        evaluatedPopulation.sort((a,b) => b.score - a.score);
        
        let newPopulation = [];
        const eliteSize = Math.max(1, Math.floor(populationSize * 0.2));
        for(let i=0; i < eliteSize; i++) newPopulation.push(evaluatedPopulation[i]);
        
        while(newPopulation.length < populationSize) {
            let parent = evaluatedPopulation[Math.floor(Math.random() * (populationSize / 2))];
            let child = {};
            
            switch (currentOptimizationMode) {
                case 'balance':
                    child = { kp_b: Math.max(0, parent.kp_b * (1 + (Math.random() - 0.5) * 0.2)), ki_b: 0, kd_b: Math.max(0, parent.kd_b * (1 + (Math.random() - 0.5) * 0.2)) };
                    break;
                case 'speed':
                    child = { kp_s: Math.max(0, parent.kp_s * (1 + (Math.random() - 0.5) * 0.5)), ki_s: Math.max(0, parent.ki_s * (1 + (Math.random() - 0.5) * 0.5)), kd_s: Math.max(0, parent.kd_s * (1 + (Math.random() - 0.5) * 0.5)) };
                    break;
                case 'position':
                     child = { kp_p: Math.max(0, parent.kp_p * (1 + (Math.random() - 0.5) * 0.5)), ki_p: Math.max(0, parent.ki_p * (1 + (Math.random() - 0.5) * 0.5)), kd_p: Math.max(0, parent.kd_p * (1 + (Math.random() - 0.5) * 0.5)) };
                    break;
            }
            newPopulation.push(child);
        }
        
        currentPopulation = newPopulation;
        currentGeneration++;
    }

    // --- FUNKCJE OCENY (FITNESS) ---
    function evaluateBalanceFitness(telemetryData, weights) {
        if (!telemetryData || telemetryData.length < 20) return 0.0;

        const firstSampleTime = telemetryData[0].trial.elapsed_ms;
        const lastSampleTime = telemetryData[telemetryData.length - 1].trial.elapsed_ms;
        const testDuration = (lastSampleTime - firstSampleTime) / 1000.0;

        if (testDuration < 1.0) return 0.0;

        const MAX_ACCEPTABLE_ITAE = 50.0;
        const MAX_ACCEPTABLE_STD_DEV = 0.75;
        const MAX_ACCEPTABLE_OVERSHOOT = 5.0;
        const MAX_ACCEPTABLE_ZERO_CROSSINGS_PER_SEC = 10;
        const CRITICAL_PITCH_ERROR = 15.0;
        
        let itae = 0, maxOvershoot = 0, zeroCrossings = 0;
        let lastTime = telemetryData[0].trial.elapsed_ms / 1000.0;
        const pitches = telemetryData.map(d => d.pitch);
        const outputs = telemetryData.map(d => d.output);

        for (let i = 1; i < telemetryData.length; i++) {
            const currentTime = telemetryData[i].trial.elapsed_ms / 1000.0;
            const dt = currentTime - lastTime;
            if(dt <= 0) continue;
            itae += Math.abs(pitches[i]) * currentTime * dt;
            if (pitches[i-1] * pitches[i] < 0) zeroCrossings++;
            lastTime = currentTime;
        }

        maxOvershoot = Math.max(...pitches.map(p => Math.abs(p)));
        if (maxOvershoot > CRITICAL_PITCH_ERROR) {
            addLogMessage(`[GA-Ocena] DYSKWALIFIKACJA: Przekroczono krytyczny kat (${maxOvershoot.toFixed(2)} st.)`, "warn");
            return 0.0;
        }

        const meanPitch = pitches.reduce((a, b) => a + b, 0) / pitches.length;
        const stdDev = Math.sqrt(pitches.map(p => Math.pow(p - meanPitch, 2)).reduce((a, b) => a + b, 0) / pitches.length);
        const rmsEffort = Math.sqrt(outputs.map(o => o*o).reduce((a, b) => a + b, 0) / outputs.length);

        const clamp = (num, min, max) => Math.min(Math.max(num, min), max);
        
        const stabilityScore = 1.0 - clamp(itae / MAX_ACCEPTABLE_ITAE, 0, 1);
        const stillnessScore = (1.0 - clamp(stdDev / MAX_ACCEPTABLE_STD_DEV, 0, 1)) * 0.7 + (1.0 - clamp((zeroCrossings/testDuration) / MAX_ACCEPTABLE_ZERO_CROSSINGS_PER_SEC, 0, 1)) * 0.3;
        const overshootScore = 1.0 - clamp(maxOvershoot / MAX_ACCEPTABLE_OVERSHOOT, 0, 1);
        const effortScore = 1.0 - clamp(rmsEffort / 1023, 0, 1);

        const totalWeight = weights.stability + weights.stillness + weights.overshoot + weights.effort;
        if(totalWeight === 0) return 0.5;

        const finalScore = (weights.stability * stabilityScore + weights.stillness * stillnessScore + weights.overshoot * overshootScore + weights.effort * effortScore) / totalWeight;
        return finalScore;
    }
    
    function evaluateSpeedFitness(telemetryData) {
        if (telemetryData.length < 20) return 0.0;
        const ppr = parseFloat(document.getElementById('encoderPprInput').value) || 820;
        const wheelDiameter = parseFloat(document.getElementById('wheelDiameterInput').value) || 8.2;
        const impulsesPerCm = ppr / (Math.PI * wheelDiameter);
        const targetSpeedCmps = parseFloat(document.getElementById('speedTestSpeedInput').value);
        const targetSpeedImps = targetSpeedCmps * impulsesPerCm;
        const targetDistanceCm = parseFloat(document.getElementById('speedTestDistanceInput').value);
        const targetDistanceImpulses = targetDistanceCm * impulsesPerCm;

        let speedErrorSumSq = 0, maxOvershoot = 0;
        const startEncoderAvg = (telemetryData[0].encoder_left + telemetryData[0].encoder_right) / 2;
        const endEncoderAvg = (telemetryData[telemetryData.length-1].encoder_left + telemetryData[telemetryData.length-1].encoder_right) / 2;
        const actualDistanceImpulses = Math.abs(endEncoderAvg - startEncoderAvg);
        const positionError = Math.abs(targetDistanceImpulses - actualDistanceImpulses);

        for (const data of telemetryData) {
            const currentSpeed = Math.abs(data.speed);
            if (currentSpeed > 0.1 * targetSpeedImps) speedErrorSumSq += Math.pow(targetSpeedImps - currentSpeed, 2);
            if (currentSpeed > targetSpeedImps) {
                const overshoot = currentSpeed - targetSpeedImps;
                if (overshoot > maxOvershoot) maxOvershoot = overshoot;
            }
        }
        
        const avgSpeedError = Math.sqrt(speedErrorSumSq / telemetryData.length);
        
        const speedPenalty = Math.min(1.0, avgSpeedError / (targetSpeedImps + 1));
        const positionPenalty = Math.min(1.0, positionError / (targetDistanceImpulses + 1));
        const overshootPenalty = Math.min(1.0, maxOvershoot / (targetSpeedImps + 1));

        const totalPenalty = (speedPenalty * 0.3) + (positionPenalty * 0.5) + (overshootPenalty * 0.2);
        return 1.0 - totalPenalty;
    }

    function evaluatePositionFitness(telemetryData) {
        if (telemetryData.length < 20 || !telemetryData[0]?.trial?.elapsed_ms) return 0.0;
        const startEncoderAvg = (telemetryData[0].encoder_left + telemetryData[0].encoder_right) / 2;
        let itae = 0, maxOvershoot = 0, lastTime = 0;
        
        for (const data of telemetryData) {
            const currentTime = data.trial.elapsed_ms / 1000.0;
            const dt = currentTime - lastTime;
            if(dt <= 0) continue;
            const currentPos = (data.encoder_left + data.encoder_right) / 2;
            const posError = Math.abs(currentPos - startEncoderAvg);
            itae += posError * currentTime * dt;
            if(posError > maxOvershoot) maxOvershoot = posError;
            lastTime = currentTime;
        }

        const finalPosError = Math.abs(((telemetryData[telemetryData.length-1].encoder_left + telemetryData[telemetryData.length-1].encoder_right) / 2) - startEncoderAvg);
        
        const itaePenalty = Math.min(1.0, itae / 50000.0); // 50000 to stala do skalowania
        const overshootPenalty = Math.min(1.0, maxOvershoot / 1000.0); // 1000 impulsow to duzy overshoot
        const finalErrorPenalty = Math.min(1.0, finalPosError / 50.0); // 50 impulsow to duzy blad koncowy
        
        const totalPenalty = (itaePenalty * 0.4) + (overshootPenalty * 0.3) + (finalErrorPenalty * 0.3);
        return 1.0 - totalPenalty;
    }

    function renderAutotestOptions() {
        const selectedTest = document.querySelector('input[name="autotest-type"]:checked').value;
        const balancePanel = document.getElementById('balanceOptionsPanel');
        const positionPanel = document.getElementById('positionTestOptionsPanel');
        const speedPanel = document.getElementById('speedTestOptionsPanel');
        const actionBtn = document.getElementById('autotestActionBtn');

        [balancePanel, positionPanel, speedPanel].forEach(el => el.style.display = 'none');
        
        if (selectedTest === 'balance') {
            balancePanel.style.display = 'block';
            actionBtn.textContent = 'Rozpocznij Sesje (Auto)';
        } else if (selectedTest === 'position') {
            positionPanel.style.display = 'block';
            actionBtn.textContent = 'Rozpocznij Sesje (Interaktywnie)';
        } else if (selectedTest === 'speed') {
            speedPanel.style.display = 'block';
            actionBtn.textContent = 'Rozpocznij Sesje (Interaktywnie)';
        }
        updateAccordionHeight(document.getElementById('autotestOptions').closest('.accordion-content'));
    }
    
    function updateWeightsBudget() {
        const budgetEl = document.getElementById('weights-budget');
        const sum = Array.from(document.querySelectorAll('.weight-input')).reduce((acc, input) => acc + parseFloat(input.value), 0);
        budgetEl.textContent = sum.toFixed(1);
        budgetEl.classList.toggle('invalid', Math.abs(sum - 10.0) > 0.01);
        budgetEl.classList.toggle('valid', Math.abs(sum - 10.0) <= 0.01);
    }
    
    async function applyPhenotype(phenotype) {
        isApplyingConfig = true;
        for (const [key, value] of Object.entries(phenotype)) {
             sendBleMessage({ type: 'set_param', key: key, value: value });
        }
        await sleep(50);
        isApplyingConfig = false;
    }

    function displayFinalGAResults() {
        const panel = document.getElementById('gaResultsPanel');
        if (!finalBestPhenotypeFromGA) return;
        
        panel.style.display = 'block';
        document.getElementById('gaFinalScore').textContent = bestOverallScore.toFixed(4);
        
        let kp, ki, kd;
        switch(currentOptimizationMode) {
             case 'balance':
                [kp, ki, kd] = [finalBestPhenotypeFromGA.kp_b, 0, finalBestPhenotypeFromGA.kd_b];
                break;
            case 'speed':
                [kp, ki, kd] = [finalBestPhenotypeFromGA.kp_s, finalBestPhenotypeFromGA.ki_s, finalBestPhenotypeFromGA.kd_s];
                break;
            case 'position':
                [kp, ki, kd] = [finalBestPhenotypeFromGA.kp_p, finalBestPhenotypeFromGA.ki_p, finalBestPhenotypeFromGA.kd_p];
                break;
        }
        document.getElementById('gaFinalKp').textContent = kp.toFixed(4);
        document.getElementById('gaFinalKi').textContent = ki.toFixed(4);
        document.getElementById('gaFinalKd').textContent = kd.toFixed(4);
        
        updateAccordionHeight(panel.closest('.accordion-content'));
    }

    function applyGaResults() {
        if (!finalBestPhenotypeFromGA) {
            addLogMessage('[UI] Brak wynikow do zastosowania.', 'warn');
            return;
        }

        isApplyingConfig = true;
        switch(currentOptimizationMode) {
             case 'balance':
                document.getElementById('balanceKpInput').value = finalBestPhenotypeFromGA.kp_b.toFixed(4);
                document.getElementById('balanceKiInput').value = "0.0000";
                document.getElementById('balanceKdInput').value = finalBestPhenotypeFromGA.kd_b.toFixed(4);
                break;
            case 'speed':
                document.getElementById('speedKpInput').value = finalBestPhenotypeFromGA.kp_s.toFixed(4);
                document.getElementById('speedKiInput').value = finalBestPhenotypeFromGA.ki_s.toFixed(4);
                document.getElementById('speedKdInput').value = finalBestPhenotypeFromGA.kd_s.toFixed(4);
                break;
            case 'position':
                document.getElementById('positionKpInput').value = finalBestPhenotypeFromGA.kp_p.toFixed(4);
                document.getElementById('positionKiInput').value = finalBestPhenotypeFromGA.ki_p.toFixed(4);
                document.getElementById('positionKdInput').value = finalBestPhenotypeFromGA.kd_p.toFixed(4);
                break;
        }
        isApplyingConfig = false;

        for(const key in finalBestPhenotypeFromGA) {
            const inputId = Object.keys(parameterMapping).find(id => parameterMapping[id] === key);
            if(inputId) document.getElementById(inputId).dispatchEvent(new Event('change', {bubbles:true}));
        }
        
        addLogMessage('[UI] Zastosowano najlepsze znalezione parametry do panelu.', 'success');
        document.getElementById('gaResultsPanel').style.display = 'none';
    }


    // --- SEKCJA STROJENIA KROK 3: CHARAKTERYZACJA ---
    let isCharacterizationRunning = false;
    let telemetryForCharacterization = [];
    let characterizationStartTime = 0;
    function setupCharacterizationControls() {
        document.getElementById('startStepResponseBtn').addEventListener('click', startSystemCharacterization);
        document.getElementById('applyStepResponseResultsBtn').addEventListener('click', applyStepResponseResults);
    }
    async function startSystemCharacterization() {
        if (lastKnownRobotState !== 'BALANSUJE' && lastKnownRobotState !== 'TRZYMA_POZYCJE') {
             addLogMessage('[Char] Blad: Robot musi byc w stanie balansu.', 'error');
             return;
        }
        addLogMessage('[Char] Rozpoczynam test odpowiedzi skokowej...', 'info');
        const angle = parseFloat(document.getElementById('stepResponseAngleInput').value);
        telemetryForCharacterization = [];
        isCharacterizationRunning = true;
        characterizationStartTime = Date.now();
        sendBleMessage({ type: 'set_param', key: 'kp_s', value: 0 });
        sendBleMessage({ type: 'set_param', key: 'ki_s', value: 0 });
        sendBleMessage({ type: 'set_param', key: 'kd_s', value: 0 });
        sendBleMessage({ type: 'adjust_zero', value: angle / 0.05 });
        setTimeout(() => {
            isCharacterizationRunning = false;
            sendBleMessage({ type: 'adjust_zero', value: -angle / 0.05 });
            addLogMessage('[Char] Zbieranie danych zakonczone. Analizuje...', 'info');
            analyzeStepResponse(telemetryForCharacterization);
        }, 4000);
    }
    function analyzeStepResponse(data) {
        if (data.length < 20) { addLogMessage('[Char] Blad: za malo danych do analizy.', 'error'); return; }
        const maxSpeed = data.reduce((max, p) => Math.abs(p.speed) > max ? Math.abs(p.speed) : max, 0);
        if (maxSpeed < 50) { addLogMessage('[Char] Blad: predkosc maksymalna zbyt niska do analizy.', 'error'); return; }
        const targetSpeed63 = maxSpeed * 0.632;
        let timeConstant = 0;
        for(let i=1; i<data.length; i++) { if (Math.abs(data[i].speed) >= targetSpeed63 && Math.abs(data[i-1].speed) < targetSpeed63) { timeConstant = data[i].time; break; } }
        const gain = maxSpeed / parseFloat(document.getElementById('stepResponseAngleInput').value);
        if (timeConstant > 0) {
            const Ku = (4/Math.PI) * (1/gain);
            const Tu = 4 * timeConstant;
            const Kp_s = 0.45 * Ku;
            const Ki_s = Kp_s / (Tu / 1.2);
            document.getElementById('srKpSuggest').textContent = Kp_s.toFixed(4);
            document.getElementById('srKiSuggest').textContent = Ki_s.toFixed(4);
            document.getElementById('srKdSuggest').textContent = "0.0000";
            document.getElementById('stepResponseResultPanel').style.display = 'block';
            addLogMessage(`[Char] Analiza zakonczona. K=${gain.toFixed(2)}, T=${timeConstant.toFixed(2)}s.`, 'success');
        } else {
             addLogMessage('[Char] Blad: nie udalo sie wyznaczyc stalej czasowej.', 'error');
        }
    }
    function applyStepResponseResults() {
        const kp = parseFloat(document.getElementById('srKpSuggest').textContent);
        const ki = parseFloat(document.getElementById('srKiSuggest').textContent);
        if(!isNaN(kp) && !isNaN(ki)) {
            isApplyingConfig = true;
            document.getElementById('speedKpInput').value = kp.toFixed(4);
            document.getElementById('speedKiInput').value = ki.toFixed(4);
            document.getElementById('speedKdInput').value = "0.0";
            isApplyingConfig = false;
            document.getElementById('speedKpInput').dispatchEvent(new Event('change', { bubbles: true }));
            document.getElementById('speedKiInput').dispatchEvent(new Event('change', { bubbles: true }));
            document.getElementById('speedKdInput').dispatchEvent(new Event('change', { bubbles: true }));
            addLogMessage('[UI] Zastosowano sugerowane wartosci Kp_s i Ki_s.', 'info');
        }
    }
    
    // =======================================================================================
    // === WIZUALIZACJA 3D (ZINTEGROWANA Z ROBOBALA.HTML) ===
    // =======================================================================================
    let scene3D, camera3D, renderer3D, controls3D;
    let robotPivot, leftWheel, rightWheel;
    let groundMesh, groundTexture;
    let currentPitch3D = 0, currentYaw3D = 0, currentEncoderLeft = 0, currentEncoderRight = 0;
    let isAnimation3DEnabled = true, isMovement3DEnabled = false;
    let lastEncoderAvg = 0;
    const WHEEL_DIAMETER = 8.2; // [cm]
    const WHEEL_RADIUS_3D = WHEEL_DIAMETER / 2;

    function createCustomWheel(totalRadius, tireThickness, width) {
        const wheelGroup = new THREE.Group();
        const tireMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.8 });
        const rimMaterial = new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.4 });
        const rimRadius = totalRadius - tireThickness;
        const tire = new THREE.Mesh(new THREE.TorusGeometry(rimRadius + tireThickness / 2, tireThickness / 2, 16, 100), tireMaterial);
        wheelGroup.add(tire);
        const rimShape = new THREE.Shape();
        rimShape.absarc(0, 0, rimRadius, 0, Math.PI * 2, false);
        const holePath = new THREE.Path();
        holePath.absarc(0, 0, rimRadius * 0.85, 0, Math.PI * 2, true);
        rimShape.holes.push(holePath);
        const extrudeSettings = { depth: width * 0.4, bevelEnabled: false };
        const outerRimGeometry = new THREE.ExtrudeGeometry(rimShape, extrudeSettings);
        outerRimGeometry.center();
        const outerRim = new THREE.Mesh(outerRimGeometry, rimMaterial);
        wheelGroup.add(outerRim);
        const hubRadius = rimRadius * 0.2;
        const hub = new THREE.Mesh(new THREE.CylinderGeometry(hubRadius, hubRadius, width * 0.5, 24), rimMaterial);
        hub.rotateX(Math.PI / 2);
        wheelGroup.add(hub);
        const spokeLength = (rimRadius * 0.85) - hubRadius;
        const spokeGeometry = new THREE.BoxGeometry(spokeLength, rimRadius * 0.15, width * 0.4);
        spokeGeometry.translate(hubRadius + spokeLength / 2, 0, 0);
        for (let i = 0; i < 6; i++) {
            const spoke = new THREE.Mesh(spokeGeometry, rimMaterial);
            spoke.rotation.z = i * (Math.PI / 3);
            wheelGroup.add(spoke);
        }
        return wheelGroup;
    }
    
    function createRobotModel3D() {
        const BODY_WIDTH = 9.0, BODY_HEIGHT = 6.0, BODY_DEPTH = 3.5, WHEEL_GAP = 1.0;
        const MAST_HEIGHT = 14.5, MAST_THICKNESS = 1.5;
        const BATTERY_WIDTH = 6.0, BATTERY_HEIGHT = 1.0, BATTERY_DEPTH = 3.0;
        const TIRE_THICKNESS = 1.0, WHEEL_WIDTH = 2.0;
        
        const pivot = new THREE.Object3D();
        const model = new THREE.Group();
        const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x1C1C1C });
        const batteryMaterial = new THREE.MeshStandardMaterial({ color: 0x4169E1 });
        const body = new THREE.Mesh(new THREE.BoxGeometry(BODY_WIDTH, BODY_HEIGHT, BODY_DEPTH), bodyMaterial);
        body.position.y = WHEEL_RADIUS_3D;
        model.add(body);
        const mast = new THREE.Mesh(new THREE.BoxGeometry(MAST_THICKNESS, MAST_HEIGHT, MAST_THICKNESS), bodyMaterial);
        mast.position.y = WHEEL_RADIUS_3D + BODY_HEIGHT / 2 + MAST_HEIGHT / 2;
        model.add(mast);
        const battery = new THREE.Mesh(new THREE.BoxGeometry(BATTERY_WIDTH, BATTERY_HEIGHT, BATTERY_DEPTH), batteryMaterial);
        battery.position.y = mast.position.y + MAST_HEIGHT / 2 + BATTERY_HEIGHT / 2;
        model.add(battery);
        
        leftWheel = createCustomWheel(WHEEL_RADIUS_3D, TIRE_THICKNESS, WHEEL_WIDTH);
        leftWheel.rotation.y = Math.PI / 2;
        leftWheel.position.set(-(BODY_WIDTH / 2 + WHEEL_GAP), WHEEL_RADIUS_3D, 0);
        model.add(leftWheel);
        
        rightWheel = createCustomWheel(WHEEL_RADIUS_3D, TIRE_THICKNESS, WHEEL_WIDTH);
        rightWheel.rotation.y = Math.PI / 2;
        rightWheel.position.set(BODY_WIDTH / 2 + WHEEL_GAP, WHEEL_RADIUS_3D, 0);
        model.add(rightWheel);
        
        model.position.y = -WHEEL_RADIUS_3D;
        pivot.add(model);
        
        return pivot;
    }

    function createCheckerTexture(squareSizeCm = 20, colorA = '#C8C8C8', colorB = '#787878') {
        const size = 256; const squares = 2;
        const canvas = document.createElement('canvas'); canvas.width = size; canvas.height = size; const ctx = canvas.getContext('2d');
        const s = size / squares;
        for (let y = 0; y < squares; y++) {
            for (let x = 0; x < squares; x++) {
                ctx.fillStyle = ((x + y) % 2 === 0) ? colorA : colorB;
                ctx.fillRect(x * s, y * s, s, s);
            }
        }
        const tex = new THREE.CanvasTexture(canvas);
        tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
        tex.anisotropy = 8; tex.encoding = THREE.sRGBEncoding;
        return tex;
    }

    function createSkyTexture() {
        const width = 1024, height = 512;
        const canvas = document.createElement('canvas'); canvas.width = width; canvas.height = height; const ctx = canvas.getContext('2d');
        const grad = ctx.createLinearGradient(0, 0, 0, height);
        grad.addColorStop(0, '#87CEEB');
        grad.addColorStop(1, '#E6F2FA');
        ctx.fillStyle = grad; ctx.fillRect(0, 0, width, height);
        ctx.globalAlpha = 0.15; ctx.fillStyle = '#FFFFFF';
        for (let i = 0; i < 12; i++) {
            const cx = Math.random() * width, cy = Math.random() * height * 0.6, rw = 120 + Math.random() * 180, rh = 30 + Math.random() * 40;
            ctx.beginPath(); ctx.ellipse(cx, cy, rw, rh, 0, 0, Math.PI * 2); ctx.fill();
        }
        const tex = new THREE.CanvasTexture(canvas);
        tex.encoding = THREE.sRGBEncoding; return tex;
    }

    function init3DVisualization() {
        const container = document.getElementById('robot3d-container');
        scene3D = new THREE.Scene();
        scene3D.background = createSkyTexture();
        camera3D = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 2000);
        camera3D.position.set(28, 22, 48);
        camera3D.lookAt(0, 8, 0);
        renderer3D = new THREE.WebGLRenderer({ antialias: true });
        renderer3D.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer3D.domElement);
        controls3D = new THREE.OrbitControls(camera3D, renderer3D.domElement);
        controls3D.target.set(0, 8, 0);
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene3D.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
        directionalLight.position.set(10, 20, 15);
        scene3D.add(directionalLight);
        
        const PLANE_SIZE_CM = 2000;
        groundTexture = createCheckerTexture(20);
        const repeats = PLANE_SIZE_CM / 20;
        groundTexture.repeat.set(repeats, repeats);
        const groundMaterial = new THREE.MeshStandardMaterial({ map: groundTexture, roughness: 1.0, metalness: 0.0 });
        const groundGeo = new THREE.PlaneGeometry(PLANE_SIZE_CM, PLANE_SIZE_CM, 1, 1);
        groundMesh = new THREE.Mesh(groundGeo, groundMaterial);
        groundMesh.rotation.x = -Math.PI / 2;
        groundMesh.position.y = 0;
        scene3D.add(groundMesh);
        
        robotPivot = createRobotModel3D();
        robotPivot.position.y = WHEEL_RADIUS_3D;
        scene3D.add(robotPivot);

        window.addEventListener('resize', () => {
            const width = container.clientWidth;
            const height = container.clientHeight;
            camera3D.aspect = width / height;
            camera3D.updateProjectionMatrix();
            renderer3D.setSize(width, height);
        });
        
        setupControls3D();
    }
    function setupControls3D() {
        document.getElementById('reset3dViewBtn').addEventListener('click', () => {
            camera3D.position.set(15, 15, 25);
            controls3D.target.set(0, 8, 0);
            controls3D.update();
        });
        document.getElementById('toggle3dAnimationBtn').addEventListener('click', () => isAnimation3DEnabled = !isAnimation3DEnabled);
        document.getElementById('toggle3dMovementBtn').addEventListener('click', () => {
            isMovement3DEnabled = !isMovement3DEnabled;
            if(!isMovement3DEnabled) { lastEncoderAvg = (currentEncoderLeft + currentEncoderRight) / 2; }
        });
    }

    function animate3D() {
        requestAnimationFrame(animate3D);
        if (isAnimation3DEnabled && robotPivot) {
            robotPivot.rotation.x = -THREE.MathUtils.degToRad(currentPitch3D);
            robotPivot.rotation.y = -THREE.MathUtils.degToRad(currentYaw3D);

            const ppr = parseFloat(document.getElementById('encoderPprInput').value) || 820;
            const wheelRotationL = (currentEncoderLeft / ppr) * 2 * Math.PI;
            const wheelRotationR = (currentEncoderRight / ppr) * 2 * Math.PI;
            
            // POPRAWKA: Dodajemy znak minus, aby odwrócić kierunek obrotu
            if (leftWheel) leftWheel.rotation.z = -wheelRotationL;
            if (rightWheel) rightWheel.rotation.z = -wheelRotationR;

            if (isMovement3DEnabled) {
                const currentEncoderAvg = (currentEncoderLeft + currentEncoderRight) / 2;
                const dist_cm = ((currentEncoderAvg - lastEncoderAvg) / ppr) * Math.PI * WHEEL_DIAMETER;
                const angleRad = robotPivot.rotation.y;
                
                if (groundTexture) {
                    const dx = Math.sin(angleRad) * dist_cm;
                    const dz = Math.cos(angleRad) * dist_cm;
                    const squaresPerCm = 1 / 20;
                    groundTexture.offset.x += dx * squaresPerCm;
                    groundTexture.offset.y += dz * squaresPerCm;
                    groundTexture.needsUpdate = true;
                }
                const logicalX = (groundTexture ? -groundTexture.offset.x * 20 : robotPivot.position.x);
                const logicalZ = (groundTexture ? -groundTexture.offset.y * 20 : robotPivot.position.z);
                document.getElementById('robot3d-position-x').textContent = logicalX.toFixed(1) + ' cm';
                document.getElementById('robot3d-position-z').textContent = logicalZ.toFixed(1) + ' cm';
                lastEncoderAvg = currentEncoderAvg;
            }
        }
        controls3D.update();
        renderer3D.render(scene3D, camera3D);
    }
</script>
</body>
</html>

