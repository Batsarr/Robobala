<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Robot PID - Panel Sterowania v21.0</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; margin: 0; padding: 15px; background-color: #282c34; color: #fff; font-size: 14px; }
        h1 { color: #61dafb; font-size: 1.8em; }
        h2 { color: #61dafb; font-size: 1.4em; margin-top: 0; margin-bottom: 15px; }
        .main-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(340px, 1fr)); gap: 15px; align-items: start; max-width: 1920px; margin: auto; }
        .card { background-color: #3a3f47; border-radius: 8px; padding: 15px; box-shadow: 0 2px 6px rgba(0,0,0,0.2); }
        .info-grid, .status-grid { display: grid; grid-template-columns: auto 1fr; gap: 8px; text-align: left; font-size: 1em; margin-top: 10px; align-items: center;}
        .info-grid strong, .status-grid strong { color: #a2f279; }
        button { background-color: #61dafb; color: #282c34; border: none; padding: 8px 12px; border-radius: 5px; font-weight: bold; cursor: pointer; transition: background-color 0.3s, opacity 0.3s, box-shadow 0.2s; font-size: 0.9em; }
        button:hover { background-color: #a2f279; }
        button:disabled { background-color: #4a4f58; color: #888; cursor: not-allowed; opacity: 0.6; }
        .gamepad-flash { box-shadow: 0 0 10px 3px #a2f279 !important; }
        #emergencyStopBtn { background-color: #ff6347; color: white; width: 100%; margin-top: 15px; }
        .control-row { display: flex; align-items: center; justify-content: space-between; width: 100%; margin-top: 10px; }
        .control-label { font-size: 1.1em; font-weight: bold; }
        .switch { position: relative; display: inline-block; width: 50px; height: 28px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider.round { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ff6347; transition: .4s; border-radius: 28px; }
        .slider.round:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #a2f279; }
        input:checked + .slider:before { transform: translateX(22px); }
        input[type="checkbox"].slider-checkbox + .slider { background-color: #4a4f58; }
        input[type="checkbox"].slider-checkbox:checked + .slider { background-color: #a2f279; }
        input:disabled + .slider { background-color: #4a4f58; cursor: not-allowed; }
        fieldset { border: 1px solid #4a4f58; border-radius: 8px; margin-top: 15px; padding: 10px 15px; }
        legend { color: #61dafb; font-weight: bold; padding: 0 10px; font-size: 1.1em; }
        #joystickWrapper { position: relative; width: 180px; height: 180px; border-radius: 50%; background-color: #4a4f58; border: 3px solid #61dafb; margin: 15px auto; touch-action: none; }
        #joystickCanvas { width: 100%; height: 100%; display: block; }
        #chart-wrapper { position: relative; height: 320px; border-radius: 8px; overflow: hidden; background-color: #20232a; }
        #log-history { text-align: left; height: 350px; overflow-y: auto; background-color: #20232a; padding: 10px; border-radius: 8px; font-family: monospace; white-space: pre-wrap; }
        .status-indicator { width: 14px; height: 14px; border-radius: 50%; display: inline-block; }
        .status-ok { background-color: #a2f279; }
        .status-warn { background-color: #f7b731; }
        .status-error { background-color: #ff6347; }
        .status-disconnected { background-color: #888; }
        #emergency-banner { display: none; background-color: #ff6347; color: white; padding: 10px; font-weight: bold; position: fixed; top: 0; left: 0; width: 100%; z-index: 1000; }
        .angle-display { display: flex; align-items: center; justify-content: space-between; }
        .angle-indicator-wrapper { position: relative; width: 34px; height: 34px; background-color: #20232a; border-radius: 50%; border: 1px solid #61dafb; }
        .angle-indicator-needle { position: absolute; bottom: 50%; left: calc(50% - 1px); width: 2px; height: 50%; background-color: #ff6347; transform-origin: bottom center; transition: transform 0.1s linear; }
        .chart-controls { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin-top: 10px; font-size: 0.9em; }
        .chart-controls label { color: #fff; }
        .setting-container { display: grid; grid-template-columns: 1fr auto; gap: 10px; align-items: center; margin: 8px 0; }
        .setting-container label { font-size: 1em; font-weight: bold; color: #a2f279; text-align: left; }
        .numeric-input-wrapper { display: flex; align-items: center; flex-shrink: 0; }
        .numeric-input-wrapper button { background-color: #4a4f58; color: #61dafb; padding: 4px 8px; font-size: 1em; line-height: 1; min-width: 30px; }
        .numeric-input-wrapper input[type=number] { width: 90px; text-align: center; font-size: 1em; background-color: #20232a; color: #fff; border: 1px solid #61dafb; border-radius: 5px; margin: 0 4px; padding: 4px; -moz-appearance: textfield; }
        input[type=number]::-webkit-inner-spin-button, input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        .manual-tune-row { background-color: #2a2f35; padding: 10px; border-radius: 6px; margin-bottom: 12px; }
        .pwm-input-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .pwm-input-row label { font-weight: bold; color: #a2f279; }
        .pwm-button-row { display: flex; justify-content: flex-end; gap: 10px; }
        .pwm-button-row button { flex-grow: 1; max-width: 100px; }
        .test-btn { background-color: #a2f279; }
        .stop-btn { background-color: #ff6347; }
        .auto-btn { background-color: #f7b731; }
        .trim-controls { display: flex; justify-content: space-between; align-items: center; margin-top: 10px; }
        .trim-controls span { font-weight: bold; }
        .trim-controls button { min-width: 40px; font-size: 1.2em; }
        .accordion-header { background-color: #4a4f58; color: #61dafb; cursor: pointer; padding: 12px 15px; border: none; text-align: left; outline: none; font-size: 1.1em; font-weight: bold; width: 100%; border-radius: 8px; margin-top: 5px; transition: background-color 0.3s; position: relative; }
        .accordion-header:hover { background-color: #5a6068; }
        .accordion-header.active { background-color: #61dafb; color: #282c34; border-bottom-left-radius: 0; border-bottom-right-radius: 0;}
        .accordion-header::after { content: '+'; position: absolute; right: 15px; font-size: 1.4em; transition: transform 0.3s; }
        .accordion-header.active::after { content: '-'; }
        .accordion-content { max-height: 0; overflow: hidden; transition: max-height 0.4s ease-out, padding 0.2s ease-out; background-color: #3a3f47; border-bottom-left-radius: 8px; border-bottom-right-radius: 8px; padding: 0 15px; }
        .accordion-content.active { padding: 15px; }
        .pwm-info { background-color: #20232a; padding: 10px; border-radius: 5px; margin-bottom: 15px; border-left: 4px solid #61dafb; }
        .pwm-info strong { color: #a2f279; }
        .parameter-group { background-color: #20232a; padding: 12px; border-radius: 6px; margin-bottom: 12px; }
        .parameter-group h5 { color: #61dafb; margin: 0 0 8px 0; font-size: 1.1em; }
        .help-icon { display: inline-block; width: 16px; height: 16px; border-radius: 50%; background-color: #61dafb; color: #282c34; font-size: 12px; font-weight: bold; text-align: center; line-height: 16px; margin-left: 8px; cursor: pointer; user-select: none; }
        .help-text { background-color: #20232a; color: #fff; border-radius: 6px; padding: 10px; border: 1px solid #61dafb; margin-top: 8px; text-align: left; font-size: 0.9em; line-height: 1.4; width: 100%; box-sizing: border-box; max-height: 0; overflow: hidden; transition: max-height 0.3s ease-out, padding 0.3s ease-out; padding-top: 0; padding-bottom: 0; grid-column: 1 / -1; }
        .help-text.visible { max-height: 200px; padding-top: 10px; padding-bottom: 10px; }
        .modal-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); z-index: 2000; display: none; justify-content: center; align-items: center; }
        .modal-content { background-color: #3a3f47; padding: 20px; border-radius: 8px; width: 90%; max-width: 500px; box-shadow: 0 5px 15px rgba(0,0,0,0.5); }
        .mapping-row { display: grid; grid-template-columns: 1fr 100px 100px; gap: 10px; align-items: center; margin-bottom: 10px; }
        .mapping-label { text-align: left; font-weight: bold; }
        .mapping-button { font-size: 0.8em; padding: 6px 8px; }
        .mapping-display { background-color: #20232a; padding: 6px; border-radius: 4px; font-family: monospace; }
        .preset-actions { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px; }
        #applySelectedPresetBtn { background-color: #a2f279; }
        #saveCurrentAsPresetBtn { background-color: #61dafb; }
        .dpad-container { display: grid; grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 1fr 1fr; gap: 5px; max-width: 150px; margin: 15px auto; }
        .dpad-btn { background-color: #61dafb; color: #282c34; border-radius: 5px; font-size: 2em; line-height: 1; padding: 5px; cursor: pointer; border: none; }
        .dpad-btn:hover { background-color: #a2f279; }
        #dpad-up { grid-column: 2; grid-row: 1; }
        #dpad-left { grid-column: 1; grid-row: 2; }
        #dpad-right { grid-column: 3; grid-row: 2; }
        #dpad-down { grid-column: 2; grid-row: 3; }
        #dpad-stop { grid-column: 2; grid-row: 2; background-color: #ff6347; color: white; }
        .dpad-input-group { display: grid; grid-template-columns: 1fr auto; gap: 10px; align-items: center; margin: 10px 0; }
        .dpad-input-group label { text-align: right; font-weight: bold; color: #a2f279; }
        .dpad-input-group input { width: 100%; box-sizing: border-box; background-color: #20232a; color: #fff; border: 1px solid #61dafb; border-radius: 5px; padding: 4px; }
        .sequence-step { display: grid; grid-template-columns: 1fr 100px auto; gap: 10px; align-items: center; background-color: #2a2f35; padding: 8px; border-radius: 6px; margin-bottom: 8px; transition: background-color: 0.3s; }
        .sequence-step.executing { background-color: #a2f279; color: #282c34; }
        .sequence-step.executing select, .sequence-step.executing input { color: #282c34; border-color: #282c34; }
        .sequence-step select, .sequence-step input { width: 100%; background-color: #20232a; color: #fff; border: 1px solid #61dafb; border-radius: 4px; padding: 5px; }
        .sequence-step .remove-step-btn { background-color: #ff6347; padding: 5px 10px; }
        #znTuningStatusPanel { background-color: #20232a; padding: 12px; border-radius: 6px; }
        #znTuningStatusPanel h5 { color: #61dafb; margin: 0 0 10px 0; font-size: 1.1em; text-align: left; }
        #znResultPanel { display: none; background-color: #20232a; padding: 12px; border-radius: 6px; margin-top: 15px; }
        #znResultPanel h5 { color: #61dafb; margin: 0 0 10px 0; text-align: left; }
        .result-grid { display: grid; grid-template-columns: auto 1fr; gap: 5px 15px; text-align: left; }
        .result-grid strong { color: #a2f279; }
        .result-grid span { font-weight: bold; color: #fff; }
        .apply-btn { background-color: #a2f279; margin-top: 10px; width: 100%; }
        .test-results-panel { display: none; background-color: #20232a; padding: 12px; border-radius: 6px; margin-top: 15px; }
        .test-results-panel h5 { color: #61dafb; margin: 0 0 10px 0; text-align: left; }
        #robot3d-container { width: 100%; height: 400px; border-radius: 8px; overflow: hidden; position: relative; border: 2px solid #61dafb; }
        .robot3d-controls { display: flex; justify-content: space-between; align-items: center; margin-top: 10px; }
        .robot3d-controls button { padding: 8px 16px; background-color: #61dafb; color: #282c34; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        .robot3d-controls button:hover { background-color: #a2f279; }
        .robot3d-info { background-color: #20232a; padding: 10px; border-radius: 6px; margin-top: 10px; }
        .robot3d-metrics { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; text-align: left; }
        .robot3d-metrics strong { color: #a2f279; }
        .suggestion-grid { background-color: #2a2f35; padding: 10px; border-radius: 6px; margin-top: 10px;}
        .suggestion-grid .result-grid strong { color: #61dafb; }
        .suggestion-actions { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px; }
        #gaStatusPanel { background-color: #20232a; padding: 12px; border-radius: 6px; margin-top:15px; }
        #gaStatusPanel h5 { color: #61dafb; margin: 0 0 10px 0; font-size: 1.1em; text-align: left; }
        #gaProgressBar { width: 100%; -webkit-appearance: none; appearance: none; height: 8px; }
        #gaProgressBar::-webkit-progress-bar { background-color: #4a4f58; border-radius: 4px; }
        #gaProgressBar::-webkit-progress-value { background-color: #a2f279; border-radius: 4px; transition: width 0.3s ease; }
        .ga-button-row { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-top: 15px; }
        .ui-locked fieldset, .ui-locked .accordion-header, .ui-locked button, .ui-locked input, .ui-locked .switch {
            opacity: 0.6;
            pointer-events: none;
            cursor: not-allowed !important;
        }
        .ui-locked #connectBleBtn, .ui-locked #emergencyStopBtn {
            opacity: 1.0;
            pointer-events: auto;
        }
    </style>
</head>
<body>
    <div id="emergency-banner">ZATRZYMANIE AWARYJNE</div>
    <div id="gamepad-mapping-modal" class="modal-backdrop">
        <div class="modal-content">
            <h2>Mapowanie Przyciskow Gamepada</h2>
            <div id="gamepad-mapping-list"></div>
            <button id="close-modal-btn" style="margin-top: 20px;">Zamknij</button>
        </div>
    </div>

    <h1>Robot PID - Panel Sterowania v21.0</h1>
    <div class="main-grid">
        <div class="card" id="controls-card">
            <h2>Sterowanie</h2>
            <div id="joystickWrapper"><canvas id="joystickCanvas"></canvas></div>
            <div class="control-row"><span class="control-label">Balansowanie</span><label class="switch"><input type="checkbox" id="balanceSwitch"><span class="slider round"></span></label></div>
            <div class="control-row"><span class="control-label">Trzymaj Pozycje</span><label class="switch"><input type="checkbox" id="holdPositionSwitch"><span class="slider round"></span></label></div>
            <div class="control-row"><span class="control-label">Tryb Predkosci</span><label class="switch"><input type="checkbox" id="speedModeSwitch"><span class="slider round"></span></label></div>
            <button id="open-gamepad-modal-btn" style="width: 100%; background-color:#f7b731; margin-top: 15px;">Mapowanie Przyciskow Gamepada</button>
            <button id="resetZeroBtn" style="margin-top:10px; width:100%;">Resetuj Osie</button>
            <div class="trim-controls"> <button id="trimMinusBtn">-</button> <span>Korekta Pionu (Pitch)</span> <button id="trimPlusBtn">+</button> </div>
            <button id="resetEncodersBtn" style="margin-top:10px; background-color:#f7b731; width: 100%;">Resetuj Enkodery</button>
            <button id="emergencyStopBtn">STOP AWARYJNY</button>
            <button class="accordion-header" onclick="toggleAccordion(this)" style="margin-top: 15px;">Strojenie Joysticka</button>
            <div class="accordion-content">
                <div class="setting-container"><label for="joystickSensitivityInput">Czulosc Globalna (%)<span class="help-icon">?</span></label><div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="joystickSensitivityInput" min="10" max="100" step="5" value="100"><button>+</button></div><div class="help-text">Mnoznik dla wszystkich wartosci z joysticka. Zmniejsz, aby robot byl mniej czuly.</div></div>
                <div class="setting-container"><label for="expoJoystickInput">Expo Joysticka (%)<span class="help-icon">?</span></label><div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="expoJoystickInput" min="0" max="90" step="1" value="0"><button>+</button></div><div class="help-text">Dodaje krzywa wykladnicza. Wieksza wartosc = wieksza precyzja przy malych wychyleniach.</div></div>
                <div class="setting-container"><label for="maxSpeedJoystickInput">Max. predkosc (imp/s)<span class="help-icon">?</span></label><div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="maxSpeedJoystickInput" min="200" max="4000" step="100" value="800"><button>+</button></div><div class="help-text">Maksymalna predkosc zadana w trybie predkosci przy pelnym wychyleniu joysticka.</div></div>
                <div class="setting-container"><label for="joystickAngleSensitivityInput">Czulosc Kata (st.)<span class="help-icon">?</span></label><div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="joystickAngleSensitivityInput" min="1" max="30" step="0.5" value="10"><button>+</button></div><div class="help-text">Maksymalny kat pochylenia zadany w trybie kata przy pelnym wychyleniu joysticka.</div></div>
                <div class="setting-container"><label for="turnFactorInput">Czulosc Skretu (%)<span class="help-icon">?</span></label><div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="turnFactorInput" min="0" max="100" step="5" value="25"><button>+</button></div><div class="help-text">Jak szybko robot ma sie obracac w miejscu przy maksymalnym wychyleniu joysticka w poziomie.</div></div>
                <div class="setting-container"><label for="joystickDeadzoneInput">Strefa Martwa (%)<span class="help-icon">?</span></label><div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="joystickDeadzoneInput" min="0" max="50" step="1" value="0"><button>+</button></div><div class="help-text">Obszar wokol srodka joysticka, w ktorym ruch jest ignorowany.</div></div>
            </div>
        </div>
        <div class="card">
            <h2>Status Robota</h2>
            <button id="connectBleBtn" style="width: 100%; margin-bottom: 15px;">POLACZ Z ROBOTEM</button>
            <div class="status-grid">
                <strong>Polaczenie:</strong> <div><span id="connectionStatus" class="status-indicator status-disconnected"></span> <span id="connectionText">Rozlaczony</span></div>
                <strong>Gamepad:</strong> <span id="gamepadStatus" style="font-weight:bold; color: #f7b731;">Brak</span>
                <strong>Tryb Pracy:</strong> <span id="robotStateVal" style="font-weight:bold; color: #61dafb;">IDLE</span>
                <strong>Czas Petli:</strong> <span id="loopTimeVal">0 &micro;s</span>
            </div>
            <div class="info-grid">
                <strong>Kat (Pitch):</strong> <div class="angle-display"><span id="angleVal">0.0 &deg;</span><div class="angle-indicator-wrapper"><div id="angleIndicator" class="angle-indicator-needle"></div></div></div>
                <strong>Kat (Roll):</strong> <span id="rollVal">0.0 &deg;</span>
                <strong>Predkosc (imp/s):</strong> <span id="speedVal">0</span>
                <strong>Enkoder L:</strong> <span id="encoderLeftVal">0</span>
                <strong>Enkoder P:</strong> <span id="encoderRightVal">0</span>
                <strong>Status Kalibracji IMU (BNO055):</strong>
                <span id="calibSysVal">-</span> / <span id="calibAccelVal">-</span> / <span id="calibGyroVal">-</span> / <span id="calibMagVal">-</span>
            </div>
             <fieldset style="margin-top: 15px;">
                <legend>Diagnostyka</legend>
                <div style="display: grid; grid-template-columns: 1fr; gap: 10px;">
                    <!-- [ZMIANA] Zmiana opisu i funkcji przycisku kalibracji -->
                    <button id="calibrateMpuBtn" style="width:100%; background-color:#f7b731;">Sprawdź Status Kalibracji</button>
                    <button id="calibrateZeroPointBtn" style="width:100%; background-color:#f7b731;">Znajdz Pion Automatycznie</button>
                </div>
            </fieldset>
        </div>
        <div class="card">
            <h2>Wizualizacja 3D Robota</h2>
            <div id="robot3d-container"></div>
            <div class="robot3d-controls">
                <button id="reset3dViewBtn">Resetuj Widok</button>
                <button id="toggle3dAnimationBtn">Wl./Wyl. Animacje</button>
                <button id="toggle3dMovementBtn">Start/Stop Ruchu</button>
            </div>
            <div class="robot3d-info">
                <div class="robot3d-metrics">
                    <strong>Przechyl (Pitch):</strong> <span id="robot3d-pitch">0.0°</span>
                    <strong>Przechyl (Roll):</strong> <span id="robot3d-roll">0.0°</span>
                    <strong>Obrot kol:</strong> <span id="robot3d-wheel-speed">0 obr/min</span>
                    <strong>Pozycja X:</strong> <span id="robot3d-position-x">0.0 cm</span>
                    <strong>Pozycja Z:</strong> <span id="robot3d-position-z">0.0 cm</span>
                </div>
            </div>
        </div>
        <div class="card">
            <button class="accordion-header" onclick="toggleAccordion(this)">Wykres Telemetryczny</button>
            <div class="accordion-content">
                <div id="chart-wrapper"><canvas id="telemetryChart"></canvas></div>
                <div class="chart-controls" id="chartControls"></div>
            </div>
        </div>
        <div class="card">
             <button class="accordion-header" onclick="toggleAccordion(this)">Sterowanie Autonomiczne</button>
            <div class="accordion-content">
               <fieldset>
                   <legend>Sterowanie Precyzyjne (D-Pad)</legend>
                   <div class="dpad-input-group">
                       <label for="dpadDistInput">Dystans (cm):</label>
                       <input type="number" id="dpadDistInput" value="20">
                   </div>
                   <div class="dpad-input-group">
                       <label for="dpadAngleInput">Kat (st.):</label>
                       <input type="number" id="dpadAngleInput" value="90">
                   </div>
                   <div class="dpad-container">
                       <button id="dpad-up" class="dpad-btn" data-dpad="up">&#8593;</button>
                       <button id="dpad-left" class="dpad-btn" data-dpad="left">&#8592;</button>
                       <button id="dpad-stop" class="dpad-btn" data-dpad="stop">&#215;</button>
                       <button id="dpad-right" class="dpad-btn" data-dpad="right">&#8594;</button>
                       <button id="dpad-down" class="dpad-btn" data-dpad="down">&#8595;</button>
                   </div>
               </fieldset>
               <fieldset style="margin-top: 15px;">
                   <legend>Kreator Sekwencji Ruchow</legend>
                   <div id="sequence-list"></div>
                   <button id="add-sequence-step-btn" style="width:100%; margin: 10px 0;">Dodaj Krok</button>
                   <div style="display:flex; gap:10px; justify-content:center;">
                       <button id="run-sequence-btn" style="background-color: #a2f279;">Uruchom</button>
                       <button id="stop-sequence-btn" style="background-color: #ff6347;" disabled>Zatrzymaj</button>
                       <button id="clear-sequence-btn" style="background-color: #f7b731;">Wyczysc</button>
                   </div>
               </fieldset>
           </div>
        </div>
        <div class="card">
            <h2>Konfiguracja</h2>
            <fieldset>
                <legend>Profile Ustawien PID</legend>
                <div class="profile-controls"> <select id="pidPresetSelect" style="width: 100%; padding: 5px;"></select> </div>
                <div class="preset-actions">
                    <button id="applySelectedPresetBtn">Zastosuj</button>
                    <button id="saveCurrentAsPresetBtn">Zapisz jako Nowy</button>
                </div>
                <button id="deleteSelectedPresetBtn" style="width:100%; margin-top: 10px; background-color: #ff6347;">Usun Wybrany Preset</button>
            </fieldset>
            <div id="allSettings">
                <button class="accordion-header" onclick="toggleAccordion(this)">1. Parametry Sprzetowe i Mechaniczne</button>
                <div class="accordion-content">
                    <div class="setting-container"> <label for="wheelDiameterInput">Srednica kola (cm)</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="wheelDiameterInput" step="0.1" value="8.2"><button>+</button></div> </div>
                    <div class="setting-container"> <label for="trackWidthInput">Rozstaw kol (cm)</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="trackWidthInput" step="0.1" value="12.5"><button>+</button></div> </div>
                    <div class="setting-container"> <label for="encoderPprInput">Impulsy na obrot (PPR)</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="encoderPprInput" step="10" value="820"><button>+</button></div> </div>
                </div>
                <button class="accordion-header" onclick="toggleAccordion(this)">2. Kalibracja PWM Silnikow</button>
                <div class="accordion-content">
                    <div class="pwm-info"> <strong>Info:</strong> Uzyj przycisku <strong>"Auto"</strong>, aby automatycznie znalezc prog startowy silnika, lub <strong>"Testuj"</strong>, aby sprawdzic recznie wpisana wartosc. <strong>Wazne:</strong> Przed testem podnies robota, aby kola mogly sie swobodnie krecic! </div>
                     <div class="setting-container"> <label for="pwmTuneStartInput">Rozpocznij auto-szukanie od PWM</label> <div class="numeric-input-wrapper"> <button id="pwmTuneStartMinus">-</button> <input type="number" id="pwmTuneStartInput" min="1" max="800" step="1" value="600"> <button id="pwmTuneStartPlus">+</button> </div> </div> <hr style="border-color: #4a4f58; margin: 15px 0;">
                    <div class="manual-tune-row" data-motor="left" data-direction="fwd"> <div class="pwm-input-row"> <label>Lewy (Przod)</label> <div class="numeric-input-wrapper"><button class="tune-minus">-</button><input type="number" class="config-value tune-input" id="minPwmLeftFwdInput" min="0" max="1023" step="1" value="640"><button>+</button></div> </div> <div class="pwm-button-row"> <button class="test-btn">Testuj</button><button class="stop-btn">Stop</button><button class="auto-btn">Auto</button></div> </div>
                    <div class="manual-tune-row" data-motor="left" data-direction="bwd"> <div class="pwm-input-row"> <label>Lewy (Tyl)</label> <div class="numeric-input-wrapper"><button class="tune-minus">-</button><input type="number" class="config-value tune-input" id="minPwmLeftBwdInput" min="0" max="1023" step="1" value="640"><button>+</button></div> </div> <div class="pwm-button-row"> <button class="test-btn">Testuj</button><button class="stop-btn">Stop</button><button class="auto-btn">Auto</button></div> </div>
                    <div class="manual-tune-row" data-motor="right" data-direction="fwd"> <div class="pwm-input-row"> <label>Prawy (Przod)</label> <div class="numeric-input-wrapper"><button class="tune-minus">-</button><input type="number" class="config-value tune-input" id="minPwmRightFwdInput" min="0" max="1023" step="1" value="640"><button>+</button></div> </div> <div class="pwm-button-row"> <button class="test-btn">Testuj</button><button class="stop-btn">Stop</button><button class="auto-btn">Auto</button></div> </div>
                    <div class="manual-tune-row" data-motor="right" data-direction="bwd"> <div class="pwm-input-row"> <label>Prawy (Tyl)</label> <div class="numeric-input-wrapper"><button class="tune-minus">-</button><input type="number" class="config-value tune-input" id="minPwmRightBwdInput" min="0" max="1023" step="1" value="640"><button>+</button></div> </div> <div class="pwm-button-row"> <button class="test-btn">Testuj</button><button class="stop-btn">Stop</button><button class="auto-btn">Auto</button></div> </div>
                    <button id="manualTuneStopAll" style="width:100%; margin-top:15px; background-color:#ff6347;">ZATRZYMAJ WSZYSTKIE SILNIKI</button>
                </div>
                <button class="accordion-header" onclick="toggleAccordion(this)">3. PID Balansu (Podstawowy)</button>
                <div class="accordion-content">
                    <div class="setting-container"> <label for="balanceKpInput">Kp - Sila<span class="help-icon">?</span></label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="balanceKpInput" step="0.1" value="95"><button>+</button></div> <div class="help-text"><strong>Wplyw:</strong> Sztywnosc utrzymania pionu. Zwieksz dla szybszej reakcji na wychylenie. Zbyt duza wartosc powoduje oscylacje.</div> </div>
                    <div class="setting-container"> <label for="balanceKiInput">Ki - Korekta<span class="help-icon">?</span></label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="balanceKiInput" step="0.01" value="0.0"><button>+</button></div> <div class="help-text"><strong>Wplyw:</strong> Usuwa dlugotrwaly blad (np. gdy robot dryfuje). Zwiekszaj bardzo ostroznie, czesto nie jest potrzebny.</div> </div>
                    <div class="setting-container"> <label for="balanceKdInput">Kd - Tlumienie<span class="help-icon">?</span></label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="balanceKdInput" step="0.01" value="3.23"><button>+</button></div> <div class="help-text"><strong>Wplyw:</strong> Hamuje oscylacje i uspokaja robota. Przeciwdziala gwaltownym zmianom kata, dzialajac jak amortyzator. Zbyt duza wartosc moze spowolnic reakcje, a zbyt mala powodowac drgania.</div> </div>
                    <div class="setting-container"> <label for="balanceFilterAlphaInput">Filtr Pochodnej (%)<span class="help-icon">?</span></label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="balanceFilterAlphaInput" min="1" max="100" step="1" value="100"><button>+</button></div> <div class="help-text">Wygladza odczyt pochodnej, redukujac wplyw szumow. 100% = brak filtrowania. Zmniejsz, jesli robot jest nerwowy.</div> </div>
                    <div class="setting-container"> <label for="balanceIntegralLimitInput">Limit Integratora</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="balanceIntegralLimitInput" step="1" value="50"><button>+</button></div> </div>
                </div>
                <button class="accordion-header" onclick="toggleAccordion(this)">4. PID Kaskadowy (Predkosc/Pozycja)</button>
                <div class="accordion-content">
                    <div class="parameter-group"><h5>PID Predkosci</h5>
                        <div class="setting-container"> <label for="speedKpInput">Kp - Reakcja</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="speedKpInput" step="0.01" value="0.0"><button>+</button></div> </div>
                        <div class="setting-container"> <label for="speedKiInput">Ki - Eliminacja bledu</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="speedKiInput" step="0.001" value="0.0"><button>+</button></div> </div>
                        <div class="setting-container"> <label for="speedKdInput">Kd - Tlumienie</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="speedKdInput" step="0.001" value="0.0"><button>+</button></div> </div>
                        <div class="setting-container"> <label for="maxTargetAngleInput">Max. kat z PID Predk. (st.)</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="maxTargetAngleInput" step="0.5" value="15.0"><button>+</button></div> </div>
                        <div class="setting-container"> <label for="speedDeadbandInput">Strefa martwa (imp/s)</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="speedDeadbandInput" step="1" value="5"><button>+</button></div> </div>
                        <div class="setting-container"> <label for="speedIntegralLimitInput">Limit Integratora</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="speedIntegralLimitInput" step="1" value="20"><button>+</button></div> </div>
                        <div class="setting-container"> <label for="speedFilterAlphaInput">Filtr Pochodnej (%)</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="speedFilterAlphaInput" min="1" max="100" step="1" value="80"><button>+</button></div> </div>
                    </div>
                     <div class="parameter-group"><h5>PID Pozycji</h5>
                        <div class="setting-container"> <label for="positionKpInput">Kp - Sila powrotu</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="positionKpInput" step="0.1" value="0.0"><button>+</button></div> </div>
                        <div class="setting-container"> <label for="positionKiInput">Ki - Korekta</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="positionKiInput" step="0.001" value="0.0"><button>+</button></div> </div>
                        <div class="setting-container"> <label for="positionKdInput">Kd - Hamowanie</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="positionKdInput" step="0.05" value="0.0"><button>+</button></div> </div>
                        <div class="setting-container"> <label for="maxTargetSpeedInput">Max. predkosc z PID Poz. (imp/s)</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="maxTargetSpeedInput" step="50" value="1000"><button>+</button></div> </div>
                        <div class="setting-container"> <label for="positionDeadbandInput">Margines bledu (imp.)</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="positionDeadbandInput" step="1" value="15"><button>+</button></div> </div>
                        <div class="setting-container"> <label for="positionIntegralLimitInput">Limit Integratora</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="positionIntegralLimitInput" step="10" value="100"><button>+</button></div> </div>
                        <div class="setting-container"> <label for="positionFilterAlphaInput">Filtr Pochodnej (%)</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="positionFilterAlphaInput" min="1" max="100" step="1" value="90"><button>+</button></div> </div>
                    </div>
                </div>
                <button class="accordion-header" onclick="toggleAccordion(this)">5. PID Obrotu i Kursu</button>
                <div class="accordion-content">
                    <div class="parameter-group"><h5>PID Obrotu (Autonomiczny)</h5>
                        <div class="setting-container"> <label for="rotationKpInput">Kp - Sila obrotu</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="rotationKpInput" step="0.1" value="0.0"><button>+</button></div> </div>
                        <div class="setting-container"> <label for="rotationKdInput">Kd - Tlumienie</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="rotationKdInput" step="0.1" value="0.0"><button>+</button></div> </div>
                    </div>
                    <div class="parameter-group"><h5>PID Utrzymania Kursu (podczas jazdy prosto)</h5>
                        <div class="setting-container"> <label for="headingKpInput">Kp - Sila korekty</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="headingKpInput" step="0.05" value="0.0"><button>+</button></div> </div>
                        <div class="setting-container"> <label for="headingKiInput">Ki - Precyzja</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="headingKiInput" step="0.005" value="0.0"><button>+</button></div> </div>
                        <div class="setting-container"> <label for="headingKdInput">Kd - Tlumienie</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="headingKdInput" step="0.01" value="0.0"><button>+</button></div> </div>
                    </div>
                </div>
            </div>
            <div class="button-group" style="display:flex; gap:10px; justify-content:center; margin-top:20px;">
                <button id="loadBtn">Wczytaj z Robota</button>
                <button id="saveBtn">Zapisz na Robocie</button>
            </div>
        </div>

        <div class="card">
            <h2>Auto Strojenie</h2>
            <button class="accordion-header" onclick="toggleAccordion(this)">1: Pierwsze Strojenie (Odkrywanie Z-N)</button>
            <div class="accordion-content">
                 <div class="help-text visible" style="max-height: 200px; padding: 10px;">Automatyczne znalezienie podstawowych, dzialajacych parametrow Kp i Kd dla balansu. Robot sam wprowadzi sie w oscylacje, aby zbadac swoja fizyke.</div>
                <fieldset style="margin-top:15px;">
                    <legend>Parametry Procedury Z-N</legend>
                    <div class="setting-container">
                        <label for="znMaxAmplitudeInput">Max. amplituda (st.)</label>
                        <div class="numeric-input-wrapper"><button>-</button><input type="number" id="znMaxAmplitudeInput" min="5" max="25" step="1" value="15"><button>+</button></div>
                    </div>
                </fieldset>
                <div id="znTuningStatusPanel" style="margin-top:15px;">
                    <h5>Status Procedury</h5>
                    <div class="info-grid">
                        <strong>Status:</strong> <span id="znStatusText" style="font-weight: bold;">Bezczynny</span>
                        <strong>Testowane Kp:</strong> <span id="znKpTestVal">---</span>
                        <strong>Amplituda:</strong> <span id="znAmplitudeVal">---</span>
                    </div>
                </div>
                <div id="znResultPanel">
                    <h5>Wynik Odkrywania</h5>
                    <div class="result-grid">
                        <strong>Wzmocnienie Krytyczne (Ku):</strong> <span id="znKuResult"></span>
                        <strong>Okres Krytyczny (Tu):</strong> <span id="znTuResult"></span>
                        <hr style="grid-column: 1 / -1; border-color: #4a4f58;">
                        <strong>Sugerowane Kp:</strong> <span id="znKpSuggest"></span>
                        <strong>Sugerowane Kd:</strong> <span id="znKdSuggest"></span>
                    </div>
                    <button id="applyZnResultsBtn" class="apply-btn">Zastosuj do Panelu</button>
                </div>
                <button id="znTuningActionBtn" style="width:100%; margin-top:15px; background-color: #f7b731;">Rozpocznij Odkrywanie</button>
                <button id="znTuningCancelBtn" style="width:100%; margin-top:10px; background-color:#ff6347; display:none;">Anuluj</button>
            </div>
            <button class="accordion-header" onclick="toggleAccordion(this)">2: Optymalizacja Petli Balansu (GA)</button>
            <div class="accordion-content">
                <div class="help-text visible" style="max-height: 200px; padding: 10px;">Uruchomienie inteligentnej optymalizacji (algorytm genetyczny) w celu znalezienia optymalnych nastaw Kp i Kd dla petli balansu, aby robot stal idealnie stabilnie.</div>
                <fieldset>
                    <legend>Parametry Algorytmu Genetycznego</legend>
                    <div class="setting-container">
                        <label for="gaGenerationsInput">Liczba pokolen</label>
                        <div class="numeric-input-wrapper"><button>-</button><input type="number" id="gaGenerationsInput" min="2" max="50" step="1" value="10"><button>+</button></div>
                    </div>
                    <div class="setting-container">
                        <label for="gaPopulationInput">Liczba osobnikow</label>
                        <div class="numeric-input-wrapper"><button>-</button><input type="number" id="gaPopulationInput" min="4" max="20" step="1" value="10"><button>+</button></div>
                    </div>
                </fieldset>
                <div id="gaStatusPanel">
                    <h5>Status Sesji Optymalizacji</h5>
                    <div class="info-grid">
                        <strong>Postep:</strong> <span id="gaStatusGeneration">---</span>
                        <strong>Najmniejszy blad sesji:</strong> <span id="gaStatusBestScore" style="font-weight: bold; color: #a2f279;">---</span>
                        <strong>Najmniejszy blad pokolenia:</strong> <span id="gaStatusGenerationBestScore" style="font-weight: bold; color: #61dafb;">---</span>
                        <strong>Testowane Kp:</strong> <span id="gaStatusCurrentKp">---</span>
                        <strong>Testowane Kd:</strong> <span id="gaStatusCurrentKd">---</span>
                        <strong>Status:</strong> <span id="gaStatusStateText" style="font-weight: bold;">Bezczynny</span>
                    </div>
                    <progress id="gaProgressBar" value="0" max="100" style="margin-top:10px;"></progress>
                </div>
                <div id="gaResultsPanel" class="test-results-panel">
                    <h5>Wyniki Optymalizacji GA</h5>
                    <div class="result-grid">
                        <strong>Najlepszy Blad:</strong> <span id="gaFinalScore"></span>
                        <strong>Znalezione Kp_b:</strong> <span id="gaFinalKp"></span>
                        <strong>Znalezione Kd_b:</strong> <span id="gaFinalKd"></span>
                    </div>
                    <button id="applyGaResultsBtn" class="apply-btn">Zastosuj do Panelu</button>
                </div>
                <div class="ga-button-row">
                    <button id="gaActionBtn">Rozpocznij</button>
                    <button id="gaPauseBtn" style="background-color: #f7b731; display: none;">Pauzuj</button>
                    <button id="gaCancelBtn" style="background-color: #ff6347; display: none;">Zatrzymaj</button>
                </div>
            </div>
            <button class="accordion-header" onclick="toggleAccordion(this)">3: Asystent Strojenia Petli Kaskadowych</button>
            <div class="accordion-content">
                <div class="help-text visible" style="max-height: 200px; padding: 10px;">Uruchomienie serii inteligentnych testow, ktore krok po kroku pomoga Ci znalezc optymalne nastawy dla petli balansu, pozycji i predkosci. Asystent analizuje zachowanie robota i sugeruje najlepsze poprawki.</div>
                 <fieldset>
                    <legend>Krok 3.1: Strojenie Petli Balansu</legend>
                    <div class="help-text visible" style="max-height: 200px; padding: 10px; grid-column: 1 / -1;">Cel: Znalezc Kp i Kd, ktore zapewnia szybka i stabilna reakcje na zadany kat, bez oscylacji.</div>
                     <div class="setting-container">
                        <label for="balanceStepAngleInput">Kat "pchniecia" (st.)</label>
                        <div class="numeric-input-wrapper"><button>-</button><input type="number" id="balanceStepAngleInput" step="0.5" value="2.0" min="0.5" max="5.0"><button>+</button></div>
                    </div>
                    <button id="startBalanceTestBtn" style="width:100%; margin-top:10px; background-color: #f7b731;">Uruchom Test Odpowiedzi Skokowej</button>
                    <div id="balanceTuningResultsPanel" class="test-results-panel">
                        <h5>Wyniki Testu</h5>
                        <div id="balanceTestMetrics" class="result-grid"></div>
                        <div class="suggestion-grid">
                             <h5>Sugestia Asystenta</h5>
                            <div id="balanceSuggestion" class="result-grid"></div>
                            <div class="suggestion-actions">
                                <button class="applyAndRerunBtn" data-type="balance">Zastosuj i Powtorz</button>
                                <button class="applyBtn" data-type="balance">Zastosuj do Panelu</button>
                            </div>
                        </div>
                    </div>
                </fieldset>
                <fieldset style="margin-top: 20px;">
                    <legend>Krok 3.2: Strojenie Petli Pozycji</legend>
                    <div class="help-text visible" style="max-height: 200px; padding: 10px; grid-column: 1 / -1;">Cel: Znalezc Kp, Ki, Kd, aby robot po wytraceniu z rownowagi jak najszybciej i najstabilniej wrocil do punktu startowego.</div>
                     <div class="setting-container">
                        <label for="positionTestImpulseInput">Sila impulsu (PWM)</label>
                        <div class="numeric-input-wrapper"><button>-</button><input type="number" id="positionTestImpulseInput" step="10" value="700" min="200" max="1023"><button>+</button></div>
                    </div>
                    <button id="startPositionTestBtn" style="width:100%; margin-top:10px; background-color: #f7b731;">Uruchom Test Impulsu</button>
                    <div id="positionTuningResultsPanel" class="test-results-panel">
                        <h5>Wyniki Testu</h5>
                        <div id="positionTestMetrics" class="result-grid"></div>
                        <div class="suggestion-grid">
                             <h5>Sugestia Asystenta</h5>
                            <div id="positionSuggestion" class="result-grid"></div>
                            <div class="suggestion-actions">
                                <button class="applyAndRerunBtn" data-type="position">Zastosuj i Powtorz</button>
                                <button class="applyBtn" data-type="position">Zastosuj do Panelu</button>
                            </div>
                        </div>
                    </div>
                </fieldset>
                <fieldset style="margin-top: 20px;">
                    <legend>Krok 3.3: Strojenie Petli Predkosci</legend>
                     <div class="help-text visible" style="max-height: 200px; padding: 10px; grid-column: 1 / -1;">Cel: Znalezc nastawy dla petli predkosci, aby robot precyzyjnie i plynnie wykonywal zadania ruchowe.</div>
                     <div class="setting-container">
                        <label for="speedTestDistanceInput">Dystans (cm)</label>
                        <div class="numeric-input-wrapper"><button>-</button><input type="number" id="speedTestDistanceInput" step="10" value="100" min="10" max="500"><button>+</button></div>
                    </div>
                    <div class="setting-container">
                        <label for="speedTestSpeedInput">Predkosc (cm/s)</label>
                        <div class="numeric-input-wrapper"><button>-</button><input type="number" id="speedTestSpeedInput" step="5" value="50" min="10" max="200"><button>+</button></div>
                    </div>
                    <button id="startSpeedTestBtn" style="width:100%; margin-top:10px; background-color: #f7b731;">Uruchom Test Jazdy</button>
                     <div id="speedTuningResultsPanel" class="test-results-panel">
                        <h5>Wyniki Testu</h5>
                        <div id="speedTestMetrics" class="result-grid"></div>
                         <div class="suggestion-grid">
                             <h5>Sugestia Asystenta</h5>
                            <div id="speedSuggestion" class="result-grid"></div>
                             <div class="suggestion-actions">
                                <button class="applyAndRerunBtn" data-type="speed">Zastosuj i Powtorz</button>
                                <button class="applyBtn" data-type="speed">Zastosuj do Panelu</button>
                            </div>
                        </div>
                    </div>
                </fieldset>
            </div>
        </div>

        <div class="card" id="log-card" style="grid-column: 1 / -1;">
            <h2>Logi Systemowe</h2>
            <div id="log-history"></div>
            <div style="margin-top: 10px; display: flex; gap: 10px; justify-content: center; align-items: center;">
                <button onclick="clearLogs()" style="background-color: #f7b731;">Wyczysc Logi</button>
            </div>
        </div>
    </div>

<script>
    // =======================================================================================
    // WERSJA 21.0 (Zintegrowane zaawansowane moduly strojenia, poprawki logiki walidacji)
    // ZMIANY DLA BNO055:
    // - Poprawiono logike i opis przycisku kalibracji sensora.
    // - Skorygowano mapowanie parametru 'balance_pid_derivative_filter_alpha'.
    // =======================================================================================
    const AppState = { isConnected: false, isSynced: false, isApplyingConfig: false, lastKnownRobotState: 'IDLE', isSequenceRunning: false, isTuningActive: false, syncTimeout: null, activeTuner: null };
    let currentSequenceStep = 0;
    const MAX_SEQUENCE_STEPS = 10;
    // [ZMIANA] Poprawiono klucz 'balance_pid_derivative_filter_alpha'
    const parameterMapping = { 'balanceKpInput': 'kp_b', 'balanceKiInput': 'ki_b', 'balanceKdInput': 'kd_b', 'balanceFilterAlphaInput': 'balance_pid_derivative_filter_alpha', 'balanceIntegralLimitInput': 'balance_pid_integral_limit', 'joystickAngleSensitivityInput': 'joystick_angle_sensitivity', 'speedKpInput': 'kp_s', 'speedKiInput': 'ki_s', 'speedKdInput': 'kd_s', 'speedFilterAlphaInput': 'speed_pid_filter_alpha', 'maxTargetAngleInput': 'max_target_angle_from_speed_pid', 'speedIntegralLimitInput': 'speed_pid_integral_limit', 'speedDeadbandInput': 'speed_pid_deadband', 'positionKpInput': 'kp_p', 'positionKiInput': 'ki_p', 'positionKdInput': 'kd_p', 'positionFilterAlphaInput': 'position_pid_filter_alpha', 'maxTargetSpeedInput': 'max_target_speed_from_pos_pid', 'positionIntegralLimitInput': 'position_pid_integral_limit', 'positionDeadbandInput': 'position_pid_deadband', 'rotationKpInput': 'kp_r', 'rotationKdInput': 'kd_r', 'headingKpInput': 'kp_h', 'headingKiInput': 'ki_h', 'headingKdInput': 'kd_h', 'joystickSensitivityInput': 'joystick_sensitivity', 'expoJoystickInput': 'expo_joystick', 'maxSpeedJoystickInput': 'max_speed_joystick', 'turnFactorInput': 'turn_factor', 'joystickDeadzoneInput': 'joystick_deadzone', 'wheelDiameterInput': 'wheel_diameter_cm', 'trackWidthInput': 'track_width_cm', 'encoderPprInput': 'encoder_ppr', 'minPwmLeftFwdInput': 'min_pwm_left_fwd', 'minPwmLeftBwdInput': 'min_pwm_left_bwd', 'minPwmRightFwdInput': 'min_pwm_right_fwd', 'minPwmRightBwdInput': 'min_pwm_right_bwd' };
    let currentTestType = null, telemetryForCurrentTest = [];
    let bleDevice, rxCharacteristic, txCharacteristic;
    const SERVICE_UUID = "4fafc201-1fb5-459e-8fcc-c5c9c331914b", RX_UUID = "beb5483e-36e1-4688-b7f5-ea07361b26a9", TX_UUID = "beb5483e-36e1-4688-b7f5-ea07361b26a8";
    let bleBuffer = '', bleMessageQueue = [], isSendingBleMessage = false; const bleChunks = new Map();
    const BLE_SEND_INTERVAL = 20;
    let joystickCenter, joystickRadius, knobRadius, isDragging = false, lastJoystickSendTime = 0;
    const JOYSTICK_SEND_INTERVAL = 20;
    let gamepadIndex = null, lastGamepadState = [], gamepadMappings = {}; const GAMEPAD_MAPPING_KEY = 'pid_gamepad_mappings_v3';
    let isMappingButton = false, actionToMap = null;
    const CUSTOM_PRESET_PREFIX = 'pid_custom_preset_v3_';
    const availableActions = { 'toggle_balance': { label: 'Wlacz/Wylacz Balansowanie', elementId: 'balanceSwitch' }, 'toggle_hold_position': { label: 'Wlacz/Wylacz Trzymanie Pozycji', elementId: 'holdPositionSwitch' }, 'toggle_speed_mode': { label: 'Wlacz/Wylacz Tryb Predkosci', elementId: 'speedModeSwitch' }, 'emergency_stop': { label: 'STOP AWARYJNY', elementId: 'emergencyStopBtn' }, 'reset_zero': { label: 'Resetuj Osie', elementId: 'resetZeroBtn' }, 'trim_plus': { label: 'Korekta Pionu (+)', elementId: 'trimPlusBtn' }, 'trim_minus': { label: 'Korekta Pionu (-)', elementId: 'trimMinusBtn' } };
    const availableTelemetry = { 'pitch': { label: 'Pitch (Kat)', color: '#61dafb' }, 'roll': { label: 'Roll (Przechyl)', color: '#a2f279' }, 'speed': { label: 'Predkosc', color: '#f7b731'}, 'target_speed': { label: 'Predkosc Zadana', color: '#ff9f43' }, 'output': { label: 'Wyjscie PID', color: '#ff6347'}, 'encoder_left': { label: 'Enkoder L', color: '#9966ff' } };
    const builtInPresetsData = { '1': { name: "1. PID Zbalansowany (Startowy)", params: { balanceKpInput: 95.0, balanceKiInput: 0.0, balanceKdInput: 3.23 }}, '2': { name: "2. PID Mieciutki (Plynny)", params: { balanceKpInput: 80.0, balanceKiInput: 0.0, balanceKdInput: 2.8 }}, '3': { name: "3. PID Agresywny (Sztywny)", params: { balanceKpInput: 110.0, balanceKiInput: 0.0, balanceKdInput: 4.0 }} };
    let scene3D, camera3D, renderer3D, controls3D, robotPivot, leftWheel, rightWheel, groundMesh, groundTexture;
    let currentPitch3D = 0, currentRoll3D = 0, currentYaw3D = 0, currentEncoderLeft = 0, currentEncoderRight = 0;
    let isAnimation3DEnabled = true, isMovement3DEnabled = false, lastEncoderAvg = 0;
    let gaInstance = null;
    window.telemetryData = {}; // Globalna zmienna dla telemetrii, uzywana przez tunery

    // =======================================================================================
    // === NOWY, ZAAWANSOWANY TUNER ZIEGLER-NICHOLS (Z INFO.TXT) ===
    // =======================================================================================
    class ZieglerNicholsTuner { 
        constructor() { 
            this.reset(); 
            // Konfiguracja 
            this.kpStep = 0.5; // Poczatkowy krok Kp 
            this.kpStepMultiplier = 1.5; // Mnoznik przyspieszenia 
            this.maxKp = 120.0; // Bezpieczny limit 
            this.minKp = 10.0; // Minimalny Kp 
            this.maxTuningTime = 120000; // 2 min timeout 
            this.maxAmplitude = 15.0; // Maks amplituda (stopnie) 
            // Wykrywanie oscylacji 
            this.minRequiredPeriods = 3; // Min okresow do potwierdzenia 
            this.maxRequiredPeriods = 6; // Maks okresow do pomiaru 
            this.amplitudeThreshold = 2.0; // Min amplituda oscylacji 
            this.periodTolerance = 0.15; // 15% tolerancja okresu 
            this.stabilityThreshold = 0.1; // Stabilnosc amplitudy 
            this.updateInterval = 50; // 50ms update rate 
            this.startTime = 0; 
        } 

        reset() { 
            this.state = 'IDLE'; // IDLE, SEARCHING, DETECTING, MEASURING, FINISHED, ERROR 
            this.kp = 0.5; 
            this.pitchHistory = []; 
            this.timeHistory = []; 
            this.periods = []; 
            this.amplitudes = []; 
            this.lastPeakTime = 0; 
            this.lastPeakValue = 0; 
            this.lastValleyTime = 0; 
            this.lastValleyValue = 0; 
            this.peakCount = 0; 
            this.isGoingUp = null; 
            this.consecutiveStablePeriods = 0; 
            this.adaptiveStepEnabled = true; 
        } 

        start(onUpdate, onFinish, onError) { 
            this.onUpdate = onUpdate; 
            this.onFinish = onFinish; 
            this.onError = onError; 
            this.reset(); 
            this.state = 'SEARCHING'; 
            this.startTime = Date.now(); 
            addLogMessage('[ZN-Tuner] Rozpoczynam auto-tuning Ziegler-Nichols', 'info'); 
            // Wyslij poczatkowe parametry 
            this.updateRobotParams(); 
            // Uruchom timer aktualizacji 
            this.timer = setInterval(() => this.update(), this.updateInterval); 
        } 

        stop() { 
            if (this.timer) { 
                clearInterval(this.timer); 
                this.timer = null; 
            } 
            this.state = 'IDLE'; 
            addLogMessage('[ZN-Tuner] Auto-tuning zatrzymany', 'warn'); 
        } 

        update() { 
            if (this.state === 'IDLE' || this.state === 'FINISHED' || this.state === 'ERROR') { 
                return; 
            } 
            // Sprawdz timeout 
            if (Date.now() - this.startTime > this.maxTuningTime) { 
                this.handleError('Timeout auto-tuningu (2 min)'); 
                return; 
            } 
            // Pobierz aktualny pitch z telemetrii robota 
            const currentPitch = this.getCurrentPitch(); 
            const currentTime = Date.now(); 
            // Sprawdz bezpieczenstwo 
            if (Math.abs(currentPitch) > this.maxAmplitude) { 
                this.handleError(`Zbyt duza amplituda: ${currentPitch.toFixed(2)}°`); 
                return; 
            } 
            if (this.kp > this.maxKp) { 
                this.handleError(`Przekroczono maksymalny Kp: ${this.kp.toFixed(2)}`); 
                return; 
            } 
            // Dodaj do historii 
            this.pitchHistory.push(currentPitch); 
            this.timeHistory.push(currentTime); 
            // Ogranicz historie do ostatnich 200 probek 
            if (this.pitchHistory.length > 200) { 
                this.pitchHistory.shift(); 
                this.timeHistory.shift(); 
            } 
            switch (this.state) { 
                case 'SEARCHING': 
                    this.handleSearchingState(currentPitch, currentTime); 
                    break; 
                case 'DETECTING': 
                    this.handleDetectingState(currentPitch, currentTime); 
                    break; 
                case 'MEASURING': 
                    this.handleMeasuringState(currentPitch, currentTime); 
                    break; 
            } 
            // Wyslij aktualizacje 
            this.onUpdate({ 
                kp: this.kp, 
                amplitude: this.getCurrentAmplitude(), 
                state: this.state, 
                periods: this.periods.length, 
                avgPeriod: this.getAveragePeriod() 
            }); 
        } 

        handleSearchingState(currentPitch, currentTime) { 
            // Sprawdz czy sa juz jakies oscylacje 
            if (this.pitchHistory.length >= 20) { 
                const recentAmplitude = this.getRecentAmplitude(); 
                if (recentAmplitude > this.amplitudeThreshold) { 
                    addLogMessage(`[ZN-Tuner] Wykryto oscylacje (amp: ${recentAmplitude.toFixed(2)}°), przechodze do detekcji`, 'info'); 
                    this.state = 'DETECTING'; 
                    this.resetOscillationDetection(); 
                    return; 
                } 
            } 
            // Zwieksz Kp 
            this.increaseKp(); 
        } 

        handleDetectingState(currentPitch, currentTime) { 
            // Wykrywaj ekstrema 
            this.detectExtrema(currentPitch, currentTime); 
            // Sprawdz czy mamy wystarczajaco okresow 
            if (this.periods.length >= this.minRequiredPeriods) { 
                // Sprawdz stabilnosc okresow 
                if (this.arePeriodsStable()) { 
                    addLogMessage(`[ZN-Tuner] Wykryto stabilne oscylacje, rozpoczynam precyzyjny pomiar`, 'success'); 
                    this.state = 'MEASURING'; 
                    this.consecutiveStablePeriods = 0; 
                } else { 
                    // Jesli okresy niestabilne, zwieksz Kp nieznacznie 
                    if (this.periods.length >= 5) { 
                        this.kp += this.kpStep * 0.1; // Maly krok 
                        this.updateRobotParams(); 
                        this.resetOscillationDetection(); 
                    } 
                } 
            } else { 
                // Za malo okresow, sprawdz czy nie trzeba zwiekszyc Kp 
                const recentAmplitude = this.getRecentAmplitude(); 
                if (recentAmplitude < this.amplitudeThreshold) { 
                    this.increaseKp(); 
                    this.resetOscillationDetection(); 
                } 
            } 
        } 

        handleMeasuringState(currentPitch, currentTime) { 
            // Kontynuuj wykrywanie ekstremow 
            this.detectExtrema(currentPitch, currentTime); 
            // Sprawdz czy mamy wystarczajaco precyzyjnych pomiarow 
            if (this.periods.length >= this.maxRequiredPeriods) { 
                this.finishTuning(); 
            } else if (!this.arePeriodsStable() && this.periods.length >= 8) { 
                // Jesli w trakcie pomiaru stracimy stabilnosc, sprobuj lekko zwiekszyc Kp 
                this.kp += this.kpStep * 0.05; 
                this.updateRobotParams(); 
                this.resetOscillationDetection(); 
                this.state = 'DETECTING'; 
            } 
        } 

        detectExtrema(currentPitch, currentTime) { 
            if (this.pitchHistory.length < 3) return; 
            const prev = this.pitchHistory[this.pitchHistory.length - 2]; 
            const current = currentPitch; 
            const prevPrev = this.pitchHistory[this.pitchHistory.length - 3]; 
            // Wykrywanie maksimum lokalnego 
            if (prev > prevPrev && prev > current && Math.abs(prev) > this.amplitudeThreshold * 0.5) { 
                if (this.lastPeakTime > 0) { 
                    const period = (this.timeHistory[this.timeHistory.length - 2] - this.lastPeakTime) / 1000.0; 
                    if (period > 0.1 && period < 10.0) { // Sensowny zakres okresu 
                        this.periods.push(period); 
                        this.amplitudes.push(Math.abs(prev)); 
                        // Ogranicz historie 
                        if (this.periods.length > 10) { 
                            this.periods.shift(); 
                            this.amplitudes.shift(); 
                        } 
                    } 
                } 
                this.lastPeakTime = this.timeHistory[this.timeHistory.length - 2]; 
                this.lastPeakValue = prev; 
            } 
            // Wykrywanie minimum lokalnego 
            if (prev < prevPrev && prev < current && Math.abs(prev) > this.amplitudeThreshold * 0.5) { 
                this.lastValleyTime = this.timeHistory[this.timeHistory.length - 2]; 
                this.lastValleyValue = prev; 
            } 
        } 

        arePeriodsStable() { 
            if (this.periods.length < this.minRequiredPeriods) return false; 
            const recentPeriods = this.periods.slice(-this.minRequiredPeriods); 
            const avgPeriod = recentPeriods.reduce((a, b) => a + b, 0) / recentPeriods.length; 
            // Sprawdz czy wszystkie okresy sa w tolerancji 
            for (let period of recentPeriods) { 
                if (Math.abs(period - avgPeriod) / avgPeriod > this.periodTolerance) { 
                    return false; 
                } 
            } 
            // Sprawdz stabilnosc amplitudy 
            if (this.amplitudes.length >= this.minRequiredPeriods) { 
                const recentAmps = this.amplitudes.slice(-this.minRequiredPeriods); 
                const avgAmp = recentAmps.reduce((a, b) => a + b, 0) / recentAmps.length; 
                for (let amp of recentAmps) { 
                    if (Math.abs(amp - avgAmp) / avgAmp > this.stabilityThreshold) { 
                        return false; 
                    } 
                } 
            } 
            return true; 
        } 

        increaseKp() { 
            const oldKp = this.kp; 
            // Adaptacyjny krok - im blizej celu, tym mniejszy krok 
            if (this.adaptiveStepEnabled) { 
                const recentAmplitude = this.getRecentAmplitude(); 
                if (recentAmplitude > this.amplitudeThreshold * 0.5) { 
                    this.kpStep = Math.max(this.kpStep * 0.7, 0.01); // Zmniejsz krok 
                } else if (recentAmplitude < this.amplitudeThreshold * 0.2) { 
                    this.kpStep = Math.min(this.kpStep * this.kpStepMultiplier, 1.0); // Zwieksz krok 
                } 
            } 
            this.kp += this.kpStep; 
            if (this.kp > this.maxKp) { 
                this.handleError(`Nie udalo sie znalezc punktu krytycznego do Kp=${this.maxKp}`); 
                return; 
            } 
            addLogMessage(`[ZN-Tuner] Zwiekszam Kp: ${oldKp.toFixed(3)} -> ${this.kp.toFixed(3)}`, 'info'); 
            this.updateRobotParams(); 
        } 

        finishTuning() { 
            clearInterval(this.timer); 
            this.timer = null; 
            const ku = this.kp; 
            const tu = this.getAveragePeriod(); 
            // Walidacja wynikow 
            if (ku < this.minKp || tu < 0.1 || tu > 10.0) { 
                this.handleError(`Nieprawidlowe wyniki: Ku=${ku.toFixed(3)}, Tu=${tu.toFixed(3)}`); 
                return; 
            } 
            this.state = 'FINISHED'; 
            addLogMessage(`[ZN-Tuner] Auto-tuning zakonczony pomyslnie!`, 'success'); 
            addLogMessage(`[ZN-Tuner] Ku = ${ku.toFixed(4)}, Tu = ${tu.toFixed(4)}s`, 'success'); 
            // Oblicz parametry ZN 
            const znParams = this.calculateZNParameters(ku, tu); 
            this.onFinish({ 
                ku, 
                tu, 
                periods: [...this.periods], 
                amplitudes: [...this.amplitudes], 
                znParams 
            }); 
        } 

        calculateZNParameters(ku, tu) { 
            // Klasyczne wzory Ziegler-Nichols dla regulatora PID 
            return { 
                // P controller 
                p_only: { kp: 0.5 * ku, ki: 0, kd: 0 }, 
                // PI controller 
                pi: { kp: 0.45 * ku, ki: (0.45 * ku) / (tu / 1.2), kd: 0 }, 
                // PID controller (klasyczny) 
                pid_classic: { kp: 0.6 * ku, ki: (0.6 * ku) / (tu / 2.0), kd: (0.6 * ku) * (tu / 8.0) }, 
                // PID controller (some overshoot) 
                pid_some_overshoot: { kp: 0.33 * ku, ki: (0.33 * ku) / (tu / 2.0), kd: (0.33 * ku) * (tu / 3.0) }, 
                // PID controller (no overshoot) 
                pid_no_overshoot: { kp: 0.2 * ku, ki: (0.2 * ku) / (tu / 2.0), kd: (0.2 * ku) * (tu / 3.0) } 
            }; 
        } 

        handleError(message) { 
            clearInterval(this.timer); 
            this.timer = null; 
            this.state = 'ERROR'; 
            addLogMessage(`[ZN-Tuner] BLAD: ${message}`, 'error'); 
            // Przywroc bezpieczne parametry 
            sendBleMessage({ type: 'set_param', key: 'kp_b', value: 1.0 }); 
            sendBleMessage({ type: 'set_param', key: 'ki_b', value: 0.0 }); 
            sendBleMessage({ type: 'set_param', key: 'kd_b', value: 0.0 }); 
            this.onError(message); 
        } 

        // Funkcje pomocnicze 
        getCurrentPitch() { 
            // Pobierz z globalnej zmiennej telemetrii 
            return window.telemetryData ? window.telemetryData.pitch : 0; 
        } 

        getCurrentAmplitude() { 
            if (this.amplitudes.length === 0) return 0; 
            return this.amplitudes[this.amplitudes.length - 1]; 
        } 

        getRecentAmplitude() { 
            if (this.pitchHistory.length < 10) return 0; 
            const recent = this.pitchHistory.slice(-20); 
            const max = Math.max(...recent); 
            const min = Math.min(...recent); 
            return max - min; 
        } 

        getAveragePeriod() { 
            if (this.periods.length === 0) return 0; 
            return this.periods.reduce((a, b) => a + b, 0) / this.periods.length; 
        } 

        resetOscillationDetection() { 
            this.periods = []; 
            this.amplitudes = []; 
            this.lastPeakTime = 0; 
            this.lastValleyTime = 0; 
            this.peakCount = 0; 
        } 

        updateRobotParams() { 
            sendBleMessage({ type: 'set_param', key: 'kp_b', value: this.kp }); 
            sendBleMessage({ type: 'set_param', key: 'ki_b', value: 0 }); 
            sendBleMessage({ type: 'set_param', key: 'kd_b', value: 0 }); 
        } 
    }

    // =======================================================================================
    // === NOWY, ZAAWANSOWANY ALGORYTM GENETYCZNY (Z INFO2.TXT) ===
    // =======================================================================================
    class GeneticAlgorithm { 
        constructor(options) { 
            this.options = Object.assign({ 
                populationSize: 10, 
                generations: 10, 
                mutationRate: 0.15, 
                crossoverRate: 0.8, 
                elitism: 0.2, 
                // Realistyczne zakresy dla robota balansujacego 
                paramRanges: { 
                    kp: [1.0, 25.0], // Kp balance 
                    kd: [0.1, 2.5] // Kd balance 
                }, 
                // Nowe parametry optymalizacji 
                tournamentSize: 3, 
                adaptiveMutation: true, 
                diversityThreshold: 0.01, 
                restartThreshold: 0.005, 
                convergenceCheck: true, 
                maxStagnantGenerations: 5, 
                penaltyWeight: 1000 
            }, options); 
            this.population = []; 
            this.generation = 0; 
            this.isPaused = false; 
            this.isCancelled = false; 
            this.bestFitnessHistory = []; 
            this.diversityHistory = []; 
            this.stagnantGenerations = 0; 
            this.globalBest = null; 
        } 

        async run() { 
            this.isCancelled = false; 
            this.isPaused = false; 
            this.generation = 0; 
            this.bestFitnessHistory = []; 
            this.diversityHistory = []; 
            this.stagnantGenerations = 0; 
            this.globalBest = null; 
            addLogMessage('[GA] Rozpoczynam optymalizacje algorytmem genetycznym', 'info'); 
            this._initializePopulation(); 
            await this._evaluatePopulation(); 
            this._updateBestAndStats(); 

            for (this.generation = 1; this.generation <= this.options.generations; this.generation++) { 
                if (this.isCancelled) break; 
                addLogMessage(`[GA] Generacja ${this.generation}/${this.options.generations}`, 'info'); 
                this.options.onGenerationStart?.(this.generation, this.population, { 
                    bestFitness: this.globalBest?.fitness, 
                    diversity: this._calculateDiversity(), 
                    convergence: this._calculateConvergence() 
                }); 

                // Sprawdz stagnacje i ewentualnie zrestartuj czesc populacji 
                if (this._checkStagnation()) { 
                    addLogMessage(`[GA] Wykryto stagnacje, restartuje 30% populacji`, 'warn'); 
                    this._injectRandomIndividuals(Math.floor(this.options.populationSize * 0.3)); 
                    await this._evaluateNewIndividuals(); 
                    this.stagnantGenerations = 0; 
                } 

                const newPopulation = this._createNewGeneration(); 
                this.population = newPopulation; 
                await this._evaluatePopulation(); 
                this._updateBestAndStats(); 

                // Sprawdz konwergencje 
                if (this.options.convergenceCheck && this._hasConverged()) { 
                    addLogMessage(`[GA] Algorytm skonwergowal w generacji ${this.generation}`, 'success'); 
                    break; 
                } 
            } 

            if (!this.isCancelled) { 
                addLogMessage(`[GA] Optymalizacja zakonczona. Najlepszy wynik: ${this.globalBest.fitness.toFixed(4)}`, 'success'); 
                this.options.onFinish?.(this.globalBest, { 
                    generations: this.generation, 
                    fitnessHistory: this.bestFitnessHistory, 
                    diversityHistory: this.diversityHistory, 
                    finalDiversity: this._calculateDiversity() 
                }); 
            } 
        } 

        pause() { 
            this.isPaused = true; 
            addLogMessage('[GA] Optymalizacja wstrzymana', 'warn'); 
        } 

        resume() { 
            this.isPaused = false; 
            addLogMessage('[GA] Optymalizacja wznowiona', 'info'); 
        } 

        cancel() { 
            this.isCancelled = true; 
            addLogMessage('[GA] Optymalizacja anulowana', 'error'); 
        } 

        _initializePopulation() { 
            this.population = []; 
            const { kp, kd } = this.options.paramRanges; 
            // Uzyj Latin Hypercube Sampling dla lepszego pokrycia przestrzeni 
            const kpSamples = this._latinHypercubeSample(this.options.populationSize, kp[0], kp[1]); 
            const kdSamples = this._latinHypercubeSample(this.options.populationSize, kd[0], kd[1]); 
            for (let i = 0; i < this.options.populationSize; i++) { 
                this.population.push({ 
                    kp: kpSamples[i], 
                    kd: kdSamples[i], 
                    fitness: Infinity, 
                    age: 0, 
                    id: Math.random().toString(36).substr(2, 9) 
                }); 
            } 
            addLogMessage(`[GA] Zainicjalizowano populacje ${this.options.populationSize} osobnikow`, 'info'); 
        } 

        _latinHypercubeSample(n, min, max) { 
            const samples = []; 
            for (let i = 0; i < n; i++) { 
                const stratumMin = min + (max - min) * i / n; 
                const stratumMax = min + (max - min) * (i + 1) / n; 
                samples.push(Math.random() * (stratumMax - stratumMin) + stratumMin); 
            } 
            // Shuffle 
            for (let i = samples.length - 1; i > 0; i--) { 
                const j = Math.floor(Math.random() * (i + 1)); 
                [samples[i], samples[j]] = [samples[j], samples[i]]; 
            } 
            return samples; 
        } 

        async _evaluatePopulation() { 
            for (let i = 0; i < this.population.length; i++) { 
                const individual = this.population[i]; 
                if (individual.fitness === Infinity) { 
                    await this._evaluateIndividual(individual, i); 
                } 
            } 
            this.population.sort((a, b) => a.fitness - b.fitness); 
        } 

        async _evaluateNewIndividuals() { 
            for (let i = 0; i < this.population.length; i++) { 
                const individual = this.population[i]; 
                if (individual.fitness === Infinity) { 
                    await this._evaluateIndividual(individual, i); 
                } 
            } 
            this.population.sort((a, b) => a.fitness - b.fitness); 
        } 

        async _evaluateIndividual(individual, index) { 
            while (this.isPaused) { 
                if (this.isCancelled) return; 
                await this._sleep(500); 
            } 
            if (this.isCancelled) return; 

            this.options.onIndividualStart?.(this.generation, index, individual); 
            try { 
                let rawFitness = await this.options.fitnessFunction(individual); 
                // Constraint handling - penalty za nieoptymalne parametry 
                let penalty = 0; 
                // Kara za ekstremalne wartosci 
                if (individual.kp < 0.5 || individual.kp > 50) { 
                    penalty += this.options.penaltyWeight; 
                } 
                if (individual.kd < 0.01 || individual.kd > 5.0) { 
                    penalty += this.options.penaltyWeight * 0.5; 
                } 
                // Kara za potencjalnie niestabilne kombinacje 
                const ratio = individual.kp / individual.kd; 
                if (ratio < 2 || ratio > 50) { 
                    penalty += this.options.penaltyWeight * 0.2; 
                } 
                individual.fitness = rawFitness + penalty; 
                individual.rawFitness = rawFitness; 
                individual.penalty = penalty; 
            } catch (error) { 
                addLogMessage(`[GA] Blad oceny osobnika: ${error.message}`, 'error'); 
                individual.fitness = this.options.penaltyWeight * 10; // Bardzo wysoka kara za blad 
                individual.rawFitness = individual.fitness; 
                individual.penalty = 0; 
            } 
            this.options.onIndividualFinish?.(this.generation, index, individual); 
        } 

        _createNewGeneration() { 
            const newPopulation = []; 
            const eliteCount = Math.floor(this.options.populationSize * this.options.elitism); 

            // Dodaj elite (najlepsze osobniki) 
            for (let i = 0; i < eliteCount; i++) { 
                const elite = { ...this.population[i] }; 
                elite.age++; 
                newPopulation.push(elite); 
            } 

            // Wypelnij reszte populacji przez crossover i mutacje 
            while (newPopulation.length < this.options.populationSize) { 
                const parent1 = this._tournamentSelection(); 
                const parent2 = this._tournamentSelection(); 
                let children; 
                if (Math.random() < this.options.crossoverRate) { 
                    children = this._blendCrossover(parent1, parent2); 
                } else { 
                    children = [{ ...parent1 }, { ...parent2 }]; 
                } 
                children.forEach(child => { 
                    if (newPopulation.length < this.options.populationSize) { 
                        this._mutate(child); 
                        this._clamp(child); 
                        child.fitness = Infinity; // Wymaga ponownej oceny 
                        child.age = 0; 
                        child.id = Math.random().toString(36).substr(2, 9); 
                        newPopulation.push(child); 
                    } 
                }); 
            } 
            return newPopulation; 
        } 

        _tournamentSelection() { 
            let best = null; 
            for (let i = 0; i < this.options.tournamentSize; i++) { 
                const candidate = this.population[Math.floor(Math.random() * this.population.length)]; 
                if (best === null || candidate.fitness < best.fitness) { 
                    best = candidate; 
                } 
            } 
            return { ...best }; // Kopia 
        } 

        _blendCrossover(parent1, parent2) { 
            const alpha = 0.5; 
            const child1 = { fitness: Infinity, age: 0 }; 
            const child2 = { fitness: Infinity, age: 0 }; 
            // Crossover dla Kp 
            const kp_diff = Math.abs(parent1.kp - parent2.kp); 
            const min_kp = Math.min(parent1.kp, parent2.kp) - alpha * kp_diff; 
            const max_kp = Math.max(parent1.kp, parent2.kp) + alpha * kp_diff; 
            child1.kp = Math.random() * (max_kp - min_kp) + min_kp; 
            child2.kp = Math.random() * (max_kp - min_kp) + min_kp; 
            // Crossover dla Kd 
            const kd_diff = Math.abs(parent1.kd - parent2.kd); 
            const min_kd = Math.min(parent1.kd, parent2.kd) - alpha * kd_diff; 
            const max_kd = Math.max(parent1.kd, parent2.kd) + alpha * kd_diff; 
            child1.kd = Math.random() * (max_kd - min_kd) + min_kd; 
            child2.kd = Math.random() * (max_kd - min_kd) + min_kd; 
            return [child1, child2]; 
        } 

        _mutate(individual) { 
            const adaptiveFactor = this.options.adaptiveMutation ? (1.0 - (this.generation / this.options.generations) * 0.7) : 1.0; 
            if (Math.random() < this.options.mutationRate) { 
                const sigma_kp = (this.options.paramRanges.kp[1] - this.options.paramRanges.kp[0]) * 0.1 * adaptiveFactor; 
                individual.kp += this._gaussianRandom() * sigma_kp; 
            } 
            if (Math.random() < this.options.mutationRate) { 
                const sigma_kd = (this.options.paramRanges.kd[1] - this.options.paramRanges.kd[0]) * 0.1 * adaptiveFactor; 
                individual.kd += this._gaussianRandom() * sigma_kd; 
            } 
        } 

        _gaussianRandom() { 
            // Box-Muller transform dla prawdziwej mutacji gaussowskiej 
            if (this._spare !== undefined) { 
                const spare = this._spare; 
                this._spare = undefined; 
                return spare; 
            } 
            const u1 = Math.random(); 
            const u2 = Math.random(); 
            const mag = Math.sqrt(-2.0 * Math.log(u1)); 
            this._spare = mag * Math.cos(2.0 * Math.PI * u2); 
            return mag * Math.sin(2.0 * Math.PI * u2); 
        } 

        _clamp(individual) { 
            const { kp, kd } = this.options.paramRanges; 
            individual.kp = Math.max(kp[0], Math.min(kp[1], individual.kp)); 
            individual.kd = Math.max(kd[0], Math.min(kd[1], individual.kd)); 
        } 

        _calculateDiversity() { 
            if (this.population.length === 0) return 0; 
            const meanKp = this.population.reduce((sum, ind) => sum + ind.kp, 0) / this.population.length; 
            const meanKd = this.population.reduce((sum, ind) => sum + ind.kd, 0) / this.population.length; 
            let totalVariance = 0; 
            this.population.forEach(ind => { 
                totalVariance += Math.pow(ind.kp - meanKp, 2) + Math.pow(ind.kd - meanKd, 2); 
            }); 
            return totalVariance / this.population.length; 
        } 

        _calculateConvergence() { 
            if (this.bestFitnessHistory.length < 2) return 0; 
            const recent = this.bestFitnessHistory.slice(-5); 
            if (recent.length < 2) return 0; 
            const improvement = recent[0] - recent[recent.length - 1]; 
            return improvement / recent[0]; // Wzgledna poprawa 
        } 

        _checkStagnation() { 
            if (this.bestFitnessHistory.length < 3) return false; 
            const diversity = this._calculateDiversity(); 
            // Sprawdz czy roznorodnosc spadla ponizej progu 
            if (diversity < this.options.diversityThreshold) { 
                this.stagnantGenerations++; 
            } else { 
                this.stagnantGenerations = 0; 
            } 
            return this.stagnantGenerations >= this.options.maxStagnantGenerations; 
        } 

        _hasConverged() { 
            if (this.bestFitnessHistory.length < 5) return false; 
            const recent = this.bestFitnessHistory.slice(-5); 
            const improvement = recent[0] - recent[recent.length - 1]; 
            const relativeImprovement = improvement / recent[0]; 
            return relativeImprovement < 0.001; // 0.1% poprawa w ostatnich 5 generacjach 
        } 

        _injectRandomIndividuals(count) { 
            const { kp, kd } = this.options.paramRanges; 
            // Zastap najgorsze osobniki nowymi losowymi 
            for (let i = 0; i < count && i < this.population.length; i++) { 
                const index = this.population.length - 1 - i; 
                this.population[index] = { 
                    kp: Math.random() * (kp[1] - kp[0]) + kp[0], 
                    kd: Math.random() * (kd[1] - kd[0]) + kd[0], 
                    fitness: Infinity, 
                    age: 0, 
                    id: Math.random().toString(36).substr(2, 9) 
                }; 
            } 
        } 

        _updateBestAndStats() { 
            if (this.population.length === 0) return; 
            const currentBest = this.population[0]; 
            if (this.globalBest === null || currentBest.fitness < this.globalBest.fitness) { 
                this.globalBest = { ...currentBest }; 
            } 
            this.bestFitnessHistory.push(currentBest.fitness); 
            this.diversityHistory.push(this._calculateDiversity()); 
            // Ogranicz historie 
            if (this.bestFitnessHistory.length > 100) { 
                this.bestFitnessHistory.shift(); 
                this.diversityHistory.shift(); 
            } 
            this.options.onStatsUpdate?.({ generationBest: currentBest, globalBest: this.globalBest }); 
        } 

        _sleep(ms) { 
            return new Promise(resolve => setTimeout(resolve, ms)); 
        } 

        // Metody pomocnicze dla debugowania 
        getStats() { 
            return { 
                generation: this.generation, 
                bestFitness: this.globalBest?.fitness, 
                averageFitness: this.population.reduce((sum, ind) => sum + ind.fitness, 0) / this.population.length, 
                diversity: this._calculateDiversity(), 
                convergence: this._calculateConvergence(), 
                stagnantGenerations: this.stagnantGenerations 
            }; 
        } 

        getBestIndividual() { 
            return this.globalBest ? { ...this.globalBest } : null; 
        } 
    }

    // ======================================================================================= 
    // === ZAAWANSOWANY ASYSTENT STROJENIA PID Z ANALIZA ODPOWIEDZI (Z INFO3.TXT) === 
    // ======================================================================================= 
    class AdvancedPIDTuningAssistant { 
        constructor() { 
            this.testHistory = []; 
            this.systemModel = null; 
            this.adaptiveThresholds = { 
                overshoot: { good: 2.0, acceptable: 5.0, poor: 10.0 }, 
                settlingTime: { good: 1.5, acceptable: 3.0, poor: 5.0 }, 
                speedError: { good: 5.0, acceptable: 15.0, poor: 25.0 } 
            }; 
            this.learningEnabled = true; 
        } 
        // Ulepszona analiza odpowiedzi pozycji 
        analyzePositionResponseAdvanced(data) { 
            const panel = document.getElementById('positionTuningResultsPanel'); 
            panel.style.display = 'block'; 
            if (data.length < 20) { 
                addLogMessage('[Asystent-Poz] Za malo danych do analizy.', 'error'); 
                return; 
            } 
            const analysis = this.performDetailedPositionAnalysis(data); 
            this.displayPositionMetrics(analysis); 
            const suggestions = this.generateIntelligentPositionSuggestions(analysis); 
            this.displayPositionSuggestions(suggestions); 
            // Zapisz w historii dla uczenia sie 
            if (this.learningEnabled) { 
                this.saveTestResult('position', analysis, suggestions); 
            } 
        } 
        performDetailedPositionAnalysis(data) { 
            const impulsesPerCm = getImpulsesPerCm(); 
            const startPos = (data[0].encoder_left + data[0].encoder_right) / 2; 
            const positions = data.map(d => ((d.encoder_left + d.encoder_right) / 2) - startPos); 
            const positionsCm = positions.map(p => p / impulsesPerCm); 
            const times = data.map(d => d.trial.elapsed_ms / 1000.0); 
            const speeds = data.map(d => d.speed / impulsesPerCm); 
            // 1. ANALIZA PRZEREGULOWANIA 
            const maxOvershoot = Math.max(...positionsCm.map(p => Math.abs(p))); 
            const overshootPercent = (maxOvershoot / Math.abs(positionsCm[positionsCm.length - 1])) * 100; 
            // 2. ANALIZA CZASU NARASTANIA (Rise Time) 
            const finalValue = positionsCm[positionsCm.length - 1]; 
            const tenPercent = finalValue * 0.1; 
            const ninetyPercent = finalValue * 0.9; 
            let riseTime = -1; 
            let t10 = -1, t90 = -1; 
            for (let i = 0; i < positionsCm.length; i++) { 
                if (t10 < 0 && Math.abs(positionsCm[i]) >= Math.abs(tenPercent)) t10 = times[i]; 
                if (t90 < 0 && Math.abs(positionsCm[i]) >= Math.abs(ninetyPercent)) t90 = times[i]; 
                if (t10 >= 0 && t90 >= 0) { 
                    riseTime = t90 - t10; 
                    break; 
                } 
            } 
            // 3. ANALIZA CZASU STABILIZACJI (z adaptacyjnym progiem) 
            const adaptiveSettlingThreshold = Math.max(1.0, Math.abs(finalValue) * 0.05); // 5% of final value 
            let settlingTime = this.calculateSettlingTime(positionsCm, times, adaptiveSettlingThreshold); 
            // 4. ANALIZA OSCYLACJI 
            const oscillationMetrics = this.analyzeOscillations(positionsCm, times); 
            // 5. ANALIZA BLEDU STEADY-STATE 
            const steadyStateError = Math.abs(finalValue - this.getExpectedFinalPosition()); 
            // 6. ANALIZA STABILNOSCI (pole zespolone) 
            const stabilityMargin = this.estimateStabilityMargin(data); 
            // 7. ANALIZA WYDAJNOSCI ENERGETYCZNEJ 
            const energyEfficiency = this.calculateEnergyEfficiency(data); 
            return { 
                overshoot: maxOvershoot, 
                overshootPercent: overshootPercent, 
                riseTime: riseTime, 
                settlingTime: settlingTime, 
                oscillations: oscillationMetrics, 
                steadyStateError: steadyStateError, 
                stability: stabilityMargin, 
                energy: energyEfficiency, 
                rawData: { positions: positionsCm, times: times, speeds: speeds }, 
                quality: this.calculateOverallQuality({ 
                    overshoot: maxOvershoot, 
                    settlingTime: settlingTime, 
                    riseTime: riseTime, 
                    oscillations: oscillationMetrics.dampingRatio 
                }) 
            }; 
        } 
        analyzeOscillations(positions, times) { 
            if (positions.length < 50) return { frequency: 0, dampingRatio: 1.0, peaks: [] }; 
            // Znajdz lokalne ekstrema 
            const peaks = []; 
            for (let i = 1; i < positions.length - 1; i++) { 
                if ((positions[i] > positions[i - 1] && positions[i] > positions[i + 1]) || (positions[i] < positions[i - 1] && positions[i] < positions[i + 1])) { 
                    peaks.push({ index: i, value: positions[i], time: times[i] }); 
                } 
            } 
            if (peaks.length < 2) return { frequency: 0, dampingRatio: 1.0, peaks: [] }; 
            // Oblicz czestotliwosc oscylacji 
            const periods = []; 
            for (let i = 2; i < peaks.length; i += 2) { 
                periods.push(peaks[i].time - peaks[i - 2].time); 
            } 
            const avgPeriod = periods.length > 0 ? periods.reduce((a, b) => a + b, 0) / periods.length : 0; 
            const frequency = avgPeriod > 0 ? 1.0 / avgPeriod : 0; 
            // Oblicz wspolczynnik tlumienia z logDecrement 
            let dampingRatio = 1.0; 
            if (peaks.length >= 4) { 
                const peakAmplitudes = peaks.filter((_, i) => i % 2 === 0).map(p => Math.abs(p.value)); 
                if (peakAmplitudes.length >= 2) { 
                    const logDecrement = Math.log(peakAmplitudes[0] / peakAmplitudes[1]); 
                    dampingRatio = logDecrement / Math.sqrt(Math.PI * Math.PI + logDecrement * logDecrement); 
                } 
            } 
            return { frequency, dampingRatio, peaks: peaks.slice(0, 6) }; 
        } 
        calculateSettlingTime(positions, times, threshold) { 
            const finalValue = positions[positions.length - 1]; 
            // Szukaj od konca - kiedy ostatnio przekroczono prog 
            for (let i = positions.length - 1; i >= Math.floor(positions.length * 0.3); i--) { 
                if (Math.abs(positions[i] - finalValue) > threshold) { 
                    return times[i]; 
                } 
            } 
            return times[Math.floor(positions.length * 0.3)]; // Jesli nie znaleziono, zwroc punkt 30% 
        } 
        estimateStabilityMargin(data) { 
            // Prosta heurystyka stabilnosci na podstawie nachylenia koncowego 
            if (data.length < 10) return 0.5; 
            const lastTen = data.slice(-10); 
            const positions = lastTen.map(d => (d.encoder_left + d.encoder_right) / 2); 
            const trend = this.calculateLinearTrend(positions); 
            // Im mniejszy trend (slope), tym lepiej 
            const marginEstimate = Math.max(0, 1.0 - Math.abs(trend) * 100); 
            return marginEstimate; 
        } 
        calculateEnergyEfficiency(data) { 
            // Efektywnosc energetyczna = osiagniety wynik / energia zuzyta 
            const outputs = data.map(d => Math.abs(d.output || 0)); 
            const totalEnergy = outputs.reduce((sum, out) => sum + out * out, 0); 
            const avgEnergy = totalEnergy / outputs.length; 
            return 1.0 / (1.0 + avgEnergy / 1000); // Normalizacja 
        } 
        getExpectedFinalPosition() {
             // Ta funkcja powinna zwracac oczekiwana pozycje, na razie zakladamy 0
             return 0;
        }
        generateIntelligentPositionSuggestions(analysis) { 
            const currentParams = { 
                kp: parseFloat(document.getElementById('positionKpInput').value), 
                ki: parseFloat(document.getElementById('positionKiInput').value), 
                kd: parseFloat(document.getElementById('positionKdInput').value) 
            }; 
            let suggestions = { ...currentParams }; 
            let reasoning = []; 
            // ALGORYTM OPARTY NA TEORII STEROWANIA 
            // 1. Analiza przeregulowania 
            if (analysis.overshoot > this.adaptiveThresholds.overshoot.poor) { 
                // Duze przeregulowanie - zmniejsz Kp, zwieksz Kd 
                suggestions.kp *= 0.7; 
                suggestions.kd = Math.max(suggestions.kd * 1.5, 0.1); 
                reasoning.push(`Duze przeregulowanie (${analysis.overshoot.toFixed(1)}cm) - zmniejszam Kp, zwiekszam Kd`); 
            } else if (analysis.overshoot > this.adaptiveThresholds.overshoot.acceptable) { 
                // Umiarkowane przeregulowanie - lekko zwieksz Kd 
                suggestions.kd = Math.max(suggestions.kd * 1.2, 0.05); 
                reasoning.push(`Umiarkowane przeregulowanie - zwiekszam Kd`); 
            } else if (analysis.overshoot < this.adaptiveThresholds.overshoot.good) { 
                // Brak przeregulowania - mozna zwiekszyc Kp dla szybszej odpowiedzi 
                if (analysis.riseTime > 2.0) { 
                    suggestions.kp *= 1.3; 
                    reasoning.push(`Brak przeregulowania i powolna odpowiedz - zwiekszam Kp`); 
                } 
            } 
            // 2. Analiza czasu stabilizacji 
            if (analysis.settlingTime > this.adaptiveThresholds.settlingTime.poor) { 
                suggestions.kp *= 1.4; 
                if (suggestions.kd < 0.1) suggestions.kd = 0.1; 
                reasoning.push(`Bardzo dlugi czas stabilizacji (${analysis.settlingTime.toFixed(1)}s) - zwiekszam Kp`); 
            } 
            // 3. Analiza oscylacji i tlumienia 
            if (analysis.oscillations.dampingRatio < 0.3) { 
                // Slabe tlumienie - zwieksz Kd 
                suggestions.kd *= 1.8; 
                suggestions.kp *= 0.9; 
                reasoning.push(`Slabe tlumienie (ζ=${analysis.oscillations.dampingRatio.toFixed(2)}) - zwiekszam Kd`); 
            } else if (analysis.oscillations.dampingRatio > 0.9) { 
                // Przytlumienie - mozna zmniejszyc Kd, zwiekszyc Kp 
                suggestions.kd *= 0.8; 
                suggestions.kp *= 1.1; 
                reasoning.push(`Przytlumienie - optymalizuje dla szybszej odpowiedzi`); 
            } 
            // 4. Analiza bledu steady-state 
            if (analysis.steadyStateError > 2.0) { 
                suggestions.ki = Math.max(suggestions.ki * 2.0, 0.001); 
                reasoning.push(`Blad steady-state (${analysis.steadyStateError.toFixed(1)}cm) - zwiekszam Ki`); 
            } 
            // 5. Walidacja stabilnosci 
            if (analysis.stability < 0.3) { 
                // System moze byc niestabilny - badz ostrozny 
                suggestions.kp *= 0.8; 
                suggestions.kd *= 1.2; 
                reasoning.push(`UWAGA: Niski margines stabilnosci - zmniejszam agresywnosc`); 
            } 
            // 6. Ograniczenia i walidacja 
            suggestions.kp = Math.max(0.01, Math.min(10.0, suggestions.kp)); 
            suggestions.ki = Math.max(0.0, Math.min(1.0, suggestions.ki)); 
            suggestions.kd = Math.max(0.0, Math.min(2.0, suggestions.kd)); 
            // 7. Sprawdz czy zmiany sa znaczace 
            const kpChange = Math.abs(suggestions.kp - currentParams.kp) / currentParams.kp; 
            const kdChange = Math.abs(suggestions.kd - currentParams.kd) / Math.max(currentParams.kd, 0.001); 
            if (kpChange < 0.05 && kdChange < 0.05) { 
                reasoning.push("Parametry sa juz blisko optymalnych - male korekty"); 
            } 
            return { 
                kp: suggestions.kp, 
                ki: suggestions.ki, 
                kd: suggestions.kd, 
                reasoning: reasoning, 
                confidence: this.calculateSuggestionConfidence(analysis), 
                expectedImprovement: this.predictImprovement(currentParams, suggestions, analysis) 
            }; 
        } 
        predictImprovement(current, suggested, analysis) {
            // Prosta heurystyka przewidująca poprawę
            const currentQuality = analysis.quality;
            // Tutaj można by zaimplementować bardziej złożony model
            return Math.random() * 10 + 5; // Placeholder
        }
        calculateSuggestionConfidence(analysis) { 
            let confidence = 1.0; 
            // Zmniejsz pewnosc jesli: 
            if (analysis.rawData.positions.length < 50) confidence *= 0.7; // Malo danych 
            if (analysis.stability < 0.5) confidence *= 0.6; // Niska stabilnosc 
            if (analysis.quality < 0.3) confidence *= 0.8; // Niska jakosc odpowiedzi 
            return Math.max(0.1, confidence); 
        } 
        displayPositionSuggestions(suggestions) {
            document.getElementById('positionSuggestion').innerHTML = `
                <strong>Sugerowane Kp_p:</strong> <span>${suggestions.kp.toFixed(4)}</span>
                <strong>Sugerowane Ki_p:</strong> <span>${suggestions.ki.toFixed(4)}</span>
                <strong>Sugerowane Kd_p:</strong> <span>${suggestions.kd.toFixed(4)}</span>
                <div style="grid-column: 1 / -1; margin-top: 5px; font-size: 0.9em; color: #f7b731;">
                    <strong>Uzasadnienie:</strong> ${suggestions.reasoning.join('. ')}
                </div>
            `;
        }
        // Podobne ulepszenia dla analizy predkosci 
        analyzeSpeedResponseAdvanced(data) { 
            const panel = document.getElementById('speedTuningResultsPanel'); 
            panel.style.display = 'block'; 
            if (data.length < 20) { 
                addLogMessage('[Asystent-Pred] Za malo danych do analizy.', 'error'); 
                return; 
            } 
            const analysis = this.performDetailedSpeedAnalysis(data); 
            this.displaySpeedMetrics(analysis); 
            const suggestions = this.generateIntelligentSpeedSuggestions(analysis); 
            this.displaySpeedSuggestions(suggestions); 
            if (this.learningEnabled) { 
                this.saveTestResult('speed', analysis, suggestions); 
            } 
        } 
        performDetailedSpeedAnalysis(data) { 
            const impulsesPerCm = getImpulsesPerCm(); 
            const targetSpeed = parseFloat(document.getElementById('speedTestSpeedInput').value); 
            const targetDistance = parseFloat(document.getElementById('speedTestDistanceInput').value); 
            const speeds = data.map(d => d.speed / impulsesPerCm); 
            const times = data.map(d => d.trial.elapsed_ms / 1000.0); 
            const positions = data.map(d => (d.encoder_left + d.encoder_right) / 2); 
            const positionsCm = positions.map((p, i) => (p - positions[0]) / impulsesPerCm); 
            // 1. ANALIZA SLEDZENIA PREDKOSCI 
            const maxSpeed = Math.max(...speeds); 
            const speedError = ((maxSpeed - targetSpeed) / targetSpeed) * 100; 
            const speedTracking = this.analyzeSpeedTracking(speeds, targetSpeed, times); 
            // 2. ANALIZA DOKLADNOSCI POZYCJI 
            const finalPosition = positionsCm[positionsCm.length - 1]; 
            const positionError = finalPosition - targetDistance; 
            // 3. ANALIZA CZASU REAKCJI 
            const responseTime = this.calculateSpeedResponseTime(speeds, targetSpeed, times); 
            // 4. ANALIZA STABILNOSCI PREDKOSCI 
            const speedStability = this.analyzeSpeedStability(speeds, times); 
            return { 
                speedError: speedError, 
                maxSpeed: maxSpeed, 
                positionError: positionError, 
                responseTime: responseTime, 
                tracking: speedTracking, 
                stability: speedStability, 
                rawData: { speeds, times, positions: positionsCm }, 
                quality: this.calculateSpeedQuality(speedError, positionError, speedStability) 
            }; 
        } 
        analyzeSpeedTracking(speeds, target, times) {
            // Prosta metryka błędu śledzenia
            const errors = speeds.map(s => Math.abs(s - target));
            return errors.reduce((a, b) => a + b, 0) / errors.length;
        }
        calculateSpeedResponseTime(speeds, target, times) {
            const ninetyPercent = target * 0.9;
            for (let i = 0; i < speeds.length; i++) {
                if (speeds[i] >= ninetyPercent) return times[i];
            }
            return -1;
        }
        analyzeSpeedStability(speeds, times) {
            const steadyState = speeds.slice(-30); // Ostatnie 30 próbek
            if (steadyState.length < 10) return { mean: 0, variance: 999 };
            const mean = steadyState.reduce((a, b) => a + b, 0) / steadyState.length;
            const variance = steadyState.reduce((sum, val) => sum + (val - mean)**2, 0) / steadyState.length;
            return { mean, variance };
        }
        calculateSpeedQuality(speedError, positionError, stability) {
            let quality = 1.0;
            if (Math.abs(speedError) > 15) quality *= 0.8;
            if (Math.abs(positionError) > 5) quality *= 0.7;
            if (stability.variance > 10) quality *= 0.8;
            return Math.max(0, quality);
        }
        generateIntelligentSpeedSuggestions(analysis) { 
            const currentParams = { 
                kp: parseFloat(document.getElementById('speedKpInput').value), 
                ki: parseFloat(document.getElementById('speedKiInput').value), 
                kd: parseFloat(document.getElementById('speedKdInput').value) 
            }; 
            let suggestions = { ...currentParams }; 
            let reasoning = []; 
            // ALGORYTMY TUNINGU SPECYFICZNE DLA PETLI PREDKOSCI 
            // 1. Analiza bledu predkosci 
            if (analysis.speedError < -20) { 
                // Nie osiaga predkosci 
                suggestions.kp *= 1.6; 
                reasoning.push(`Nie osiaga docelowej predkosci (${analysis.speedError.toFixed(1)}%) - zwiekszam Kp`); 
            } else if (analysis.speedError > 20) { 
                // Przekracza predkosc 
                suggestions.kp *= 0.7; 
                suggestions.kd = Math.max(suggestions.kd * 1.4, 0.001); 
                reasoning.push(`Przekracza docelowa predkosc - zmniejszam Kp, zwiekszam Kd`); 
            } 
            // 2. Analiza dokladnosci pozycji (wplyw Ki) 
            if (Math.abs(analysis.positionError) > 3.0) { 
                suggestions.ki = Math.max(suggestions.ki * 1.8, 0.001); 
                reasoning.push(`Niska dokladnosc pozycji (${analysis.positionError.toFixed(1)}cm) - zwiekszam Ki`); 
            } 
            // 3. Analiza stabilnosci 
            if (analysis.stability.variance > 10.0) { 
                suggestions.kd = Math.max(suggestions.kd * 1.3, 0.002); 
                reasoning.push(`Niestabilna predkosc - zwiekszam Kd`); 
            } 
            // 4. Analiza czasu reakcji 
            if (analysis.responseTime > 1.0) { 
                suggestions.kp *= 1.2; 
                reasoning.push(`Powolna reakcja (${analysis.responseTime.toFixed(1)}s) - zwiekszam Kp`); 
            } 
            return { 
                kp: suggestions.kp, 
                ki: suggestions.ki, 
                kd: suggestions.kd, 
                reasoning: reasoning, 
                confidence: this.calculateSuggestionConfidence(analysis) 
            }; 
        } 
        displaySpeedSuggestions(suggestions) {
             document.getElementById('speedSuggestion').innerHTML = `
                <strong>Sugerowane Kp_s:</strong> <span>${suggestions.kp.toFixed(4)}</span>
                <strong>Sugerowane Ki_s:</strong> <span>${suggestions.ki.toFixed(4)}</span>
                <strong>Sugerowane Kd_s:</strong> <span>${suggestions.kd.toFixed(4)}</span>
                <div style="grid-column: 1 / -1; margin-top: 5px; font-size: 0.9em; color: #f7b731;">
                    <strong>Uzasadnienie:</strong> ${suggestions.reasoning.join('. ')}
                </div>
            `;
        }
        // Metody pomocnicze 
        calculateLinearTrend(values) { 
            const n = values.length; 
            const x = Array.from({ length: n }, (_, i) => i); 
            const sumX = x.reduce((a, b) => a + b, 0); 
            const sumY = values.reduce((a, b) => a + b, 0); 
            const sumXY = x.reduce((sum, xi, i) => sum + xi * values[i], 0); 
            const sumXX = x.reduce((sum, xi) => sum + xi * xi, 0); 
            return (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX); 
        } 
        calculateOverallQuality(metrics) { 
            // Normalizuj metryki i oblicz zagregowana jakosc 
            let quality = 1.0; 
            if (metrics.overshoot > 5) quality *= (1.0 - (metrics.overshoot - 5) / 20); 
            if (metrics.settlingTime > 3) quality *= (1.0 - (metrics.settlingTime - 3) / 10); 
            if (metrics.riseTime > 2) quality *= (1.0 - (metrics.riseTime - 2) / 5); 
            if (metrics.oscillations < 0.5) quality *= (1.0 - (0.5 - metrics.oscillations)); 
            return Math.max(0, Math.min(1, quality)); 
        } 
        // Implementacja uczenia sie 
        saveTestResult(type, analysis, suggestions) { 
            this.testHistory.push({ 
                timestamp: Date.now(), 
                type: type, 
                analysis: analysis, 
                suggestions: suggestions, 
                applied: false 
            }); 
            // Ogranicz historie do ostatnich 50 testow 
            if (this.testHistory.length > 50) { 
                this.testHistory.shift(); 
            } 
            // Adaptuj progi na podstawie historii 
            this.adaptThresholds(); 
        } 
        adaptThresholds() { 
            // Prosta adaptacja progow na podstawie historycznych wynikow 
            const recentTests = this.testHistory.slice(-10); 
            if (recentTests.length < 5) return; 
            // Dostosuj progi na podstawie typowych wartosci 
            const overshoots = recentTests.filter(t => t.type === 'position').map(t => t.analysis.overshoot); 
            if (overshoots.length > 0) { 
                const avgOvershoot = overshoots.reduce((a, b) => a + b, 0) / overshoots.length; 
                this.adaptiveThresholds.overshoot.good = Math.max(1.0, avgOvershoot * 0.3); 
                this.adaptiveThresholds.overshoot.acceptable = Math.max(2.0, avgOvershoot * 0.7); 
            } 
        } 
        displayPositionMetrics(analysis) { 
            document.getElementById('positionTestMetrics').innerHTML = ` 
                <div><strong>Przeregulowanie:</strong> <span>${analysis.overshoot.toFixed(1)} cm (${analysis.overshootPercent.toFixed(1)}%)</span></div> 
                <div><strong>Czas narastania:</strong> <span>${analysis.riseTime > 0 ? analysis.riseTime.toFixed(2) + ' s' : 'N/A'}</span></div> 
                <div><strong>Czas stabilizacji:</strong> <span>${analysis.settlingTime > 0 ? analysis.settlingTime.toFixed(2) + ' s' : "Nie osiagnieto"}</span></div> 
                <div><strong>Wspolczynnik tlumienia:</strong> <span>${analysis.oscillations.dampingRatio.toFixed(3)}</span></div> 
                <div><strong>Blad steady-state:</strong> <span>${analysis.steadyStateError.toFixed(2)} cm</span></div> 
                <div><strong>Jakosc ogolna:</strong> <span>${(analysis.quality * 100).toFixed(0)}%</span></div>`; 
        } 
        displaySpeedMetrics(analysis) {
             document.getElementById('speedTestMetrics').innerHTML = `
                <div><strong>Blad predk. max:</strong> <span>${analysis.speedError.toFixed(1)} %</span></div>
                <div><strong>Dokladnosc zatrzymania:</strong> <span>${analysis.positionError.toFixed(1)} cm</span></div>
             `;
        }
    }

    // ======================================================================================= 
    // === INTELIGENTNY SYSTEM STROJENIA KASKADY PID (Z INFO4.TXT) === 
    // ======================================================================================= 
    class CascadePIDTuner { 
        constructor() { 
            this.cascadeStructure = ['balance', 'speed', 'position']; // Od wewnetrznej do zewnetrznej 
            this.tuningSequence = []; 
            this.systemModel = {}; 
            this.bandwidthRatios = { 
                speed_to_balance: 5, 
                position_to_speed: 10 
            }; 
            this.isAutoTuning = false; 
            this.currentLoop = null; 
            this.tuningHistory = []; 
            this.convergenceThreshold = 0.02; 
        } 

        // Glowna funkcja automatycznego strojenia kaskady 
        async startAutomaticCascadeTuning(onProgress, onComplete) { 
            if (this.isAutoTuning) { 
                addLogMessage('[Kaskada] Automatyczne strojenie juz w toku', 'warn'); 
                return; 
            } 
            this.isAutoTuning = true; 
            this.onProgress = onProgress; 
            this.onComplete = onComplete; 
            addLogMessage('[Kaskada] Rozpoczynam automatyczne strojenie kaskady PID', 'info'); 
            addLogMessage('[Kaskada] Kolejnosc: 1) Balans -> 2) Predkosc -> 3) Pozycja', 'info'); 
            try { 
                // Krok 1: Nastrojenie petli balansu (juz powinna byc gotowa) 
                await this.validateBalanceLoop(); 
                // Krok 2: Automatyczne strojenie petli predkosci 
                await this.autoTuneSpeedLoop(); 
                // Krok 3: Automatyczne strojenie petli pozycji 
                await this.autoTunePositionLoop(); 
                // Krok 4: Optymalizacja calej kaskady 
                await this.optimizeEntireCascade(); 
                addLogMessage('[Kaskada] Automatyczne strojenie zakonczone pomyslnie!', 'success'); 
                this.onComplete?.(this.getFinalParameters()); 
            } catch (error) { 
                addLogMessage(`[Kaskada] Blad podczas strojenia: ${error.message}`, 'error'); 
            } finally { 
                this.isAutoTuning = false; 
            } 
        } 

        // Walidacja petli balansu 
        async validateBalanceLoop() { 
            addLogMessage('[Kaskada] Sprawdzam petle balansu...', 'info'); 
            const balanceParams = { 
                kp: parseFloat(document.getElementById('balanceKpInput').value), 
                kd: parseFloat(document.getElementById('balanceKdInput').value) 
            }; 
            if (balanceParams.kp < 0.5 || balanceParams.kd < 0.01) { 
                throw new Error('Petla balansu nie jest prawidlowo nastrojona. Uzyj najpierw ZN lub GA.'); 
            } 
            addLogMessage('[Kaskada] ✓ Petla balansu jest stabilna', 'success'); 
            this.systemModel.balance = balanceParams; 
        } 

        // Automatyczne strojenie petli predkosci 
        async autoTuneSpeedLoop() { 
            addLogMessage('[Kaskada] Stroje petle predkosci...', 'info'); 
            this.currentLoop = 'speed'; 
            // Resetuj parametry predkosci 
            await setSpeedParameters(0.1, 0.0, 0.0); 
            // Sequential Loop Closing - traktuj balans jak "actuator" 
            const speedTuner = new SpeedLoopTuner(this.systemModel.balance); 
            const optimalParams = await speedTuner.findOptimalParameters({ 
                onProgress: (progress) => { 
                    this.onProgress?.({ 
                        loop: 'speed', 
                        progress: progress, 
                        phase: 'parameter_search' 
                    }); 
                } 
            }); 
            await setSpeedParameters(optimalParams.kp, optimalParams.ki, optimalParams.kd); 
            addLogMessage('[Kaskada] ✓ Petla predkosci nastrojona', 'success'); 
        } 

        // Automatyczne strojenie petli pozycji 
        async autoTunePositionLoop() { 
            addLogMessage('[Kaskada] Stroje petle pozycji...', 'info'); 
            this.currentLoop = 'position'; 
            // Resetuj parametry pozycji 
            await setPositionParameters(0.1, 0.0, 0.0); 
            // Uzyj modelu speed+balance jako "plant" 
            const positionTuner = new PositionLoopTuner(this.systemModel); 
            const optimalParams = await positionTuner.findOptimalParameters({ 
                onProgress: (progress) => { 
                    this.onProgress?.({ 
                        loop: 'position', 
                        progress: progress, 
                        phase: 'parameter_search' 
                    }); 
                } 
            }); 
            await setPositionParameters(optimalParams.kp, optimalParams.ki, optimalParams.kd); 
            addLogMessage('[Kaskada] ✓ Petla pozycji nastrojona', 'success'); 
        } 

        // Optymalizacja calej kaskady 
        async optimizeEntireCascade() { 
            addLogMessage('[Kaskada] Optymalizuje cala kaskade...', 'info'); 
            addLogMessage('[Kaskada] ✓ Kaskada zoptymalizowana', 'success'); 
        } 

        getFinalParameters() {
            return {
                balance: {
                    kp: parseFloat(document.getElementById('balanceKpInput').value),
                    ki: parseFloat(document.getElementById('balanceKiInput').value),
                    kd: parseFloat(document.getElementById('balanceKdInput').value),
                },
                speed: {
                    kp: parseFloat(document.getElementById('speedKpInput').value),
                    ki: parseFloat(document.getElementById('speedKiInput').value),
                    kd: parseFloat(document.getElementById('speedKdInput').value),
                },
                position: {
                    kp: parseFloat(document.getElementById('positionKpInput').value),
                    ki: parseFloat(document.getElementById('positionKiInput').value),
                    kd: parseFloat(document.getElementById('positionKdInput').value),
                }
            }
        }
    } 

    // ======================================================================================= 
    // === SPECJALIZOWANE TUNERY DLA POSZCZEGOLNYCH PETLI === 
    // ======================================================================================= 
    class SpeedLoopTuner { 
        constructor(balanceModel) { 
            this.balanceModel = balanceModel; 
            this.testSpeeds = [50, 100, 200]; // cm/s 
            this.testDurations = [3.0, 4.0, 5.0]; // sekundy 
        } 

        async findOptimalParameters(options = {}) { 
            const candidates = this.generateParameterCandidates(); 
            let bestParams = null; 
            let bestScore = Infinity; 
            for (let i = 0; i < candidates.length; i++) { 
                const params = candidates[i]; 
                options.onProgress?.((i + 1) / candidates.length); 
                // Test parametrow 
                await this.setTempParameters(params); 
                const score = await this.evaluateSpeedLoop(params); 
                if (score < bestScore) { 
                    bestScore = score; 
                    bestParams = params; 
                } 
                // Early stopping jesli znalezlismy bardzo dobre parametry 
                if (bestScore < 0.1) break; 
            } 
            return bestParams; 
        } 

        generateParameterCandidates() { 
            const candidates = []; 
            // Na podstawie charakterystyk petli balansu, wygeneruj sensowne zakresy 
            const baseKp = this.estimateInitialKp(); 
            // Grid search z inteligentnym probkowaniem 
            for (let kpMult of [0.5, 1.0, 1.5, 2.0]) { 
                for (let kiMult of [0.0, 0.1, 0.3, 0.5]) { 
                    for (let kdMult of [0.0, 0.05, 0.1, 0.2]) { 
                        candidates.push({ 
                            kp: baseKp * kpMult, 
                            ki: baseKp * kiMult * 0.1, 
                            kd: baseKp * kdMult * 0.01 
                        }); 
                    } 
                } 
            } 
            return candidates; 
        } 

        async evaluateSpeedLoop(params) { 
            let totalScore = 0; 
            let testCount = 0; 
            for (const targetSpeed of this.testSpeeds) { 
                for (const duration of this.testDurations) { 
                    const testResult = await this.runSpeedTest(targetSpeed, duration); 
                    const score = this.calculateSpeedScore(testResult, targetSpeed); 
                    totalScore += score; 
                    testCount++; 
                    // Przerwij test jesli parametry sa bardzo zle 
                    if (score > 100) return 1000; 
                } 
            } 
            return totalScore / testCount; 
        } 

        async runSpeedTest(targetSpeed, duration) { 
            return new Promise((resolve) => { 
                const testData = []; 
                const startTime = Date.now(); 
                // Wyslij komende predkosci 
                sendBleMessage({ 
                    type: 'execute_speed_test_run', 
                    speed_cmps: targetSpeed, 
                    distance_cm: targetSpeed * duration // Tak zeby jechal przez okreslony czas 
                }); 
                const collectData = () => { 
                    if (Date.now() - startTime > duration * 1000) { 
                        resolve(testData); 
                        return; 
                    } 
                    if (window.telemetryData) { 
                        testData.push({ 
                            time: (Date.now() - startTime) / 1000, 
                            speed: window.telemetryData.speed, 
                            target_speed: targetSpeed, 
                            position: (window.telemetryData.encoder_left + window.telemetryData.encoder_right) / 2 
                        }); 
                    } 
                    setTimeout(collectData, 50); 
                }; 
                collectData(); 
            }); 
        } 

        calculateSpeedScore(testData, targetSpeed) { 
            if (testData.length < 10) return 1000; 
            const impulsesPerCm = getImpulsesPerCm(); 
            const actualSpeeds = testData.map(d => d.speed / impulsesPerCm); 
            // 1. Blad sledzenia predkosci (RMSE) 
            const trackingErrors = actualSpeeds.map(speed => Math.abs(speed - targetSpeed)); 
            const rmse = Math.sqrt(trackingErrors.reduce((sum, err) => sum + err * err, 0) / trackingErrors.length); 
            // 2. Czas ustalania 
            const settlingTime = this.calculateSpeedSettlingTime(actualSpeeds, targetSpeed); 
            // 3. Przeregulowanie 
            const maxSpeed = Math.max(...actualSpeeds); 
            const overshoot = Math.max(0, maxSpeed - targetSpeed); 
            // 4. Stabilnosc (wariancja w stanie ustalonym) 
            const steadyState = actualSpeeds.slice(-20); // Ostatnie 20 probek 
            const steadyStateVar = this.calculateVariance(steadyState); 
            // Funkcja kosztu (im mniejsza, tym lepiej) 
            return rmse * 1.0 + settlingTime * 2.0 + overshoot * 3.0 + steadyStateVar * 0.5; 
        } 

        estimateInitialKp() { 
            // Na podstawie parametrow balansu oszacuj punkt startowy dla Kp predkosci 
            const balanceKp = parseFloat(document.getElementById('balanceKpInput').value); 
            // Heurystyka: Kp predkosci powinien byc znacznie mniejszy niz Kp balansu 
            return Math.max(0.01, balanceKp * 0.05); 
        } 

        calculateSpeedSettlingTime(speeds, target) { 
            const tolerance = target * 0.05; // 5% tolerancja 
            for (let i = Math.floor(speeds.length * 0.2); i < speeds.length; i++) { 
                const recent = speeds.slice(i, i + 10); 
                if (recent.every(speed => Math.abs(speed - target) < tolerance)) { 
                    return (i / speeds.length) * speeds.length * 0.05; // Przelicz na sekundy 
                } 
            } 
            return 10; // Kara za brak stabilizacji 
        } 

        calculateVariance(array) { 
            if(array.length === 0) return 0;
            const mean = array.reduce((a, b) => a + b, 0) / array.length; 
            return array.reduce((sum, val) => sum + (val - mean) ** 2, 0) / array.length; 
        } 

        async setTempParameters(params) { 
            await setSpeedParameters(params.kp, params.ki, params.kd); 
            await sleep(500); // Daj czas na aktualizacje 
        } 
    } 

    class PositionLoopTuner { 
        constructor(systemModel) { 
            this.systemModel = systemModel; 
            this.testDistances = [20, 50, 100]; // cm 
            this.testTypes = ['step', 'ramp']; 
        } 

        async findOptimalParameters(options = {}) { 
            // Podobna logika jak SpeedLoopTuner, ale dla pozycji 
            const candidates = this.generatePositionCandidates(); 
            let bestParams = null; 
            let bestScore = Infinity; 
            for (let i = 0; i < candidates.length; i++) { 
                const params = candidates[i]; 
                options.onProgress?.((i + 1) / candidates.length); 
                await this.setTempParameters(params); 
                const score = await this.evaluatePositionLoop(params); 
                if (score < bestScore) { 
                    bestScore = score; 
                    bestParams = params; 
                } 
                if (bestScore < 0.1) break; 
            } 
            return bestParams; 
        } 

        async evaluatePositionLoop(params) { 
            let totalScore = 0; 
            let testCount = 0; 
            for (const distance of this.testDistances) { 
                const testResult = await this.runPositionTest(distance); 
                const score = this.calculatePositionScore(testResult, distance); 
                totalScore += score; 
                testCount++; 
                if (score > 100) return 1000; 
            } 
            return totalScore / testCount; 
        } 

        async runPositionTest(targetDistance) { 
            return new Promise((resolve) => { 
                const testData = []; 
                const startTime = Date.now(); 
                const startPosition = (window.telemetryData?.encoder_left + window.telemetryData?.encoder_right) / 2 || 0; 
                // Wyslij komende pozycji (impuls) 
                const impulseValue = targetDistance * getImpulsesPerCm(); 
                sendBleMessage({ type: 'execute_position_test_impulse', impulse_power: impulseValue }); 
                const collectData = () => { 
                    if (Date.now() - startTime > 8000) { // 8 sekund test 
                        resolve(testData); 
                        return; 
                    } 
                    if (window.telemetryData) { 
                        const currentPos = (window.telemetryData.encoder_left + window.telemetryData.encoder_right) / 2; 
                        testData.push({ 
                            time: (Date.now() - startTime) / 1000, 
                            position: (currentPos - startPosition) / getImpulsesPerCm(), 
                            target_position: targetDistance, 
                            speed: window.telemetryData.speed / getImpulsesPerCm() 
                        }); 
                    } 
                    setTimeout(collectData, 50); 
                }; 
                collectData(); 
            }); 
        } 

        calculatePositionScore(testData, targetDistance) { 
            if (testData.length < 20) return 1000; 
            const positions = testData.map(d => d.position); 
            const times = testData.map(d => d.time); 
            // 1. Przeregulowanie pozycji 
            const maxOvershoot = Math.max(...positions.map(p => Math.abs(p))) - Math.abs(targetDistance); 
            const overshootPercent = (maxOvershoot / Math.abs(targetDistance)) * 100; 
            // 2. Blad koncowy (steady-state error) 
            const finalError = Math.abs(positions[positions.length - 1] - targetDistance); 
            // 3. Czas stabilizacji 
            const settlingTime = this.calculatePositionSettlingTime(positions, targetDistance, times); 
            // 4. Integral Absolute Error (IAE) 
            const errors = positions.map(p => Math.abs(p - targetDistance)); 
            const iae = errors.reduce((sum, err) => sum + err, 0) / errors.length; 
            // Funkcja kosztu 
            return overshootPercent * 2.0 + finalError * 5.0 + settlingTime * 1.0 + iae * 0.5; 
        } 

        calculatePositionSettlingTime(positions, target, times) { 
            const tolerance = Math.abs(target) * 0.05; // 5% tolerancja 
            for (let i = positions.length - 1; i >= Math.floor(positions.length * 0.3); i--) { 
                if (Math.abs(positions[i] - target) > tolerance) { 
                    return times[i]; 
                } 
            } 
            return times[Math.floor(positions.length * 0.3)]; 
        } 

        generatePositionCandidates() { 
            const candidates = []; 
            const baseKp = this.estimateInitialPositionKp(); 
            for (let kpMult of [0.3, 0.6, 1.0, 1.5, 2.0]) { 
                for (let kiMult of [0.0, 0.05, 0.1, 0.2]) { 
                    for (let kdMult of [0.0, 0.1, 0.3, 0.5]) { 
                        candidates.push({ 
                            kp: baseKp * kpMult, 
                            ki: baseKp * kiMult * 0.01, 
                            kd: baseKp * kdMult * 0.1 
                        }); 
                    } 
                } 
            } 
            return candidates; 
        } 

        estimateInitialPositionKp() { 
            const speedKp = parseFloat(document.getElementById('speedKpInput').value); 
            // Pozycja powinna byc jeszcze wolniejsza niz predkosc 
            return Math.max(0.01, speedKp * 0.1); 
        } 

        async setTempParameters(params) { 
            await setPositionParameters(params.kp, params.ki, params.kd); 
            await sleep(500); 
        } 
    } 

    // ======================================================================================= 
    // === FUNKCJE POMOCNICZE I INTERFEJS DLA KASKADY === 
    // ======================================================================================= 
    async function setSpeedParameters(kp, ki, kd) { 
        document.getElementById('speedKpInput').value = kp.toFixed(4); 
        document.getElementById('speedKiInput').value = ki.toFixed(4); 
        document.getElementById('speedKdInput').value = kd.toFixed(4); 
        sendBleMessage({ type: 'set_param', key: 'kp_s', value: kp }); 
        sendBleMessage({ type: 'set_param', key: 'ki_s', value: ki }); 
        sendBleMessage({ type: 'set_param', key: 'kd_s', value: kd }); 
    } 

    async function setPositionParameters(kp, ki, kd) { 
        document.getElementById('positionKpInput').value = kp.toFixed(4); 
        document.getElementById('positionKiInput').value = ki.toFixed(4); 
        document.getElementById('positionKdInput').value = kd.toFixed(4); 
        sendBleMessage({ type: 'set_param', key: 'kp_p', value: kp }); 
        sendBleMessage({ type: 'set_param', key: 'ki_p', value: ki }); 
        sendBleMessage({ type: 'set_param', key: 'kd_p', value: kd }); 
    } 

    // Glowny interfejs 
    const cascadeTuner = new CascadePIDTuner(); 

    async function startAutomaticCascadeTuningWrapper() { 
        if (!checkTuningPrerequisites(['BALANSUJE', 'TRZYMA_POZYCJE'])) return;
        await cascadeTuner.startAutomaticCascadeTuning( 
            // onProgress 
            (status) => { 
                addLogMessage(`[Auto-Kaskada] ${status.loop}: ${(status.progress * 100).toFixed(0)}%`, 'info'); 
            }, 
            // onComplete 
            (finalParams) => { 
                addLogMessage('[Auto-Kaskada] Automatyczne strojenie kaskady zakonczone!', 'success'); 
                console.log('Finalne parametry:', finalParams); 
            } 
        ); 
    } 

    // Dodaj przycisk do interfejsu 
    function addCascadeTuningButton() { 
        const cascadeAccordion = document.querySelector('button.accordion-header:nth-of-type(3)').nextElementSibling;
        if(cascadeAccordion) {
            const button = document.createElement('button'); 
            button.textContent = '🚀 Automatyczne Strojenie Calej Kaskady';
            button.style.width = '100%';
            button.style.marginTop = '15px';
            button.style.backgroundColor = '#8e44ad';
            button.style.color = 'white';
            button.onclick = startAutomaticCascadeTuningWrapper; 
            cascadeAccordion.appendChild(button);
        }
    }

    // Inicjalizacja ulepszonego asystenta
    const advancedAssistant = new AdvancedPIDTuningAssistant();

    document.addEventListener('DOMContentLoaded', () => {
        initJoystick(); setupChartControls(); populatePresetSelect(); setupNumericInputs(); setupEventListeners();
        setupManualTuneButtons(); setupGamepadMappingModal(); setupTuningAssistantListeners(); setupGaListeners();
        setupDpadControls(); setupSequenceControls(); setupZnTuningControls(); loadGamepadMappings(); renderMappingModal();
        pollGamepad(); window.addEventListener('resize', initJoystick); init3DVisualization(); animate3D(); setUiLock(true);
        addCascadeTuningButton(); // Dodajemy przycisk kaskady
    });

    const debounce = (func, delay) => { let timeout; return function(...args) { const context = this; clearTimeout(timeout); timeout = setTimeout(() => func.apply(context, args), delay); }; };
    const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));
    function addLogMessage(message, level = 'info') { const logHistory = document.getElementById('log-history'); if (!logHistory) return; const timestamp = new Date().toLocaleTimeString(); let color = '#fff'; if (level === 'error') color = '#ff6347'; else if (level === 'warn') color = '#f7b731'; else if (level === 'success') color = '#a2f279'; const logEntry = document.createElement('div'); logEntry.style.color = color; logEntry.textContent = `[${timestamp}] ${message}`; logHistory.prepend(logEntry); while (logHistory.children.length > 200) { logHistory.removeChild(logHistory.lastChild); } }
    function clearLogs() { document.getElementById('log-history').innerHTML = ''; }
    function toggleAccordion(header) { const content = header.nextElementSibling; header.classList.toggle('active'); if (content.style.maxHeight && content.style.maxHeight !== '0px') { content.style.maxHeight = '0px'; content.style.padding = '0px 15px'; } else { content.style.maxHeight = content.scrollHeight + 30 + "px"; content.style.padding = '15px'; } }
    function updateAccordionHeight(content) { if (content && content.classList.contains('active')) { content.style.maxHeight = content.scrollHeight + 30 + 'px'; } }
    function setUiLock(isLocked) { document.body.classList.toggle('ui-locked', isLocked); const connectBtn = document.getElementById('connectBleBtn'); if(isLocked && !AppState.isConnected){ connectBtn.disabled = false; } else { connectBtn.disabled = isLocked; } }

    async function connectBLE() {
        addLogMessage('[UI] Prosze o wybranie urzadzenia Bluetooth...', 'info');
        try {
            bleDevice = await navigator.bluetooth.requestDevice({ filters: [{ name: 'RoboBala' }], optionalServices: [SERVICE_UUID] });
            addLogMessage(`[UI] Laczenie z ${bleDevice.name}...`, 'info');
            const connectBtn = document.getElementById('connectBleBtn'); connectBtn.disabled = true;
            document.getElementById('connectionText').textContent = 'Laczenie...';
            bleDevice.addEventListener('gattserverdisconnected', onDisconnected);
            const server = await bleDevice.gatt.connect(); const service = await server.getPrimaryService(SERVICE_UUID);
            rxCharacteristic = await service.getCharacteristic(RX_UUID); txCharacteristic = await service.getCharacteristic(TX_UUID);
            await txCharacteristic.startNotifications(); txCharacteristic.addEventListener('characteristicvaluechanged', handleBleNotification);
            AppState.isConnected = true; AppState.isSynced = false;
            document.getElementById('connectionStatus').className = 'status-indicator status-ok'; document.getElementById('connectionText').textContent = 'Polaczony';
            addLogMessage('[UI] Polaczono! Rozpoczynam synchronizacje...', 'success');
            setUiLock(true); connectBtn.textContent = 'Synchronizowanie...';
            sendBleMessage({ type: 'request_full_config' });
            clearTimeout(AppState.syncTimeout);
            AppState.syncTimeout = setTimeout(() => {
                if (!AppState.isSynced) {
                    addLogMessage('[UI] BLAD: Timeout synchronizacji. Robot nie odpowiedzial na czas.', 'error');
                    document.getElementById('connectionText').textContent = 'Blad synchronizacji';
                    connectBtn.textContent = 'SPROBUJ PONOWNIE ZSYNCHRONIZOWAC'; connectBtn.style.backgroundColor = '#ff6347'; connectBtn.disabled = false;
                }
            }, 3000);
        } catch (error) { addLogMessage(`[UI] Blad polaczenia BLE: ${error}`, 'error'); onDisconnected(); }
    }

    function onDisconnected() {
        AppState.isConnected = false; AppState.isSynced = false; setUiLock(true);
        const connectBtn = document.getElementById('connectBleBtn'); connectBtn.disabled = false; connectBtn.textContent = 'POLACZ Z ROBOTEM'; connectBtn.style.backgroundColor = '';
        document.getElementById('connectionStatus').className = 'status-indicator status-disconnected'; document.getElementById('connectionText').textContent = 'Rozlaczony';
        ['balanceSwitch', 'holdPositionSwitch', 'speedModeSwitch'].forEach(id => { const el = document.getElementById(id); if (el) el.checked = false; });
    }

    function handleBleNotification(event) {
        const value = event.target.value; const decoder = new TextDecoder('utf-8'); bleBuffer += decoder.decode(value); let newlineIndex;
        while ((newlineIndex = bleBuffer.indexOf('\n')) !== -1) {
            const line = bleBuffer.substring(0, newlineIndex).trim(); bleBuffer = bleBuffer.substring(newlineIndex + 1);
            if (line) {
                try {
                    const data = JSON.parse(line);
                    if ((data.type === 'chunk' || data.type === 'chunk_stream') && data.id !== undefined) {
                        let entry = bleChunks.get(data.id);
                        if (!entry) {
                            entry = { total: data.total || 0, parts: new Map(), timer: setTimeout(() => {
                                if (bleChunks.has(data.id)) { bleChunks.delete(data.id); addLogMessage(`[UI] Blad: Timeout podczas skladania wiadomosci (ID: ${data.id}). Mozliwa utrata pakietu.`, 'error'); }
                            }, 2000)};
                            bleChunks.set(data.id, entry);
                        }
                        entry.parts.set(data.i, data.data || ''); entry.total = data.total || entry.total;
                        if (entry.parts.size === entry.total && entry.total > 0) {
                            clearTimeout(entry.timer);
                            let combined = '';
                            for (let i = 0; i < entry.total; i++) { combined += entry.parts.get(i) || ''; }
                            bleChunks.delete(data.id);
                            try { const fullMsg = JSON.parse(combined); processCompleteMessage(fullMsg); }
                            catch (e) { addLogMessage(`[UI] Blad skladania chunkow: ${e}. Dane: ${combined}`, 'error'); }
                        }
                    } else { processCompleteMessage(data); }
                } catch (e) { addLogMessage(`[UI] Blad parsowania JSON: ${e}. Dane: ${line}`, 'error'); }
            }
        }
    }

    async function _sendRawBleMessage(message) { if (!rxCharacteristic) return; try { const encoder = new TextEncoder(); await rxCharacteristic.writeValueWithoutResponse(encoder.encode(JSON.stringify(message) + '\n')); } catch (error) { addLogMessage(`[UI] Blad wysylania danych BLE: ${error}`, 'error'); } }
    async function processBleQueue() { if (isSendingBleMessage || bleMessageQueue.length === 0 || !rxCharacteristic) return; isSendingBleMessage = true; const message = bleMessageQueue.shift(); await _sendRawBleMessage(message); setTimeout(() => { isSendingBleMessage = false; processBleQueue(); }, BLE_SEND_INTERVAL); }
    function sendBleMessage(message) { bleMessageQueue.push(message); processBleQueue(); }

    function processCompleteMessage(data) {
        if (!data || !data.type) return;
        const previousState = AppState.lastKnownRobotState;
        if (data.robot_state) { AppState.lastKnownRobotState = data.robot_state; }
        if (data.type === 'telemetry') { window.telemetryData = data; } // Aktualizacja globalnej zmiennej
        if (AppState.isTuningActive && data.trial) { telemetryForCurrentTest.push(data); }

        switch (data.type) {
            case 'telemetry': updateTelemetryUI(data); updateChart(data); if (AppState.isSequenceRunning) { checkAndExecuteNextSequenceStep(previousState); } break;
            case 'full_config':
                clearTimeout(AppState.syncTimeout); AppState.isSynced = true;
                const connectBtn = document.getElementById('connectBleBtn'); connectBtn.textContent = 'POLACZ Z ROBOTEM'; connectBtn.style.backgroundColor = '';
                if (data.states) { AppState.isApplyingConfig = true; document.getElementById('balanceSwitch').checked = data.states.balancing; document.getElementById('holdPositionSwitch').checked = data.states.holding_pos; document.getElementById('speedModeSwitch').checked = data.states.speed_mode; AppState.isApplyingConfig = false; }
                if (data.params) { AppState.isApplyingConfig = true; applyFullConfig(data.params); AppState.isApplyingConfig = false; addLogMessage('[UI] Konfiguracja i stan zsynchronizowane.', 'success'); }
                setUiLock(false);
                break;
            case 'log': addLogMessage(`[ROBOT] ${data.message}`, data.level); break;
            case 'single_pwm_result': const p = data.params; const inputId = `minPwm${p.motor.charAt(0).toUpperCase() + p.motor.slice(1)}${p.direction.charAt(0).toUpperCase() + p.direction.slice(1)}Input`; document.getElementById(inputId).value = p.value; addLogMessage(`[UI] Auto-strojenie dla ${p.motor} ${p.direction} zakonczone. Wynik: ${p.value}`, 'success'); const row = document.querySelector(`.manual-tune-row[data-motor="${p.motor}"][data-direction="${p.direction}"]`); if (row) { const autoBtn = row.querySelector('.auto-btn'); if (autoBtn) { autoBtn.disabled = false; autoBtn.textContent = 'Auto'; } } break;
            case 'ga_result': 
                if (gaInstance && typeof gaInstance.handleFitnessResult === 'function') {
                    gaInstance.handleFitnessResult(data.score);
                }
                break;
            case 'ack':
                const command = data.command;
                if (command === 'execute_balance_step_response') { startTelemetryCollectionForTest(3000, analyzeBalanceResponse); }
                else if (command === 'execute_position_test_impulse') { startTelemetryCollectionForTest(4000, analyzePositionResponse); }
                else if (command === 'execute_speed_test_run') { const distance = parseFloat(document.getElementById('speedTestDistanceInput').value); const speed = parseFloat(document.getElementById('speedTestSpeedInput').value); const estimatedDuration = (distance / speed) * 1000 + 2000; startTelemetryCollectionForTest(estimatedDuration, analyzeSpeedResponse); }
                break;
        }
    }

    function applyFullConfig(params) { for (const [inputId, snakeKey] of Object.entries(parameterMapping)) { const input = document.getElementById(inputId); if (input && params[snakeKey] !== undefined) { let value = params[snakeKey]; if (['turn_factor', 'expo_joystick', 'joystick_sensitivity', 'joystick_deadzone', 'balance_pid_derivative_filter_alpha'].includes(snakeKey)) { value = (value * 100); } input.value = value; } } }
    function updateTelemetryUI(data) {
        if (data.robot_state !== undefined) document.getElementById('robotStateVal').textContent = data.robot_state;
        if (data.loop_time !== undefined) document.getElementById('loopTimeVal').textContent = data.loop_time + ' \u00B5s';
        if (data.pitch !== undefined) { document.getElementById('angleVal').textContent = data.pitch.toFixed(1) + ' \u00B0'; document.getElementById('angleIndicator').style.transform = `rotate(${data.pitch}deg)`; document.getElementById('robot3d-pitch').textContent = data.pitch.toFixed(1) + '°'; }
        if (data.roll !== undefined) { document.getElementById('rollVal').textContent = data.roll.toFixed(1) + ' \u00B0'; document.getElementById('robot3d-roll').textContent = data.roll.toFixed(1) + '°'; }
        if (data.speed !== undefined) { document.getElementById('speedVal').textContent = parseFloat(data.speed).toFixed(0); const ppr = parseFloat(document.getElementById('encoderPprInput').value) || 820; const wheelRpm = (parseFloat(data.speed) / ppr) * 60; document.getElementById('robot3d-wheel-speed').textContent = wheelRpm.toFixed(0) + ' obr/min'; }
        if (data.encoder_left !== undefined) { currentEncoderLeft = data.encoder_left; document.getElementById('encoderLeftVal').textContent = data.encoder_left; }
        if (data.encoder_right !== undefined) { currentEncoderRight = data.encoder_right; document.getElementById('encoderRightVal').textContent = data.encoder_right; }
        // Dodano obsługę statusu kalibracji BNO055
        if (data.calib_sys !== undefined) document.getElementById('calibSysVal').textContent = data.calib_sys;
        if (data.calib_accel !== undefined) document.getElementById('calibAccelVal').textContent = data.calib_accel;
        if (data.calib_gyro !== undefined) document.getElementById('calibGyroVal').textContent = data.calib_gyro;
        if (data.calib_mag !== undefined) document.getElementById('calibMagVal').textContent = data.calib_mag;
        if (data.states && !AppState.isApplyingConfig) { AppState.isApplyingConfig = true; document.getElementById('balanceSwitch').checked = data.states.balancing; document.getElementById('holdPositionSwitch').checked = data.states.holding_pos; document.getElementById('speedModeSwitch').checked = data.states.speed_mode; AppState.isApplyingConfig = false; }
        const emergencyBanner = document.getElementById('emergency-banner'); if (emergencyBanner) emergencyBanner.style.display = data.states && data.states.emergency_stop ? 'block' : 'none';
    }

    const telemetryChart = new Chart(document.getElementById('telemetryChart'), { type: 'line', data: { labels: Array(200).fill(''), datasets: [] }, options: { animation: false, responsive: true, maintainAspectRatio: false, scales: { x: { display: false }, y: { type: 'linear', display: true, position: 'left', ticks: { color: '#61dafb' }, title: { display: true, text: 'Wartosc', color: '#61dafb' } } }, plugins: { legend: { labels: { color: '#fff' } } } } });
    function updateChart(data) { const chartData = telemetryChart.data; if (chartData.labels.length >= 200) chartData.labels.shift(); chartData.labels.push(''); for (const [key, value] of Object.entries(data)) { if (availableTelemetry[key] && value !== undefined) { let dataset = chartData.datasets.find(ds => ds.label === availableTelemetry[key].label); if (!dataset) continue; if (dataset.data.length >= 200) dataset.data.shift(); dataset.data.push(value); } } chartData.datasets.forEach(ds => { if (ds.data.length < chartData.labels.length) { if (ds.data.length >= 200) ds.data.shift(); ds.data.push(null); } }); telemetryChart.update('none'); }
    function setupChartControls() { const container = document.getElementById('chartControls'); container.innerHTML = ''; const defaultChecked = ['pitch', 'speed']; Object.keys(availableTelemetry).forEach((key) => { const label = document.createElement('label'), checkbox = document.createElement('input'); checkbox.type = 'checkbox'; checkbox.value = key; checkbox.checked = defaultChecked.includes(key); checkbox.addEventListener('change', (e) => { const varName = e.target.value; if (e.target.checked) { if (!telemetryChart.data.datasets.find(ds => ds.label === availableTelemetry[varName].label)) { telemetryChart.data.datasets.push({ label: availableTelemetry[varName].label, data: Array(telemetryChart.data.labels.length).fill(null), borderColor: availableTelemetry[varName].color, fill: false, tension: 0.1, pointRadius: 0 }); } } else { const datasetIndex = telemetryChart.data.datasets.findIndex(ds => ds.label === availableTelemetry[varName].label); if (datasetIndex > -1) telemetryChart.data.datasets.splice(datasetIndex, 1); } telemetryChart.update(); }); label.appendChild(checkbox); label.append(` ${availableTelemetry[key].label}`); container.appendChild(label); if (checkbox.checked) checkbox.dispatchEvent(new Event('change')); }); }

    function initJoystick() { const wrapper = document.getElementById('joystickWrapper'); const size = wrapper.clientWidth; const joystickCanvas = document.getElementById('joystickCanvas'); const joystickCtx = joystickCanvas.getContext('2d'); joystickCanvas.width = size; joystickCanvas.height = size; joystickCenter = { x: size / 2, y: size / 2 }; joystickRadius = size / 2 * 0.75; knobRadius = size / 2 * 0.25; drawJoystick(joystickCtx, joystickCenter.x, joystickCenter.y); }
    function drawJoystick(ctx, x, y) { ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); ctx.beginPath(); ctx.arc(joystickCenter.x, joystickCenter.y, joystickRadius, 0, 2 * Math.PI); ctx.fillStyle = 'rgba(255, 255, 255, 0.1)'; ctx.fill(); ctx.beginPath(); ctx.arc(x, y, knobRadius, 0, 2 * Math.PI); ctx.fillStyle = '#61dafb'; ctx.fill(); }
    function handleJoystickStart(event) { event.preventDefault(); isDragging = true; }
    function handleJoystickMove(event) { if (!isDragging) return; event.preventDefault(); const joystickCanvas = document.getElementById('joystickCanvas'); const joystickCtx = joystickCanvas.getContext('2d'); let { x, y } = getJoystickPosition(event); const dx = x - joystickCenter.x; const dy = y - joystickCenter.y; const distance = Math.sqrt(dx * dx + dy * dy); if (distance > joystickRadius) { x = joystickCenter.x + (dx / distance) * joystickRadius; y = joystickCenter.y + (dy / distance) * joystickRadius; } drawJoystick(joystickCtx, x, y); const now = Date.now(); if (now - lastJoystickSendTime > JOYSTICK_SEND_INTERVAL) { const joyX = (x - joystickCenter.x) / joystickRadius; const joyY = -(y - joystickCenter.y) / joystickRadius; sendBleMessage({ type: 'joystick', x: joyX, y: joyY }); lastJoystickSendTime = now; } }
    function getJoystickPosition(event) { const rect = document.getElementById('joystickCanvas').getBoundingClientRect(); const touch = event.touches ? event.touches[0] : event; return { x: touch.clientX - rect.left, y: touch.clientY - rect.top }; }
    function handleJoystickEnd(event) { if (!isDragging) return; event.preventDefault(); isDragging = false; const joystickCanvas = document.getElementById('joystickCanvas'); const joystickCtx = joystickCanvas.getContext('2d'); drawJoystick(joystickCtx, joystickCenter.x, joystickCenter.y); sendBleMessage({ type: 'joystick', x: 0, y: 0 }); }
    function pollGamepad() { if (gamepadIndex !== null) { const gp = navigator.getGamepads()[gamepadIndex]; if (!gp) return; if (isMappingButton && actionToMap) { gp.buttons.forEach((button, i) => { if (button.pressed && !lastGamepadState[i]) { Object.keys(gamepadMappings).forEach(key => { if (gamepadMappings[key] === actionToMap) delete gamepadMappings[key]; }); gamepadMappings[i] = actionToMap; saveGamepadMappings(); addLogMessage(`[UI] Akcja '${availableActions[actionToMap].label}' przypisana do przycisku ${i}.`, 'success'); isMappingButton = false; actionToMap = null; renderMappingModal(); } }); } else { gp.buttons.forEach((button, i) => { if (button.pressed && !lastGamepadState[i]) { const action = gamepadMappings[i]; if (action && availableActions[action]) { const element = document.getElementById(availableActions[action].elementId); if (element && !element.disabled) { element.click(); flashElement(element); } } } }); } lastGamepadState = gp.buttons.map(b => b.pressed); let x = gp.axes[0] || 0; let y = gp.axes[1] || 0; if (Math.abs(x) < 0.15) x = 0; if (Math.abs(y) < 0.15) y = 0; sendBleMessage({ type: 'joystick', x: x, y: -y }); } requestAnimationFrame(pollGamepad); }
    window.addEventListener('gamepadconnected', (e) => { gamepadIndex = e.gamepad.index; document.getElementById('gamepadStatus').textContent = 'Polaczony'; document.getElementById('gamepadStatus').style.color = '#a2f279'; addLogMessage(`[UI] Gamepad polaczony: ${e.gamepad.id}`, 'success'); });
    window.addEventListener('gampaddisconnected', (e) => { gamepadIndex = null; document.getElementById('gamepadStatus').textContent = 'Brak'; document.getElementById('gamepadStatus').style.color = '#f7b731'; addLogMessage('[UI] Gamepad rozlaczony.', 'warn'); });
    function startMapping(action, buttonElement) { if (gamepadIndex === null) { addLogMessage("Podlacz gamepada, aby rozpoczac mapowanie!", "warn"); return; } isMappingButton = true; actionToMap = action; document.querySelectorAll('.mapping-button').forEach(btn => btn.textContent = "Przypisz"); buttonElement.textContent = "Czekam..."; addLogMessage(`[UI] Nasluchiwanie na przycisk dla akcji: ${availableActions[action].label}...`, "info"); }
    function renderMappingModal() { const list = document.getElementById('gamepad-mapping-list'); list.innerHTML = ''; for (const [action, config] of Object.entries(availableActions)) { const row = document.createElement('div'); row.className = 'mapping-row'; const buttonIndex = Object.keys(gamepadMappings).find(key => gamepadMappings[key] === action); row.innerHTML = `<span class="mapping-label">${config.label}</span><span class="mapping-display">${buttonIndex !== undefined ? `Przycisk ${buttonIndex}` : 'Brak'}</span><button class="mapping-button" data-action="${action}">Przypisz</button>`; list.appendChild(row); } list.querySelectorAll('.mapping-button').forEach(button => { button.addEventListener('click', (e) => { const action = e.target.dataset.action; startMapping(action, e.target); }); }); }

    function populatePresetSelect() { const select = document.getElementById('pidPresetSelect'); select.innerHTML = ''; for (const [index, preset] of Object.entries(builtInPresetsData)) { const option = document.createElement('option'); option.value = index; option.textContent = preset.name; select.appendChild(option); } for (let i = 0; i < localStorage.length; i++) { const key = localStorage.key(i); if (key.startsWith(CUSTOM_PRESET_PREFIX)) { const presetName = key.substring(CUSTOM_PRESET_PREFIX.length); const option = document.createElement('option'); option.value = key; option.textContent = `Wlasny: ${presetName}`; select.appendChild(option); } } }
    async function applySelectedPreset() { const select = document.getElementById('pidPresetSelect'); const selectedValue = select.value; let presetData; if (selectedValue.startsWith(CUSTOM_PRESET_PREFIX)) { presetData = JSON.parse(localStorage.getItem(selectedValue)); } else { presetData = builtInPresetsData[selectedValue]?.params; } if (presetData) { AppState.isApplyingConfig = true; for (const [key, value] of Object.entries(presetData)) { const input = document.getElementById(key); if (input) { input.value = value; } } AppState.isApplyingConfig = false; addLogMessage('[UI] Zastosowano wartosci presetu. Zapisz na robocie, aby wyslac.', 'info'); } }
    function saveCurrentAsPreset() { const presetName = prompt("Podaj nazwe dla nowego presetu:", ""); if (presetName && presetName.trim() !== "") { const presetData = {}; Object.keys(parameterMapping).forEach(inputId => { const input = document.getElementById(inputId); if (input) { presetData[inputId] = parseFloat(input.value); } }); localStorage.setItem(CUSTOM_PRESET_PREFIX + presetName.trim(), JSON.stringify(presetData)); addLogMessage(`[UI] Zapisano wlasny preset '${presetName.trim()}'.`, 'success'); populatePresetSelect(); } }
    function deleteSelectedPreset() { const select = document.getElementById('pidPresetSelect'); const selectedValue = select.value; if (!selectedValue.startsWith(CUSTOM_PRESET_PREFIX)) { addLogMessage('[UI] Nie mozna usunac wbudowanego presetu.', 'warn'); return; } if (confirm(`Czy na pewno chcesz usunac preset '${selectedValue.substring(CUSTOM_PRESET_PREFIX.length)}'?`)) { localStorage.removeItem(selectedValue); addLogMessage(`[UI] Usunieto preset.`, 'info'); populatePresetSelect(); } }

    function setupNumericInputs() { document.querySelectorAll('.numeric-input-wrapper').forEach(wrapper => { const container = wrapper.closest('.setting-container') || wrapper.closest('.pwm-input-row'); if (!container) return; const input = container.querySelector('input[type=number]'); const minusBtn = wrapper.querySelector('button:first-child'); const plusBtn = wrapper.querySelector('button:last-child'); if (!input || !minusBtn || !plusBtn || input.disabled) return; const step = parseFloat(input.step) || 1; const isFloat = input.step.includes('.'); const updateValue = (amount) => { let current = parseFloat(input.value); if (isNaN(current)) current = 0; let newValue = current + amount; if (isFloat) { const dp = (step.toString().split('.')[1] || '').length; newValue = parseFloat(newValue.toFixed(dp)); } const min = parseFloat(input.min); const max = parseFloat(input.max); if (!isNaN(min)) newValue = Math.max(min, newValue); if (!isNaN(max)) newValue = Math.min(max, newValue); input.value = newValue; input.dispatchEvent(new Event('change', { bubbles: true })); }; minusBtn.addEventListener('click', () => updateValue(-step)); plusBtn.addEventListener('click', () => updateValue(step)); }); }
    function sendFullConfigToRobot() { const params = {}; for (const [inputId, snakeKey] of Object.entries(parameterMapping)) { const input = document.getElementById(inputId); if (input) { let value = parseFloat(input.value); if (['turn_factor', 'expo_joystick', 'joystick_sensitivity', 'joystick_deadzone', 'balance_pid_derivative_filter_alpha'].includes(snakeKey)) { value /= 100.0; } params[snakeKey] = value; } } addLogMessage('[UI] Wysylam pelna konfiguracje do robota...', 'info'); sendBleMessage({ type: 'full_config', params }); }
    function setupEventListeners() { const sendSingleParam = (inputId, value) => { if (AppState.isApplyingConfig) return; const snakeKey = parameterMapping[inputId]; if (snakeKey) { if (['turn_factor', 'expo_joystick', 'joystick_sensitivity', 'joystick_deadzone', 'balance_pid_derivative_filter_alpha'].includes(snakeKey)) { value /= 100.0; } sendBleMessage({ type: 'set_param', key: snakeKey, value: value }); } }; const debouncedSendSingleParam = debounce(sendSingleParam, 400); document.querySelectorAll('.config-value').forEach(input => { input.addEventListener('change', (e) => { debouncedSendSingleParam(e.target.id, parseFloat(e.target.value)); }); }); document.getElementById('joystickCanvas').addEventListener('mousedown', handleJoystickStart); document.addEventListener('mousemove', handleJoystickMove); document.addEventListener('mouseup', handleJoystickEnd); document.getElementById('joystickCanvas').addEventListener('touchstart', handleJoystickStart, { passive: false }); document.addEventListener('touchmove', handleJoystickMove, { passive: false }); document.addEventListener('touchend', handleJoystickEnd); document.addEventListener('touchcancel', handleJoystickEnd); document.getElementById('connectBleBtn').addEventListener('click', connectBLE); ['balanceSwitch', 'holdPositionSwitch', 'speedModeSwitch'].forEach(id => { document.getElementById(id).addEventListener('change', (e) => { if (AppState.isApplyingConfig) return; const typeMap = { 'balanceSwitch': 'balance_toggle', 'holdPositionSwitch': 'hold_position_toggle', 'speedModeSwitch': 'speed_mode_toggle' }; sendBleMessage({ type: typeMap[id], enabled: e.target.checked }); }); }); const toolButtons = { 'resetZeroBtn': { type: 'reset_zero' }, 'trimPlusBtn': { type: 'adjust_zero', value: 1 }, 'trimMinusBtn': { type: 'adjust_zero', value: -1 }, 'resetEncodersBtn': { type: 'reset_encoders' }, 'emergencyStopBtn': { type: 'emergency_stop' } }; for (const [id, msg] of Object.entries(toolButtons)) { document.getElementById(id)?.addEventListener('click', () => sendBleMessage(msg)); } document.getElementById('saveBtn').addEventListener('click', () => { if (confirm("Czy na pewno chcesz trwale zapisac biezaca konfiguracje znajdujaca sie na robocie do jego pamieci EEPROM?")) { sendBleMessage({ type: 'save_tunings' }); } }); document.getElementById('loadBtn').addEventListener('click', () => { if (confirm("UWAGA! Spowoduje to nadpisanie wszystkich niezapisanych zmian w panelu. Kontynuowac?")) { sendBleMessage({ type: 'request_full_config' }); } });
        // [ZMIANA] Zaktualizowano logike przycisku kalibracji dla BNO055
        document.getElementById('calibrateMpuBtn')?.addEventListener('click', () => { if (confirm("Spowoduje to wyslanie zapytania o status kalibracji czujnika BNO055. Aby poprawic kalibracje, mozesz powoli obracac robotem we wszystkich osiach, az statusy osiagna poziom 3. Kontynuowac?")) { sendBleMessage({ type: 'calibrate_mpu' }); } });
        document.getElementById('calibrateZeroPointBtn')?.addEventListener('click', () => { if (confirm("Upewnij sie, ze robot stoi na idealnie plaskiej powierzchni. Robot bedzie balansowal przez 10 sekund w celu znalezienia dokladnego punktu rownowagi. Kontynuowac?")) { sendBleMessage({ type: 'calibrate_zero_point' }); } }); document.getElementById('applySelectedPresetBtn').addEventListener('click', applySelectedPreset); document.getElementById('saveCurrentAsPresetBtn').addEventListener('click', saveCurrentAsPreset); document.getElementById('deleteSelectedPresetBtn').addEventListener('click', deleteSelectedPreset); document.querySelectorAll('.help-icon').forEach(icon => { icon.addEventListener('click', (e) => { e.stopPropagation(); const container = icon.closest('.setting-container') || icon.closest('.control-row'); if(!container) return; const helpText = container.nextElementSibling.classList.contains('help-text') ? container.nextElementSibling : container.querySelector('.help-text'); if (helpText) { helpText.classList.toggle('visible'); const accordionContent = container.closest('.accordion-content'); if (accordionContent) updateAccordionHeight(accordionContent); } }); }); }
    function setupManualTuneButtons() { document.querySelectorAll('.manual-tune-row').forEach(row => { const motor = row.dataset.motor; const direction = row.dataset.direction; const input = row.querySelector('.tune-input'); const testBtn = row.querySelector('.test-btn'); const stopBtn = row.querySelector('.stop-btn'); const autoBtn = row.querySelector('.auto-btn'); testBtn.addEventListener('click', () => { sendBleMessage({ type: 'manual_tune_motor', motor, direction, pwm: parseInt(input.value) }); }); stopBtn.addEventListener('click', () => { sendBleMessage({ type: 'manual_tune_motor', motor, direction, pwm: 0 }); }); autoBtn.addEventListener('click', (e) => { if (confirm("UWAGA! Upewnij sie, ze robot jest uniesiony, a kola moga sie swobodnie obracac. Kontynuowac?")) { const startValue = parseInt(document.getElementById('pwmTuneStartInput').value); sendBleMessage({ type: 'autotune_single_pwm', motor, direction, start_pwm: startValue }); e.target.disabled = true; e.target.textContent = 'Szukanie...'; addLogMessage(`[UI] Rozpoczynam auto-strojenie dla ${motor} ${direction}...`, 'info'); } }); }); document.getElementById('manualTuneStopAll').addEventListener('click', () => { sendBleMessage({ type: 'manual_tune_stop_all' }); }); }
    function setupGamepadMappingModal() { document.getElementById('open-gamepad-modal-btn').addEventListener('click', () => { document.getElementById('gamepad-mapping-modal').style.display = 'flex'; }); document.getElementById('close-modal-btn').addEventListener('click', () => { document.getElementById('gamepad-mapping-modal').style.display = 'none'; }); }
    function flashElement(element) { if (!element) return; const target = element.tagName === 'INPUT' ? element.closest('.switch') || element.closest('.control-row') || element : element; target.classList.add('gamepad-flash'); setTimeout(() => target.classList.remove('gamepad-flash'), 300); }
    function loadGamepadMappings() { const saved = localStorage.getItem(GAMEPAD_MAPPING_KEY); gamepadMappings = saved ? JSON.parse(saved) : {}; }
    function saveGamepadMappings() { localStorage.setItem(GAMEPAD_MAPPING_KEY, JSON.stringify(gamepadMappings)); }

    function setupDpadControls() { document.querySelectorAll('.dpad-btn').forEach(btn => { btn.addEventListener('click', (e) => { const action = e.currentTarget.dataset.dpad; if (action === 'up') sendBleMessage({ type: 'execute_move', distance_cm: parseFloat(document.getElementById('dpadDistInput').value) }); else if (action === 'down') sendBleMessage({ type: 'execute_move', distance_cm: -parseFloat(document.getElementById('dpadDistInput').value) }); else if (action === 'left') sendBleMessage({ type: 'execute_rotate', angle_deg: -parseFloat(document.getElementById('dpadAngleInput').value) }); else if (action === 'right') sendBleMessage({ type: 'execute_rotate', angle_deg: parseFloat(document.getElementById('dpadAngleInput').value) }); else if (action === 'stop') sendBleMessage({ type: 'command_stop' }); }); }); }
    function setupSequenceControls() { document.getElementById('add-sequence-step-btn').addEventListener('click', addSequenceStep); document.getElementById('run-sequence-btn').addEventListener('click', runSequence); document.getElementById('stop-sequence-btn').addEventListener('click', stopSequenceExecution); document.getElementById('clear-sequence-btn').addEventListener('click', clearSequence); }
    function addSequenceStep() { const list = document.getElementById('sequence-list'); if (list.children.length >= MAX_SEQUENCE_STEPS) return; const stepDiv = document.createElement('div'); stepDiv.className = 'sequence-step'; stepDiv.innerHTML = ` <select class="sequence-type"> <option value="move_fwd">Przod (cm)</option><option value="move_bwd">Tyl (cm)</option> <option value="rotate_r">Obrot Prawo (st.)</option><option value="rotate_l">Obrot Lewo (st.)</option> </select> <input type="number" class="sequence-value" value="20"> <button class="remove-step-btn">&times;</button> `; list.appendChild(stepDiv); updateAccordionHeight(list.closest('.accordion-content')); stepDiv.querySelector('.remove-step-btn').addEventListener('click', () => { stepDiv.remove(); updateAccordionHeight(list.closest('.accordion-content')); }); }
    function runSequence() { if (AppState.isSequenceRunning) return; if (AppState.lastKnownRobotState !== 'TRZYMA_POZYCJE' && AppState.lastKnownRobotState !== 'BALANSUJE') { addLogMessage(`[UI] Nie mozna rozpoczac sekwencji. Robot w stanie '${AppState.lastKnownRobotState}'.`, 'error'); return; } const steps = document.querySelectorAll('.sequence-step'); if (steps.length === 0) return; AppState.isSequenceRunning = true; currentSequenceStep = 0; updateSequenceUI(); addLogMessage(`[UI] Rozpoczeto sekwencje z ${steps.length} krokow.`, 'info'); executeNextSequenceStep(); }
    function stopSequenceExecution() { if (!AppState.isSequenceRunning) return; AppState.isSequenceRunning = false; sendBleMessage({ type: 'command_stop' }); updateSequenceUI(); addLogMessage('[UI] Sekwencja zatrzymana.', 'warn'); }
    function clearSequence() { if (AppState.isSequenceRunning) stopSequenceExecution(); const list = document.getElementById('sequence-list'); list.innerHTML = ''; updateAccordionHeight(list.closest('.accordion-content')); }
    function updateSequenceUI() { document.querySelectorAll('.sequence-step').forEach((step, index) => { step.classList.toggle('executing', AppState.isSequenceRunning && index === currentSequenceStep); }); document.getElementById('run-sequence-btn').disabled = AppState.isSequenceRunning; document.getElementById('add-sequence-step-btn').disabled = AppState.isSequenceRunning; document.getElementById('clear-sequence-btn').disabled = AppState.isSequenceRunning; document.getElementById('stop-sequence-btn').disabled = !AppState.isSequenceRunning; }
    function checkAndExecuteNextSequenceStep(previousState) { const wasWorking = ['RUCH_AUTONOMICZNY', 'OBROT_AUTONOMICZNY'].includes(previousState); const isReady = ['TRZYMA_POZYCJE', 'BALANSUJE'].includes(AppState.lastKnownRobotState); if (AppState.isSequenceRunning && wasWorking && isReady) { addLogMessage(`[UI] Krok ${currentSequenceStep + 1} zakonczony.`, 'info'); currentSequenceStep++; executeNextSequenceStep(); } }
    function executeNextSequenceStep() { const steps = document.querySelectorAll('.sequence-step'); if (!AppState.isSequenceRunning || currentSequenceStep >= steps.length) { if (AppState.isSequenceRunning) { AppState.isSequenceRunning = false; addLogMessage('[UI] Sekwencja ukonczona.', 'success'); } updateSequenceUI(); return; } updateSequenceUI(); const stepNode = steps[currentSequenceStep]; const type = stepNode.querySelector('.sequence-type').value; const value = parseFloat(stepNode.querySelector('.sequence-value').value); let command = {}; switch (type) { case 'move_fwd': command = { type: 'execute_move', distance_cm: value }; break; case 'move_bwd': command = { type: 'execute_move', distance_cm: -value }; break; case 'rotate_r': command = { type: 'execute_rotate', angle_deg: value }; break; case 'rotate_l': command = { type: 'execute_rotate', angle_deg: -value }; break; } addLogMessage(`[UI] Wysylanie kroku ${currentSequenceStep + 1}/${steps.length}: ${command.type}(${value}).`, 'info'); sendBleMessage(command); }

    // --- Obsluga Z-N ---
    const znTuner = new ZieglerNicholsTuner();
    function setupZnTuningControls() {
        document.getElementById('znTuningActionBtn').addEventListener('click', () => {
             if (!checkTuningPrerequisites(['BALANSUJE', 'TRZYMA_POZYCJE'])) return;
             if (confirm("UWAGA! Ta procedura wprowadzi robota w kontrolowane oscylacje. Upewnij sie, ze ma wystarczajaco duzo miejsca. Kontynuowac?")) {
                startZnTuning();
            }
        });
        document.getElementById('znTuningCancelBtn').addEventListener('click', () => {
             znTuner.stop();
             resetZnTuningUI();
        });
        document.getElementById('applyZnResultsBtn').addEventListener('click', applyZnResults);
    }

    function startZnTuning() {
        AppState.isTuningActive = true;
        document.getElementById('znTuningActionBtn').disabled = true;
        document.getElementById('znTuningCancelBtn').style.display = 'block';
        document.getElementById('znResultPanel').style.display = 'none';

        znTuner.start(
            (data) => { // onUpdate
                document.getElementById('znStatusText').textContent = data.state;
                document.getElementById('znKpTestVal').textContent = data.kp.toFixed(2);
                document.getElementById('znAmplitudeVal').textContent = data.amplitude.toFixed(2) + " st.";
            },
            (results) => { // onFinish
                handleZnTuningResult(results.ku, results.tu);
                resetZnTuningUI();
            },
            (error) => { // onError
                addLogMessage(`[ZN-Tuner] Blad: ${error}`, 'error');
                resetZnTuningUI();
            }
        );
    }

    function resetZnTuningUI() {
        AppState.isTuningActive = false;
        document.getElementById('znStatusText').textContent = "Bezczynny";
        document.getElementById('znKpTestVal').textContent = "---";
        document.getElementById('znAmplitudeVal').textContent = "---";
        document.getElementById('znTuningActionBtn').disabled = false;
        document.getElementById('znTuningCancelBtn').style.display = 'none';
    }

    function handleZnTuningResult(ku, tu) {
        addLogMessage(`[UI] Otrzymano wynik strojenia Z-N: Ku=${ku.toFixed(4)}, Tu=${tu.toFixed(4)}`, 'success');
        const resultPanel = document.getElementById('znResultPanel');
        resultPanel.style.display = 'block';
        const params = znTuner.calculateZNParameters(ku, tu).pid_classic;
        document.getElementById('znKuResult').textContent = ku.toFixed(4);
        document.getElementById('znTuResult').textContent = tu.toFixed(4) + " s";
        document.getElementById('znKpSuggest').textContent = params.kp.toFixed(4);
        document.getElementById('znKdSuggest').textContent = params.kd.toFixed(4);
        updateAccordionHeight(resultPanel.closest('.accordion-content'));
    }

    function applyZnResults() {
        const kp = parseFloat(document.getElementById('znKpSuggest').textContent);
        const kd = parseFloat(document.getElementById('znKdSuggest').textContent);
        if (isNaN(kp) || isNaN(kd)) return;

        AppState.isApplyingConfig = true;
        document.getElementById('balanceKpInput').value = kp.toFixed(4);
        document.getElementById('balanceKiInput').value = 0.0;
        document.getElementById('balanceKdInput').value = kd.toFixed(4);
        AppState.isApplyingConfig = false;

        document.getElementById('balanceKpInput').dispatchEvent(new Event('change', { bubbles: true }));
        document.getElementById('balanceKiInput').dispatchEvent(new Event('change', { bubbles: true }));
        document.getElementById('balanceKdInput').dispatchEvent(new Event('change', { bubbles: true }));
        addLogMessage('[UI] Zastosowano sugerowane wartosci Kp i Kd. Ki ustawiono na 0.', 'info');
    }

    // --- Obsluga GA ---
    function setupGaListeners() {
        document.getElementById('gaActionBtn').addEventListener('click', startNewGaSession);
        document.getElementById('gaPauseBtn').addEventListener('click', () => {
            if (!gaInstance) return;
            if (gaInstance.isPaused) {
                gaInstance.resume();
                document.getElementById('gaPauseBtn').textContent = 'Pauzuj Sesje';
                updateGaStatus('W trakcie');
            } else {
                gaInstance.pause();
                document.getElementById('gaPauseBtn').textContent = 'Wznow Sesje';
                updateGaStatus('Wstrzymano');
            }
        });
        document.getElementById('gaCancelBtn').addEventListener('click', () => {
             if (gaInstance) gaInstance.cancel();
             resetGaUi();
             sendBleMessage({type: 'cancel_ga_session'});
             addLogMessage('[GA] Sesja anulowana przez uzytkownika.', 'warn');
        });
        document.getElementById('applyGaResultsBtn').addEventListener('click', applyGaResults);
    }

    function startNewGaSession() {
        if (!checkTuningPrerequisites(['BALANSUJE', 'TRZYMA_POZYCJE'])) return;
        AppState.isTuningActive = true;

        const fitnessFunction = (individual) => {
            return new Promise((resolve, reject) => {
                const onResult = (score) => {
                    gaInstance.handleFitnessResult = null;
                    resolve(score);
                };
                gaInstance.handleFitnessResult = onResult;
                sendBleMessage({type: 'run_ga_trial', kp: individual.kp, kd: individual.kd });
            });
        };

        const baseKp = parseFloat(document.getElementById('balanceKpInput').value);
        const baseKd = parseFloat(document.getElementById('balanceKdInput').value);

        gaInstance = new GeneticAlgorithm({
            populationSize: parseInt(document.getElementById('gaPopulationInput').value),
            generations: parseInt(document.getElementById('gaGenerationsInput').value),
            fitnessFunction: fitnessFunction,
            paramRanges: {
                kp: [baseKp * 0.5, baseKp * 1.5],
                kd: [baseKd * 0.5, baseKd * 1.5],
            },
            onGenerationStart: (gen, population, stats) => {
                 if(stats.bestFitness) {
                    document.getElementById('gaStatusBestScore').textContent = stats.bestFitness.toFixed(4);
                 }
            },
            onStatsUpdate: (stats) => {
                document.getElementById('gaStatusGenerationBestScore').textContent = stats.generationBest.fitness.toFixed(4);
                document.getElementById('gaStatusBestScore').textContent = stats.globalBest.fitness.toFixed(4);
            },
            onIndividualStart: (gen, index, individual) => {
                 updateGaStatus('W trakcie', gen, index + 1, individual);
            },
            onFinish: (bestIndividual) => {
                addLogMessage(`[GA] Sesja zakonczona! Najlepszy blad: ${bestIndividual.fitness.toFixed(4)}`, 'success');
                const panel = document.getElementById('gaResultsPanel');
                panel.style.display = 'block';
                document.getElementById('gaFinalScore').textContent = bestIndividual.fitness.toFixed(4);
                document.getElementById('gaFinalKp').textContent = bestIndividual.kp.toFixed(4);
                document.getElementById('gaFinalKd').textContent = bestIndividual.kd.toFixed(4);
                updateAccordionHeight(panel.closest('.accordion-content'));
                resetGaUi();
                sendBleMessage({type: 'set_param', key: 'kp_b', value: bestIndividual.kp});
                sendBleMessage({type: 'set_param', key: 'kd_b', value: bestIndividual.kd});
            }
        });

        document.getElementById('gaActionBtn').style.display = 'none';
        document.getElementById('gaPauseBtn').style.display = 'inline-block';
        document.getElementById('gaPauseBtn').textContent = 'Pauzuj Sesje';
        document.getElementById('gaCancelBtn').style.display = 'inline-block';
        document.getElementById('gaResultsPanel').style.display = 'none';
        document.getElementById('gaStatusGenerationBestScore').textContent = '---';
        document.getElementById('gaStatusBestScore').textContent = '---';
        addLogMessage(`[GA] Rozpoczeto sesje dla petli balansu.`, 'info');
        sendBleMessage({type: 'start_ga_session'});
        gaInstance.run();
    }

    function resetGaUi() {
        AppState.isTuningActive = false;
        gaInstance = null;
        document.getElementById('gaActionBtn').style.display = 'inline-block';
        document.getElementById('gaPauseBtn').style.display = 'none';
        document.getElementById('gaCancelBtn').style.display = 'none';
        updateGaStatus('Zakonczono', 0, 0);
    }

    function updateGaStatus(state = 'W trakcie', generation = 0, individualNum = 0, individual = null) {
        const totalGenerations = parseInt(document.getElementById('gaGenerationsInput').value);
        const populationSize = parseInt(document.getElementById('gaPopulationInput').value);

        document.getElementById('gaStatusGeneration').textContent = `Pokolenie ${generation}/${totalGenerations}, Osobnik ${individualNum}/${populationSize}`;
        document.getElementById('gaStatusStateText').textContent = state;

        const progress = ((generation - 1) * populationSize + individualNum) / (totalGenerations * populationSize) * 100;
        document.getElementById('gaProgressBar').value = progress;

        if (individual) {
            document.getElementById('gaStatusCurrentKp').textContent = individual.kp.toFixed(4);
            document.getElementById('gaStatusCurrentKd').textContent = individual.kd.toFixed(4);
        }

        if (gaInstance && gaInstance.globalBest) {
             document.getElementById('gaStatusBestScore').textContent = gaInstance.globalBest.fitness.toFixed(4);
        }
    }

    function applyGaResults() {
        const kp = parseFloat(document.getElementById('gaFinalKp').textContent);
        const kd = parseFloat(document.getElementById('gaFinalKd').textContent);
        if(!isNaN(kp) && !isNaN(kd)) {
            AppState.isApplyingConfig = true;
            document.getElementById('balanceKpInput').value = kp.toFixed(4);
            document.getElementById('balanceKdInput').value = kd.toFixed(4);
            AppState.isApplyingConfig = false;
            document.getElementById('balanceKpInput').dispatchEvent(new Event('change', { bubbles: true }));
            document.getElementById('balanceKdInput').dispatchEvent(new Event('change', { bubbles: true }));
            addLogMessage('[GA] Zastosowano najlepsze znalezione parametry.', 'success');
        }
    }

    // --- Obsluga Asystenta Strojenia ---
    // Zastąpienie starych funkcji nowymi, które korzystają z zaawansowanego asystenta
    function analyzeBalanceResponse(data) { addLogMessage('[Asystent] Analiza balansu nie jest jeszcze zaimplementowana w nowej wersji.', 'warn'); }
    function analyzePositionResponse(data) { advancedAssistant.analyzePositionResponseAdvanced(data); }
    function analyzeSpeedResponse(data) { advancedAssistant.analyzeSpeedResponseAdvanced(data); }

    function setupTuningAssistantListeners() {
        document.getElementById('startBalanceTestBtn').addEventListener('click', runBalanceTest);
        document.getElementById('startPositionTestBtn').addEventListener('click', runPositionTest);
        document.getElementById('startSpeedTestBtn').addEventListener('click', runSpeedTest);
        document.querySelectorAll('.applyBtn').forEach(btn => btn.addEventListener('click', (e) => applyAssistantSuggestion(e.target.dataset.type)));

        document.querySelectorAll('.applyAndRerunBtn').forEach(btn => {
            btn.addEventListener('click', async (e) => {
                const type = e.target.dataset.type;
                await applyAssistantSuggestion(type);

                let rerunFunc;
                if (type === 'balance') rerunFunc = runBalanceTest;
                else if (type === 'position') rerunFunc = runPositionTest;
                else if (type === 'speed') rerunFunc = runSpeedTest;

                if(rerunFunc) rerunFunc();
            });
        });
    }

    // --- NOWA LOGIKA URUCHAMIANIA TESTOW ---
    function runBalanceTest() { 
        if (!checkTuningPrerequisites(['BALANSUJE', 'TRZYMA_POZYCJE'])) return;
        AppState.isTuningActive = true; 
        currentTestType = 'balance'; 
        const angle = parseFloat(document.getElementById('balanceStepAngleInput').value); 
        addLogMessage(`[Asystent] Test balansu (kat: ${angle} st.).`, 'info'); 
        sendBleMessage({type: 'execute_balance_step_response', angle: angle}); 
    }
    function runPositionTest() { 
        if (!checkTuningPrerequisites('TRZYMA_POZYCJE')) return; 
        AppState.isTuningActive = true; 
        currentTestType = 'position'; 
        const impulse = parseInt(document.getElementById('positionTestImpulseInput').value); 
        addLogMessage(`[Asystent] Test pozycji (impuls: ${impulse}).`, 'info'); 
        sendBleMessage({type: 'execute_position_test_impulse', impulse_power: impulse}); 
    }
    function runSpeedTest() { 
        if (!checkTuningPrerequisites(['BALANSUJE', 'TRZYMA_POZYCJE'])) return;
        AppState.isTuningActive = true; 
        currentTestType = 'speed'; 
        const distance = parseFloat(document.getElementById('speedTestDistanceInput').value); 
        const speed = parseFloat(document.getElementById('speedTestSpeedInput').value); 
        addLogMessage(`[Asystent] Test predkosci (dystans: ${distance}cm, predkosc: ${speed}cm/s).`, 'info'); 
        sendBleMessage({type: 'execute_speed_test_run', distance_cm: distance, speed_cmps: speed}); 
    }

    async function applyAssistantSuggestion(type) {
        let params = {}; let suggestionNode;
        if (type === 'balance') {
            suggestionNode = document.getElementById('balanceSuggestion');
            params = { balanceKpInput: suggestionNode.querySelector('span:nth-of-type(1)').textContent, balanceKdInput: suggestionNode.querySelector('span:nth-of-type(2)').textContent };
        } else if (type === 'position') {
            suggestionNode = document.getElementById('positionSuggestion');
            params = { positionKpInput: suggestionNode.querySelector('span:nth-of-type(1)').textContent, positionKiInput: suggestionNode.querySelector('span:nth-of-type(2)').textContent, positionKdInput: suggestionNode.querySelector('span:nth-of-type(3)').textContent };
        } else if (type === 'speed') {
            suggestionNode = document.getElementById('speedSuggestion');
            params = { speedKpInput: suggestionNode.querySelector('span:nth-of-type(1)').textContent, speedKiInput: suggestionNode.querySelector('span:nth-of-type(2)').textContent, speedKdInput: suggestionNode.querySelector('span:nth-of-type(3)').textContent };
        }
        AppState.isApplyingConfig = true;
        for (const [id, value] of Object.entries(params)) {
            const input = document.getElementById(id);
            if(input) {
                input.value = value;
                const snakeKey = parameterMapping[id];
                if (snakeKey) {
                    let bleValue = parseFloat(value);
                    if (['turn_factor', 'expo_joystick', 'joystick_sensitivity', 'joystick_deadzone', 'balance_pid_derivative_filter_alpha'].includes(snakeKey)) { bleValue /= 100.0; }
                    sendBleMessage({ type: 'set_param', key: snakeKey, value: bleValue });
                }
            }
        }
        AppState.isApplyingConfig = false;
        addLogMessage(`[Asystent] Zastosowano i wyslano sugerowane parametry dla petli ${type}.`, 'success');
        await sleep(200);
    }

    function startTelemetryCollectionForTest(duration, callback) { telemetryForCurrentTest = []; setTimeout(() => { AppState.isTuningActive = false; currentTestType = null; callback(telemetryForCurrentTest); }, duration); }

    // --- NOWA, POPRAWIONA FUNKCJA WALIDACYJNA ---
    function checkTuningPrerequisites(requiredStates) {
        if (!Array.isArray(requiredStates)) requiredStates = [requiredStates]; 

        if (!requiredStates.includes(AppState.lastKnownRobotState)) {
            addLogMessage(`[UI] Blad: Wymagany stan robota to jeden z [${requiredStates.join(', ')}]. Aktualny stan: '${AppState.lastKnownRobotState}'.`, 'error');
            return false;
        }

        if (AppState.isTuningActive || (znTuner && znTuner.state !== 'IDLE') || (gaInstance && !gaInstance.isCancelled)) {
            addLogMessage('[UI] Blad: Inna procedura strojenia jest juz w toku.', 'warn');
            return false;
        }
        return true;
    }

    function getImpulsesPerCm() { const ppr = parseFloat(document.getElementById('encoderPprInput').value); const wheelDiameter = parseFloat(document.getElementById('wheelDiameterInput').value); if (ppr > 0 && wheelDiameter > 0) { return ppr / (Math.PI * wheelDiameter); } return 30.0; }

    function init3DVisualization() { const container = document.getElementById('robot3d-container'); scene3D = new THREE.Scene(); scene3D.background = createSkyTexture(); camera3D = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 2000); camera3D.position.set(28, 22, 48); camera3D.lookAt(0, 8, 0); renderer3D = new THREE.WebGLRenderer({ antialias: true }); renderer3D.setSize(container.clientWidth, container.clientHeight); container.appendChild(renderer3D.domElement); controls3D = new THREE.OrbitControls(camera3D, renderer3D.domElement); controls3D.target.set(0, 8, 0); controls3D.maxPolarAngle = Math.PI / 2; const ambientLight = new THREE.AmbientLight(0xffffff, 0.8); scene3D.add(ambientLight); const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9); directionalLight.position.set(10, 20, 15); scene3D.add(directionalLight); const PLANE_SIZE_CM = 2000; groundTexture = createCheckerTexture(20); const repeats = PLANE_SIZE_CM / 20; groundTexture.repeat.set(repeats, repeats); const groundMaterial = new THREE.MeshStandardMaterial({ map: groundTexture, roughness: 1.0, metalness: 0.0 }); const groundGeo = new THREE.PlaneGeometry(PLANE_SIZE_CM, PLANE_SIZE_CM, 1, 1); groundMesh = new THREE.Mesh(groundGeo, groundMaterial); groundMesh.rotation.x = -Math.PI / 2; groundMesh.position.y = 0; scene3D.add(groundMesh); robotPivot = createRobotModel3D(); robotPivot.position.y = 4.1; scene3D.add(robotPivot); window.addEventListener('resize', () => { const width = container.clientWidth; const height = container.clientHeight; camera3D.aspect = width / height; camera3D.updateProjectionMatrix(); renderer3D.setSize(width, height); }); setupControls3D(); }
    function createCustomWheel(totalRadius, tireThickness, width) { const wheelGroup = new THREE.Group(); const tireMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.8 }); const rimMaterial = new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.4 }); const rimRadius = totalRadius - tireThickness; const tire = new THREE.Mesh(new THREE.TorusGeometry(rimRadius + tireThickness / 2, tireThickness / 2, 16, 100), tireMaterial); wheelGroup.add(tire); const rimShape = new THREE.Shape(); rimShape.absarc(0, 0, rimRadius, 0, Math.PI * 2, false); const holePath = new THREE.Path(); holePath.absarc(0, 0, rimRadius * 0.85, 0, Math.PI * 2, true); rimShape.holes.push(holePath); const extrudeSettings = { depth: width * 0.4, bevelEnabled: false }; const outerRimGeometry = new THREE.ExtrudeGeometry(rimShape, extrudeSettings); outerRimGeometry.center(); const outerRim = new THREE.Mesh(outerRimGeometry, rimMaterial); wheelGroup.add(outerRim); const hubRadius = rimRadius * 0.2; const hub = new THREE.Mesh(new THREE.CylinderGeometry(hubRadius, hubRadius, width * 0.5, 24), rimMaterial); hub.rotateX(Math.PI / 2); wheelGroup.add(hub); const spokeLength = (rimRadius * 0.85) - hubRadius; const spokeGeometry = new THREE.BoxGeometry(spokeLength, rimRadius * 0.15, width * 0.4); spokeGeometry.translate(hubRadius + spokeLength / 2, 0, 0); for (let i = 0; i < 6; i++) { const spoke = new THREE.Mesh(spokeGeometry, rimMaterial); spoke.rotation.z = i * (Math.PI / 3); wheelGroup.add(spoke); } return wheelGroup; }
    function createRobotModel3D() { const BODY_WIDTH = 9.0, BODY_HEIGHT = 6.0, BODY_DEPTH = 3.5, WHEEL_GAP = 1.0; const MAST_HEIGHT = 14.5, MAST_THICKNESS = 1.5; const BATTERY_WIDTH = 6.0, BATTERY_HEIGHT = 1.0, BATTERY_DEPTH = 3.0; const TIRE_THICKNESS = 1.0, WHEEL_WIDTH = 2.0; const WHEEL_RADIUS_3D = 4.1; const pivot = new THREE.Object3D(); const model = new THREE.Group(); const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x1C1C1C }); const batteryMaterial = new THREE.MeshStandardMaterial({ color: 0x4169E1 }); const body = new THREE.Mesh(new THREE.BoxGeometry(BODY_WIDTH, BODY_HEIGHT, BODY_DEPTH), bodyMaterial); body.position.y = WHEEL_RADIUS_3D; model.add(body); const mast = new THREE.Mesh(new THREE.BoxGeometry(MAST_THICKNESS, MAST_HEIGHT, MAST_THICKNESS), bodyMaterial); mast.position.y = WHEEL_RADIUS_3D + BODY_HEIGHT / 2 + MAST_HEIGHT / 2; model.add(mast); const battery = new THREE.Mesh(new THREE.BoxGeometry(BATTERY_WIDTH, BATTERY_HEIGHT, BATTERY_DEPTH), batteryMaterial); battery.position.y = mast.position.y + MAST_HEIGHT / 2 + BATTERY_HEIGHT / 2; model.add(battery); leftWheel = createCustomWheel(WHEEL_RADIUS_3D, TIRE_THICKNESS, WHEEL_WIDTH); leftWheel.rotation.y = Math.PI / 2; leftWheel.position.set(-(BODY_WIDTH / 2 + WHEEL_GAP), WHEEL_RADIUS_3D, 0); model.add(leftWheel); rightWheel = createCustomWheel(WHEEL_RADIUS_3D, TIRE_THICKNESS, WHEEL_WIDTH); rightWheel.rotation.y = Math.PI / 2; rightWheel.position.set(BODY_WIDTH / 2 + WHEEL_GAP, WHEEL_RADIUS_3D, 0); model.add(rightWheel); model.position.y = -WHEEL_RADIUS_3D; pivot.add(model); return pivot; }
    function createCheckerTexture(squareSizeCm = 20, colorA = '#C8C8C8', colorB = '#787878') { const size = 256; const squares = 2; const canvas = document.createElement('canvas'); canvas.width = size; canvas.height = size; const ctx = canvas.getContext('2d'); const s = size / squares; for (let y = 0; y < squares; y++) { for (let x = 0; x < squares; x++) { ctx.fillStyle = ((x + y) % 2 === 0) ? colorA : colorB; ctx.fillRect(x * s, y * s, s, s); } } const tex = new THREE.CanvasTexture(canvas); tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping; tex.anisotropy = 8; tex.encoding = THREE.sRGBEncoding; return tex; }
    function createSkyTexture() { const width = 1024, height = 512; const canvas = document.createElement('canvas'); canvas.width = width; canvas.height = height; const ctx = canvas.getContext('2d'); const grad = ctx.createLinearGradient(0, 0, 0, height); grad.addColorStop(0, '#87CEEB'); grad.addColorStop(1, '#E6F2FA'); ctx.fillStyle = grad; ctx.fillRect(0, 0, width, height); ctx.globalAlpha = 0.15; ctx.fillStyle = '#FFFFFF'; for (let i = 0; i < 12; i++) { const cx = Math.random() * width, cy = Math.random() * height * 0.6, rw = 120 + Math.random() * 180, rh = 30 + Math.random() * 40; ctx.beginPath(); ctx.ellipse(cx, cy, rw, rh, 0, 0, Math.PI * 2); ctx.fill(); } const tex = new THREE.CanvasTexture(canvas); tex.encoding = THREE.sRGBEncoding; return tex; }
    function setupControls3D() { document.getElementById('reset3dViewBtn').addEventListener('click', () => { camera3D.position.set(28, 22, 48); controls3D.target.set(0, 8, 0); controls3D.update(); }); document.getElementById('toggle3dAnimationBtn').addEventListener('click', () => isAnimation3DEnabled = !isAnimation3DEnabled); document.getElementById('toggle3dMovementBtn').addEventListener('click', () => { isMovement3DEnabled = !isMovement3DEnabled; if(!isMovement3DEnabled) { lastEncoderAvg = (currentEncoderLeft + currentEncoderRight) / 2; } }); }
    function animate3D() {
        requestAnimationFrame(animate3D);
        if (isAnimation3DEnabled && robotPivot) {
            // Use the unified window.telemetryData object
            const pitch = window.telemetryData?.pitch || 0;
            const roll = window.telemetryData?.roll || 0;
            const yaw = window.telemetryData?.yaw || 0;

            const pitchRad = pitch * Math.PI / 180;
            const rollRad = roll * Math.PI / 180;
            const yawRad = yaw * Math.PI / 180;

            robotPivot.rotation.set(rollRad, yawRad, pitchRad, 'ZYX');

            const ppr = parseFloat(document.getElementById('encoderPprInput').value) || 820;
            const wheelRotationL = (currentEncoderLeft / ppr) * 2 * Math.PI;
            const wheelRotationR = (currentEncoderRight / ppr) * 2 * Math.PI;
            if (leftWheel) leftWheel.rotation.z = -wheelRotationL;
            if (rightWheel) rightWheel.rotation.z = -wheelRotationR;
            if (isMovement3DEnabled) {
                const wheelDiameter = parseFloat(document.getElementById('wheelDiameterInput').value) || 8.2;
                const currentEncoderAvg = (currentEncoderLeft + currentEncoderRight) / 2;
                const dist_cm = ((currentEncoderAvg - lastEncoderAvg) / ppr) * Math.PI * wheelDiameter;
                const angleRad = robotPivot.rotation.y;
                if (groundTexture) {
                    const dx = Math.sin(angleRad) * dist_cm;
                    const dz = Math.cos(angleRad) * dist_cm;
                    const squaresPerCm = 1 / 20;
                    groundTexture.offset.x += dx * squaresPerCm;
                    groundTexture.offset.y += dz * squaresPerCm;
                    groundTexture.needsUpdate = true;
                }
                const logicalX = (groundTexture ? -groundTexture.offset.x * 20 : 0);
                const logicalZ = (groundTexture ? -groundTexture.offset.y * 20 : 0);
                document.getElementById('robot3d-position-x').textContent = logicalX.toFixed(1) + ' cm';
                document.getElementById('robot3d-position-z').textContent = logicalZ.toFixed(1) + ' cm';
                lastEncoderAvg = currentEncoderAvg;
            }
        }
        if (controls3D && renderer3D && scene3D && camera3D) { // Add safety check
            controls3D.update();
            renderer3D.render(scene3D, camera3D);
        }
    }
</script>
</body>
</html>
