<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Robot Samo Balansujacy - Wersja 17.0-REALISTIC-SIM</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; margin: 0; padding: 15px; background-color: #282c34; color: #fff; font-size: 14px; }
        h1 { color: #61dafb; font-size: 1.8em; }
        h2 { color: #61dafb; font-size: 1.4em; margin-top: 0; margin-bottom: 15px; }
        .main-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(340px, 1fr)); gap: 15px; align-items: start; max-width: 1920px; margin: auto; }
        .card { background-color: #3a3f47; border-radius: 8px; padding: 15px; box-shadow: 0 2px 6px rgba(0,0,0,0.2); }
        .info-grid, .status-grid { display: grid; grid-template-columns: auto 1fr; gap: 8px; text-align: left; font-size: 1em; margin-top: 10px; align-items: center;}
        .info-grid strong, .status-grid strong { color: #a2f279; }
        button { background-color: #61dafb; color: #282c34; border: none; padding: 8px 12px; border-radius: 5px; font-weight: bold; cursor: pointer; transition: background-color 0.3s; font-size: 0.9em; }
        button:hover { background-color: #a2f279; }
        button:disabled { background-color: #4a4f58; color: #888; cursor: not-allowed; }
        #emergencyStopBtn { background-color: #ff6347; color: white; width: 100%; margin-top: 15px; }
        .control-row { display: flex; align-items: center; justify-content: space-between; width: 100%; margin-top: 10px; }
        .control-label { font-size: 1.1em; font-weight: bold; }
        .switch { position: relative; display: inline-block; width: 50px; height: 28px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider.round { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ff6347; transition: .4s; border-radius: 28px; }
        .slider.round:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #a2f279; }
        input:checked + .slider:before { transform: translateX(22px); }
        input:disabled + .slider { background-color: #4a4f58; cursor: not-allowed; }
        fieldset { border: 1px solid #4a4f58; border-radius: 8px; margin-top: 15px; padding: 10px 15px; }
        legend { color: #61dafb; font-weight: bold; padding: 0 10px; font-size: 1.1em; }
        #joystickWrapper { position: relative; width: 180px; height: 180px; border-radius: 50%; background-color: #4a4f58; border: 3px solid #61dafb; margin: 15px auto; }
        #joystickCanvas { width: 100%; height: 100%; display: block; }
        #chart-wrapper, #canvas-3d-container { position: relative; height: 320px; border-radius: 8px; overflow: hidden; background-color: #20232a; }
        #log-container { text-align: left; height: 280px; overflow-y: auto; background-color: #20232a; padding: 10px; border-radius: 8px; margin-top: 15px; }
        .status-indicator { width: 14px; height: 14px; border-radius: 50%; display: inline-block; }
        .status-ok { background-color: #a2f279; }
        .status-warn { background-color: #f7b731; }
        .status-error { background-color: #ff6347; }
        .status-disconnected { background-color: #888; }
        #emergency-banner { display: none; background-color: #ff6347; color: white; padding: 10px; font-weight: bold; position: fixed; top: 0; left: 0; width: 100%; z-index: 1000; }
        .angle-display { display: flex; align-items: center; justify-content: space-between; }
        .angle-indicator-wrapper { position: relative; width: 34px; height: 34px; background-color: #20232a; border-radius: 50%; border: 1px solid #61dafb; }
        .angle-indicator-needle { position: absolute; bottom: 50%; left: calc(50% - 1px); width: 2px; height: 50%; background-color: #ff6347; transform-origin: bottom center; transition: transform 0.1s linear; }
        .profile-controls { display: flex; gap: 10px; margin-top: 10px; }
        .chart-controls { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin-top: 10px; font-size: 0.9em; }
        .chart-controls label { color: #fff; }
        .setting-block { margin-bottom: 0; }
        .setting-container { display: flex; align-items: center; gap: 8px; margin: 8px 0; }
        .setting-container label { font-size: 1em; font-weight: bold; color: #a2f279; text-align: left; flex-grow: 1; }
        .numeric-input-wrapper { display: flex; align-items: center; flex-shrink: 0; }
        .numeric-input-wrapper button { background-color: #4a4f58; color: #61dafb; padding: 4px 8px; font-size: 1em; line-height: 1; min-width: 30px; }
        .numeric-input-wrapper input[type=number] { width: 75px; text-align: center; font-size: 1em; background-color: #20232a; color: #fff; border: 1px solid #61dafb; border-radius: 5px; margin: 0 4px; padding: 4px; -moz-appearance: textfield; }
        input[type=number]::-webkit-inner-spin-button, input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        .manual-tune-row { display: grid; grid-template-columns: 1fr auto auto; gap: 10px; align-items: center; margin-bottom: 8px; }
        .manual-tune-row label { text-align: left; font-weight: bold; color: #a2f279; }
        .manual-tune-row .test-btn { background-color: #a2f279; }
        .manual-tune-row .stop-btn { background-color: #ff6347; }
        .manual-tune-readout { margin-top: 15px; font-size: 1.2em; font-weight: bold; display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .trim-controls { display: flex; justify-content: space-between; align-items: center; margin-top: 10px; }
        .trim-controls span { font-weight: bold; }
        .trim-controls button { min-width: 40px; font-size: 1.2em; }
        .dpad-container { display: grid; grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 1fr 1fr; gap: 5px; max-width: 150px; margin: 15px auto; }
        .dpad-btn { background-color: #61dafb; color: #282c34; border-radius: 5px; font-size: 2em; line-height: 1; padding: 5px; cursor: pointer; border: none; }
        .dpad-btn:hover { background-color: #a2f279; }
        #dpad-up { grid-column: 2; grid-row: 1; }
        #dpad-left { grid-column: 1; grid-row: 2; }
        #dpad-right { grid-column: 3; grid-row: 2; }
        #dpad-down { grid-column: 2; grid-row: 3; }
        #dpad-stop { grid-column: 2; grid-row: 2; background-color: #ff6347; color: white; }
        .dpad-input-group { display: grid; grid-template-columns: 1fr auto; gap: 10px; align-items: center; margin: 10px 0; }
        .dpad-input-group label { text-align: right; font-weight: bold; color: #a2f279; }
        .dpad-input-group input { width: 100%; box-sizing: border-box; }
        .accordion-header { background-color: #4a4f58; color: #61dafb; cursor: pointer; padding: 12px 15px; border: none; text-align: left; outline: none; font-size: 1.1em; font-weight: bold; width: 100%; border-radius: 8px; margin-top: 10px; transition: background-color 0.3s; position: relative; }
        .accordion-header:hover { background-color: #5a6068; }
        .accordion-header.active { background-color: #61dafb; color: #282c34; border-bottom-left-radius: 0; border-bottom-right-radius: 0;}
        .accordion-header::after { content: '+'; position: absolute; right: 15px; font-size: 1.4em; transition: transform 0.3s; }
        .accordion-header.active::after { content: '-'; }
        .accordion-content { max-height: 0; overflow: hidden; transition: max-height 0.4s ease-out; background-color: #3a3f47; border-bottom-left-radius: 8px; border-bottom-right-radius: 8px;}
        .accordion-content.active { max-height: 2000px; transition: max-height 0.4s ease-in; padding: 15px; }
        .pwm-info { background-color: #20232a; padding: 10px; border-radius: 5px; margin-bottom: 15px; border-left: 4px solid #61dafb; }
        .pwm-info strong { color: #a2f279; }
    </style>
</head>
<body>
    <div id="emergency-banner">ZATRZYMANIE AWARYJNE</div>

    <h1>Robot Samo Balansujacy - Panel Sterowania</h1>
    <div class="main-grid">
        <div class="card" id="controls-card">
            <h2>Sterowanie</h2>
            <div id="joystickWrapper"><canvas id="joystickCanvas"></canvas></div>
            <div class="control-row"><span class="control-label">Balansowanie</span><label class="switch"><input type="checkbox" id="balanceSwitch"><span class="slider round"></span></label></div>
            <div class="control-row"><span class="control-label">Trzymaj Pozycje</span><label class="switch"><input type="checkbox" id="holdPositionSwitch"><span class="slider round"></span></label></div>
            <div class="control-row"><span class="control-label">Tryb Predkosci</span><label class="switch"><input type="checkbox" id="speedModeSwitch"><span class="slider round"></span></label></div>
            
            <fieldset style="padding: 10px 10px 5px 10px;"><legend>Strojenie Joysticka</legend>
                <div class="setting-block"><div class="setting-container"><label for="expoJoystickInput">Expo Joysticka (%)</label><div class="numeric-input-wrapper"><button id="expoJoystickMinus">-</button><input type="number" id="expoJoystickInput" min="0" max="90" step="1" value="0"><button id="expoJoystickPlus">+</button></div></div></div>
                <div class="setting-block"><div class="setting-container"><label for="joystickSensitivityInput">Czulosc Joysticka (%)</label><div class="numeric-input-wrapper"><button id="joystickSensitivityMinus">-</button><input type="number" id="joystickSensitivityInput" min="10" max="100" step="1" value="100"><button id="joystickSensitivityPlus">+</button></div></div></div>
                <div class="setting-block"><div class="setting-container"><label for="maxSpeedJoystickInput">Max. predkosc (imp/s)</label><div class="numeric-input-wrapper"><button id="maxSpeedJoystickMinus">-</button><input type="number" id="maxSpeedJoystickInput" min="200" max="4000" step="100" value="800"><button id="maxSpeedJoystickPlus">+</button></div></div></div>
            </fieldset>
            
            <hr style="border-color: #4a4f58; margin: 15px 0;">
            <button id="resetZeroBtn">Resetuj Osie</button>
            <div class="trim-controls">
                <button id="trimMinusBtn">-</button>
                <span>Korekta Pionu (Pitch)</span>
                <button id="trimPlusBtn">+</button>
            </div>
            <div class="trim-controls">
                <button id="trimRollMinusBtn">-</button>
                <span>Korekta Przechylu (Roll)</span>
                <button id="trimRollPlusBtn">+</button>
            </div>
            <button id="resetEncodersBtn" style="margin-top:10px; background-color:#f7b731;">Resetuj Enkodery</button>
            <button id="emergencyStopBtn">STOP AWARYJNY</button>
        </div>
        
        <div class="card">
            <h2>Status Robota</h2>
            <button id="connectBleBtn" style="width: 100%; margin-bottom: 15px;">POLACZ Z ROBOTEM PRZEZ BLUETOOTH</button>
            <div class="status-grid">
                <strong>Polaczenie:</strong> <div><span id="connectionStatus" class="status-indicator status-disconnected"></span> <span id="connectionText">Rozlaczony</span></div>
                <strong>Status Systemu:</strong> <div><span id="systemStatus" class="status-indicator status-disconnected"></span> <span id="systemText">Nieznany</span></div>
                <strong>Status Kontrolera:</strong> <span id="gamepadStatus" style="font-weight:bold; color: #f7b731;">Brak</span>
                <strong>Tryb Pracy:</strong> <span id="robotStateVal" style="font-weight:bold; color: #61dafb;">IDLE</span>
                <strong>Czas Petli:</strong> <span id="loopTimeVal">0 &micro;s</span>
                <strong>PWM Rozdzielczosc:</strong> <span id="pwmResolutionVal" style="font-weight:bold; color: #a2f279;">10-bit (1023)</span>
            </div>
            <div class="info-grid">
                <strong>Kat (Pitch):</strong> <div class="angle-display"><span id="angleVal">0.0 &deg;</span><div class="angle-indicator-wrapper"><div id="angleIndicator" class="angle-indicator-needle"></div></div></div>
                <strong>Kat (Roll):</strong> <span id="rollVal">0.0 &deg;</span>
                <strong>Predkosc (imp/s):</strong> <span id="speedVal">0</span>
                <strong>Zadany Kat:</strong> <span id="targetAngleVal">0.0 &deg;</span>
                <hr style="grid-column: 1 / -1; border-color: #4a4f58; margin: 5px 0;">
                <strong>PID Balans Wyj.:</strong> <span id="balanceOutputVal">0</span>
                <strong>Lewy Silnik:</strong> <span id="leftMotorVal">0</span>
                <strong>Prawy Silnik:</strong> <span id="rightMotorVal">0</span>
                <hr style="grid-column: 1 / -1; border-color: #4a4f58; margin: 5px 0;">
                <strong>Enkoder L:</strong> <span id="encoderLeftVal">0</span>
                <strong>Enkoder P:</strong> <span id="encoderRightVal">0</span>
            </div>
        </div>

        <div class="card">
            <button class="accordion-header active">Wizualizacja 3D</button>
            <div class="accordion-content active" style="padding: 0;">
                 <div id="canvas-3d-container"></div>
            </div>
        </div>

        <div class="card">
             <button class="accordion-header">Sterowanie Precyzyjne</button>
             <div class="accordion-content">
                <fieldset>
                    <legend>Sterowanie Precyzyjne</legend>
                    <div class="dpad-input-group"><label for="dpadDistInput">Dystans (cm):</label><input type="number" id="dpadDistInput" value="20"></div>
                    <div class="dpad-input-group"><label for="dpadAngleInput">Kat (st.):</label><input type="number" id="dpadAngleInput" value="10"></div>
                    <div class="dpad-container">
                        <button id="dpad-up" class="dpad-btn">&#8593;</button>
                        <button id="dpad-left" class="dpad-btn">&#8592;</button>
                        <button id="dpad-stop" class="dpad-btn">&#215;</button>
                        <button id="dpad-right" class="dpad-btn">&#8594;</button>
                        <button id="dpad-down" class="dpad-btn">&#8595;</button>
                    </div>
                </fieldset>
                <fieldset style="margin-top: 15px;">
                    <legend>Diagnostyka</legend>
                    <div id="diagnostic-controls" style="display: flex; justify-content: center;">
                        <button id="startDiagnosticBtn" style="width:100%;background-color:#f7b731;">Start Analizatora Enkoderow</button>
                        <button id="stopDiagnosticBtn" style="display:none; background-color: #ff6347;width:100%;">Stop Analizatora</button>
                    </div>
                     <button id="calibrateMpuBtn" style="width:100%; margin-top:10px; background-color:#f7b731;">Kalibruj MPU (DMP)</button>
                </fieldset>
            </div>
        </div>
        
        <div class="card">
            <button class="accordion-header">Wykres Telemetryczny</button>
            <div class="accordion-content">
                <div id="chart-wrapper"><canvas id="telemetryChart"></canvas></div>
                <div class="chart-controls" id="chartControls"></div>
            </div>
        </div>
        
        <div class="card">
            <h2>Konfiguracja</h2>
            <fieldset>
                <legend>Profile Konfiguracyjne</legend>
                <div class="profile-controls">
                    <select id="profileSelect"></select>
                    <button id="applyProfileBtn">Zastosuj do Robota</button>
                </div>
                <div class="profile-controls">
                    <input type="text" id="profileNameInput" placeholder="Nazwa nowego profilu">
                    <button id="saveProfileBtn">Zapisz</button>
                </div>
            </fieldset>
            
            <div id="allSettings">
                <button class="accordion-header">0. Konfiguracja Fizyczna i Dynamika</button>
                <div class="accordion-content">
                    <div class="setting-container"><label for="encoderPPRInput">Impulsy na obrot (PPR)</label><div class="numeric-input-wrapper"><button id="encoderPPRMinus">-</button><input type="number" id="encoderPPRInput" min="100" max="5000" step="1" value="820"><button id="encoderPPRPlus">+</button></div></div>
                    <div class="setting-container"><label for="wheelDiameterCmInput">Srednica kola (cm)</label><div class="numeric-input-wrapper"><button id="wheelDiameterCmMinus">-</button><input type="number" id="wheelD
ameterCmInput" min="1" max="20" step="0.1" value="8.2"><button id="wheelDiameterCmPlus">+</button></div></div>
                    <div class="setting-container"><label for="trackWidthCmInput">Rozstaw kol (cm)</label><div class="numeric-input-wrapper"><button id="trackWidthCmMinus">-</button><input type="number" id="trackWidthCmInput" min="1" max="40" step="0.1" value="13.0"><button id="trackWidthCmPlus">+</button></div></div>
                    <div class="setting-container"><label for="motorBacklashInput">Luz silnika (impulsy)</label><div class="numeric-input-wrapper"><button id="motorBacklashMinus">-</button><input type="number" id="motorBacklashInput" min="0" max="200" step="1" value="0"><button id="motorBacklashPlus">+</button></div></div>
                    <hr style="border-color: #4a4f58; margin: 10px 0;">
                    <div class="setting-container"><label for="turnToRollTargetInput">Docelowy Kat Pochylenia (st.)</label><div class="numeric-input-wrapper"><button id="turnToRollTargetMinus">-</button><input type="number" id="turnToRollTargetInput" min="0" max="15" step="0.5" value="5.0"><button id="turnToRollTargetPlus">+</button></div></div>
                    <hr style="border-color: #4a4f58; margin: 10px 0;">
                    <div class="setting-container"><label for="balanceDeadbandAngleInput">Martwa Strefa Balansu (st.)</label><div class="numeric-input-wrapper"><button id="balanceDeadbandAngleMinus">-</button><input type="number" id="balanceDeadbandAngleInput" min="0" max="5" step="0.1" value="0.5"><button id="balanceDeadbandAnglePlus">+</button></div></div>
                </div>

                <button class="accordion-header">1. Strojenie Min. PWM (10-bit)</button>
                <div class="accordion-content">
                     <div class="pwm-info">
                         <strong>ZAKRES:</strong> 0-1023 (10-bit)<br>
                         <strong>TYPOWE WARTOSCI:</strong> 600-700 dla wielu silnikow
                     </div>
                     <p style="margin-top:0; margin-bottom:15px; text-align:left;">Podnies robota w powietrze! Ustaw PWM i kliknij 'Testuj', aby znalezc prog startowy silnika.</p>
                     <div class="manual-tune-row" data-motor="left" data-direction="fwd"><label>Lewy (Przod)</label><div class="numeric-input-wrapper"><button class="tune-minus">-</button><input type="number" class="tune-input" min="0" max="1023" step="1" value="0"><button class="tune-plus">+</button></div><div><button class="test-btn">Testuj</button><button class="stop-btn">Stop</button></div></div>
                     <div class="manual-tune-row" data-motor="left" data-direction="bwd"><label>Lewy (Tyl)</label><div class="numeric-input-wrapper"><button class="tune-minus">-</button><input type="number" class="tune-input" min="0" max="1023" step="1" value="0"><button class="tune-plus">+</button></div><div><button class="test-btn">Testuj</button><button class="stop-btn">Stop</button></div></div>
                     <div class="manual-tune-row" data-motor="right" data-direction="fwd"><label>Prawy (Przod)</label><div class="numeric-input-wrapper"><button class="tune-minus">-</button><input type="number" class="tune-input" min="0" max="1023" step="1" value="0"><button class="tune-plus">+</button></div><div><button class="test-btn">Testuj</button><button class="stop-btn">Stop</button></div></div>
                     <div class="manual-tune-row" data-motor="right" data-direction="bwd"><label>Prawy (Tyl)</label><div class="numeric-input-wrapper"><button class="tune-minus">-</button><input type="number" class="tune-input" min="0" max="1023" step="1" value="0"><button class="tune-plus">+</button></div><div><button class="test-btn">Testuj</button><button class="stop-btn">Stop</button></div></div>
                     <hr style="border-color: #4a4f58; margin: 15px 0;">
                     <div class="manual-tune-readout"><div>Enkoder L: <span id="manualEncoderL">0</span></div><div>Enkoder P: <span id="manualEncoderR">0</span></div></div>
                     <button id="manualTuneStopAll" style="width:100%; margin-top:15px; background-color:#ff6347;">ZATRZYMAJ WSZYSTKO</button>
                </div>

                <button class="accordion-header">2. Ustawienia Min. PWM (10-bit)</button>
                <div class="accordion-content">
                    <div class="pwm-info">
                        <strong>ZAKRES:</strong> 0-1023 (10-bit)<br>
                        <strong>TYPOWE WARTOSCI:</strong> 600-700 dla wielu silnikow
                    </div>
                    <div class="setting-block"><div class="setting-container"><label for="minPwmLeftFwdInput">Min. PWM L (Przod)</label><div class="numeric-input-wrapper"><button id="minPwmLeftFwdMinus">-</button><input type="number" id="minPwmLeftFwdInput" min="0" max="1023" step="1" value="640"><button id="minPwmLeftFwdPlus">+</button></div></div></div>
                    <div class="setting-block"><div class="setting-container"><label for="minPwmLeftBwdInput">Min. PWM L (Tyl)</label><div class="numeric-input-wrapper"><button id="minPwmLeftBwdMinus">-</button><input type="number" id="minPwmLeftBwdInput" min="0" max="1023" step="1" value="640"><button id="minPwmLeftBwdPlus">+</button></div></div></div>
                    <div class="setting-block"><div class="setting-container"><label for="minPwmRightFwdInput">Min. PWM P (Przod)</label><div class="numeric-input-wrapper"><button id="minPwmRightFwdMinus">-</button><input type="number" id="minPwmRightFwdInput" min="0" max="1023" step="1" value="640"><button id="minPwmRightFwdPlus">+</button></div></div></div>
                    <div class="setting-block"><div class="setting-container"><label for="minPwmRightBwdInput">Min. PWM P (Tyl)</label><div class="numeric-input-wrapper"><button id="minPwmRightBwdMinus">-</button><input type="number" id="minPwmRightBwdInput" min="0" max="1023" step="1" value="640"><button id="minPwmRightBwdPlus">+</button></div></div></div>
                </div>
                
                <button class="accordion-header">3. Strojenie PID (Balans)</button>
                <div class="accordion-content">
                    <div class="setting-block"><div class="setting-container"><label for="joystickAngleSensitivityInput">Maksymalny Kat (Tryb Kata)</label><div class="numeric-input-wrapper"><button id="joystickAngleSensitivityMinus">-</button><input type="number" id="joystickAngleSensitivityInput" min="1" max="25" step="1" value="10"><button id="joystickAngleSensitivityPlus">+</button></div></div></div>
                    <div class="setting-block"><div class="setting-container"><label for="kpBalanceInput">Kp (Sztywnosc)</label><div class="numeric-input-wrapper"><button id="kpBalanceMinus">-</button><input type="number" id="kpBalanceInput" min="0" max="200" step="1" value="95"><button id="kpBalancePlus">+</button></div></div></div>
                    <div class="setting-block"><div class="setting-container"><label for="kiBalanceInput">Ki (Korekta bledu)</label><div class="numeric-input-wrapper"><button id="kiBalanceMinus">-</button><input type="number" id="kiBalanceInput" min="0" max="20" step="0.05" value="0"><button id="kiBalancePlus">+</button></div></div></div>
                    <div class="setting-block"><div class="setting-container"><label for="kdBalanceInput">Kd (Tlumienie)</label><div class="numeric-input-wrapper"><button id="kdBalanceMinus">-</button><input type="number" id="kdBalanceInput" min="0" max="20" step="0.01" value="3.23"><button id="kdBalancePlus">+</button></div></div></div>
                    <hr style="border-color: #4a4f58; margin: 10px 0;">
                    <p style="font-weight:bold; color: #61dafb; margin-top: 0;">Ustawienia zaawansowane:</p>
                    <div class="setting-block"><div class="setting-container"><label for="balancePidDerivativeFilterAlphaInput">Filtr pochodnej (Alfa)</label><div class="numeric-input-wrapper"><button id="balancePidDerivativeFilterAlphaMinus">-</button><input type="number" id="balancePidDerivativeFilterAlphaInput" min="0.01" max="1.0" step="0.01" value="1"><button id="balancePidDerivativeFilterAlphaPlus">+</button></div></div></div>
                </div>
                
                <button class="accordion-header">4. Strojenie PID (Predkosc)</button>
                <div class="accordion-content">
                    <div class="setting-block"><div class="setting-container"><label for="maxTargetAngleFromSpeedPIDInput">Maksymalny Kat (Tryb Predkosci)</label><div class="numeric-input-wrapper"><button id="maxTargetAngleFromSpeedPIDMinus">-</button><input type="number" id="maxTargetAngleFromSpeedPIDInput" min="1" max="25" step="1" value="15"><button id="maxTargetAngleFromSpeedPIDPlus">+</button></div></div></div>
                    <div class="setting-block"><div class="setting-container"><label for="kpSpeedInput">Kp Predkosci</label><div class="numeric-input-wrapper"><button id="kpSpeedMinus">-</button><input type="number" id="kpSpeedInput" min="0" max="5.0" step="0.01" value="0.05"><button id="kpSpeedPlus">+</button></div></div></div>
                    <div class="setting-block"><div class="setting-container"><label for="kiSpeedInput">Ki Predkosci</label><div class="numeric-input-wrapper"><button id="kiSpeedMinus">-</button><input type="number" id="kiSpeedInput" min="0" max="1.0" step="0.001" value="0"><button id="kiSpeedPlus">+</button></div></div></div>
                    <div class="setting-block"><div class="setting-container"><label for="kdSpeedInput">Kd Predkosci</label><div class="numeric-input-wrapper"><button id="kdSpeedMinus">-</button><input type="number" id="kdSpeedInput" min="0" max="1.0" step="0.001" value="0"><button id="kdSpeedPlus">+</button></div></div></div>
                    <div class="setting-block"><div class="setting-container"><label for="speedPidDeadbandInput">Margines bledu (imp/s)</label><div class="numeric-input-wrapper"><button id="speedPidDeadbandMinus">-</button><input type="number" id="speedPidDeadbandInput" min="0" max="100" step="1" value="5"><button id="speedPidDeadbandPlus">+</button></div></div></div>
                </div>

                <button class="accordion-header">5. Strojenie PID (Pozycja)</button>
                <div class="accordion-content">
                    <div class="setting-block"><div class="setting-container"><label for="maxTargetSpeedFromPosPIDInput">Max predkosc z PID Pozycji (imp/s)</label><div class="numeric-input-wrapper"><button id="maxTargetSpeedFromPosPIDMinus">-</button><input type="number" id="maxTargetSpeedFromPosPIDInput" min="200" max="4000" step="100" value="1000"><button id="maxTargetSpeedFromPosPIDPlus">+</button></div></div></div>
                    <div class="setting-block"><div class="setting-container"><label for="kpPositionInput">Kp Pozycji</label><div class="numeric-input-wrapper"><button id="kpPositionMinus">-</button><input type="number" id="kpPositionInput" min="0" max="5.0" step="0.05" value="2.5"><button id="kpPositionPlus">+</button></div></div></div>
                    <div class="setting-block"><div class="setting-container"><label for="kiPositionInput">Ki Pozycji</label><div class="numeric-input-wrapper"><button id="kiPositionMinus">-</button><input type="number" id="kiPositionInput" min="0" max="0.1" step="0.001" value="0.006"><button id="kiPositionPlus">+</button></div></div></div>
                    <div class="setting-block"><div class="setting-container"><label for="kdPositionInput">Kd Pozycji</label><div class="numeric-input-wrapper"><button id="kdPositionMinus">-</button><input type="number" id="kdPositionInput" min="0" max="5.0" step="0.01" value="1"><button id="kdPositionPlus">+</button></div></div></div>
                    <div class="setting-block"><div class="setting-container"><label for="positionPidDeadbandInput">Margines bledu (impulsy)</label><div class="numeric-input-wrapper"><button id="positionPidDeadbandMinus">-</button><input type="number" id="positionPidDeadbandInput" min="0" max="100" step="1" value="15"><button id="positionPidDeadbandPlus">+</button></div></div></div>
                </div>
                
                <button class="accordion-header">6. Strojenie PID (Obrot)</button>
                <div class="accordion-content">
                    <div class="setting-block"><div class="setting-container"><label for="kpRotationInput">Kp Obrotu</label><div class="numeric-input-wrapper"><button id="kpRotationMinus">-</button><input type="number" id="kpRotationInput" min="0" max="10.0" step="0.1" value="1"><button id="kpRotationPlus">+</button></div></div></div>
                    <div class="setting-block"><div class="setting-container"><label for="kdRotationInput">Kd Obrotu</label><div class="numeric-input-wrapper"><button id="kdRotationMinus">-</button><input type="number" id="kdRotationInput" min="0" max="10.0" step="0.1" value="1"><button id="kdRotationPlus">+</button></div></div></div>
                </div>

                <button class="accordion-header">7. Strojenie PID (Utrzymanie Kierunku)</button>
                <div class="accordion-content">
                    <div class="pwm-info">
                         <strong>INFO:</strong> Ten regulator jest aktywny tylko, gdy nie skrecasz joystickiem.<br>
                         Automatycznie utrzymuje jazde na wprost.
                     </div>
                    <div class="setting-block"><div class="setting-container"><label for="kpHeadingInput">Kp Kierunku</label><div class="numeric-input-wrapper"><button id="kpHeadingMinus">-</button><input type="number" id="kpHeadingInput" min="0" max="10.0" step="0.1" value="0.8"><button id="kpHeadingPlus">+</button></div></div></div>
                    <div class="setting-block"><div class="setting-container"><label for="kiHeadingInput">Ki Kierunku</label><div class="numeric-input-wrapper"><button id="kiHeadingMinus">-</button><input type="number" id="kiHeadingInput" min="0" max="2.0" step="0.01" value="0.02"><button id="kiHeadingPlus">+</button></div></div></div>
                    <div class="setting-block"><div class="setting-container"><label for="kdHeadingInput">Kd Kierunku</label><div class="numeric-input-wrapper"><button id="kdHeadingMinus">-</button><input type="number" id="kdHeadingInput" min="0" max="5.0" step="0.05" value="0.1"><button id="kdHeadingPlus">+</button></div></div></div>
                </div>

                <button class="accordion-header">8. Strojenie PID (Przechyl w Skrecie)</button>
                <div class="accordion-content">
                    <div class="pwm-info">
                         <strong>INFO:</strong> Ten regulator stabilizuje robota na boki podczas skrecania.
                     </div>
                    <div class="setting-block"><div class="setting-container"><label for="kpRollInput">Kp Przechylu</label><div class="numeric-input-wrapper"><button id="kpRollMinus">-</button><input type="number" id="kpRollInput" min="0" max="50.0" step="0.5" value="15.0"><button id="kpRollPlus">+</button></div></div></div>
                    <div class="setting-block"><div class="setting-container"><label for="kiRollInput">Ki Przechylu</label><div class="numeric-input-wrapper"><button id="kiRollMinus">-</button><input type="number" id="kiRollInput" min="0" max="10.0" step="0.1" value="0.0"><button id="kiRollPlus">+</button></div></div></div>
                    <div class="setting-block"><div class="setting-container"><label for="kdRollInput">Kd Przechylu</label><div class="numeric-input-wrapper"><button id="kdRollMinus">-</button><input type="number" id="kdRollInput" min="0" max="5.0" step="0.05" value="0.5"><button id="kdRollPlus">+</button></div></div></div>
                </div>

                <button class="accordion-header">9. Ustawienia Dodatkowe</button>
                <div class="accordion-content">
                    <div class="setting-block"><div class="setting-container"><label for="joystickDeadzoneInput">Martwa Strefa (%)</label><div class="numeric-input-wrapper"><button id="joystickDeadzoneMinus">-</button><input type="number" id="joystickDeadzoneInput" min="0" max="50" step="1" value="0"><button id="joystickDeadzonePlus">+</button></div></div></div>
                    <div class="setting-block"><div class="setting-container"><label for="turnFactorInput">Moc Skretu (%)</label><div class="numeric-input-wrapper"><button id="turnFactorMinus">-</button><input type="number" id="turnFactorInput" min="0" max="100" step="1" value="25"><button id="turnFactorPlus">+</button></div></div></div>
                </div>
            </div>
            <div class="button-group" style="display:flex; gap:10px; justify-content:center; margin-top:20px;">
                <button id="loadBtn">Wczytaj z EEPROM</button>
                <button id="saveBtn">Zapisz Ustawienia</button>
            </div>
        </div>
        <div class="card" id="log-container">
            <h2>Historia Zdarzen</h2>
            <div id="log-history"></div>
        </div>
    </div>

<script>
    // Globalne zmienne dla joysticka - przeniesione z DOMContentLoaded dla dostepnosci w window.onresize
    let joystickCanvas, joystickCtx, joystickCenter, joystickRadius, knobRadius, isDragging = false;

    // Funkcja resize joysticka - dostepna globalnie
    function resizeJoystick() { 
        const wrapper = document.getElementById('joystickWrapper'); 
        if (!wrapper || !joystickCanvas) {
            console.warn('Brak elementow joysticka podczas resize');
            return;
        }
        joystickCanvas.width = wrapper.offsetWidth; 
        joystickCanvas.height = wrapper.offsetHeight; 
        joystickCenter = { x: joystickCanvas.width / 2, y: joystickCanvas.height / 2 }; 
        joystickRadius = Math.min(joystickCanvas.width, joystickCanvas.height) / 2 * 0.9; 
        knobRadius = joystickRadius / 3; 
        drawJoystick(0, 0); 
    }

    // Funkcja rysowania joysticka - dostepna globalnie
    function drawJoystick(x, y) {
        if (!joystickCtx) {
            console.warn('Brak kontekstu canvas dla joysticka');
            return;
        }
        joystickCtx.clearRect(0, 0, joystickCanvas.width, joystickCanvas.height); 
        joystickCtx.beginPath(); 
        joystickCtx.arc(joystickCenter.x, joystickCenter.y, joystickRadius, 0, Math.PI * 2); 
        joystickCtx.fillStyle = '#4a4f58'; 
        joystickCtx.fill(); 
        joystickCtx.beginPath(); 
        joystickCtx.arc(joystickCenter.x + x, joystickCenter.y + y, knobRadius, 0, Math.PI * 2); 
        joystickCtx.fillStyle = '#a2f279'; 
        joystickCtx.fill(); 
    }

    document.addEventListener('DOMContentLoaded', () => {
        // Inicjalizacja elementow joysticka
        joystickCanvas = document.getElementById('joystickCanvas'); 
        if (!joystickCanvas) {
            console.error('Nie znaleziono elementu joystickCanvas');
            return;
        }
        joystickCtx = joystickCanvas.getContext('2d');

        const PROFILE_PREFIX = 'robot_profile_v16.7_final_';
        const availableTelemetry = {
            'pitch': { label: 'Pitch (Kat)', color: '#61dafb' },
            'roll': { label: 'Roll (Kat)', color: '#fd79a8' },
            'target_angle': { label: 'Zadany Kat', color: '#a2f279' },
            'speed': { label: 'Predkosc', color: '#f7b731' },
            'speed_setpoint': { label: 'Zadana Predkosc', color: '#ff6347' },
            'balance_output': { label: 'PID Balans', color: '#ff9ff3' },
            'left_motor': { label: 'Lewy Silnik', color: '#54a0ff' },
            'right_motor': { label: 'Prawy Silnik', color: '#ee5253' }
        };
        let lastUserInteraction = {};
        const INTERACTION_TIMEOUT = 500;
        let finalTargetAngleForDisplay = 0.0;
        let gamepadIndex, gamepadPollInterval, lastGamepadState = { x: 0, y: 0, buttons: [] };
        let bleDevice, rxCharacteristic, txCharacteristic;
        let pendingConfigSegments = {};
        const SERVICE_UUID = "4fafc201-1fb5-459e-8fcc-c5c9c331914b";
        const RX_UUID      = "beb5483e-36e1-4688-b7f5-ea07361b26a9";
        const TX_UUID      = "beb5483e-36e1-4688-b7f5-ea07361b26a8";

        let scene, camera, renderer, controls, robotModel, leftWheel, rightWheel;
        
        // Stale fizyczne dla wizualizacji 3D
        const IMPULSES_PER_REVOLUTION = 820;
        const WHEEL_DIAMETER_CM = 8.2;
        const TRACK_WIDTH_CM = 13.0;

        let robotState = {
            pitch: 0,
            roll: 0,
            encoderL: 0,
            encoderR: 0,
            lastEncoderL: 0,
            lastEncoderR: 0
        };

        async function connectBLE() {
            try {
                console.log('Proszę o wybranie urzadzenia Bluetooth...');
                document.getElementById('connectionText').textContent = 'Wybierz robota...';
                bleDevice = await navigator.bluetooth.requestDevice({ filters: [{ services: [SERVICE_UUID] }] });
                console.log('Laczenie z serwerem GATT...');
                document.getElementById('connectionText').textContent = 'Laczenie...';
                const server = await bleDevice.gatt.connect();
                console.log('Pobieranie serwisu...');
                const service = await server.getPrimaryService(SERVICE_UUID);
                console.log('Pobieranie charakterystyk...');
                rxCharacteristic = await service.getCharacteristic(RX_UUID); 
                txCharacteristic = await service.getCharacteristic(TX_UUID);
                console.log('Nasluchiwanie na powiadomienia z robota...');
                await txCharacteristic.startNotifications();
                txCharacteristic.addEventListener('characteristicvaluechanged', handleBleNotification);
                bleDevice.addEventListener('gattserverdisconnected', onDisconnected);
                console.log('Polaczono z robotem!');
                document.getElementById('connectionStatus').className = 'status-indicator status-ok';
                document.getElementById('connectionText').textContent = 'Polaczony z ' + bleDevice.name;
                document.getElementById('connectBleBtn').disabled = true;
                sendBleMessage({ type: 'request_state' });
                document.querySelectorAll('#chartControls input:checked').forEach(cb => cb.dispatchEvent(new Event('change')));
            } catch(error) {
                console.error('Blad polaczenia BLE:', error);
                document.getElementById('connectionStatus').className = 'status-indicator status-error';
                document.getElementById('connectionText').textContent = 'Blad polaczenia';
            }
        }

        function onDisconnected() {
            console.log('Rozlaczono z robotem.');
            document.getElementById('connectionStatus').className = 'status-indicator status-disconnected';
            document.getElementById('connectionText').textContent = 'Rozlaczony';
            ['balanceSwitch', 'holdPositionSwitch', 'speedModeSwitch'].forEach(id => {
                const element = document.getElementById(id);
                if (element) element.checked = false;
            });
            document.getElementById('systemStatus').className = 'status-indicator status-disconnected';
            document.getElementById('systemText').textContent = 'Nieznany';
            document.getElementById('connectBleBtn').disabled = false;
            rxCharacteristic = null;
            txCharacteristic = null;
            pendingConfigSegments = {};
        }

        function handleBleNotification(event) {
            const value = event.target.value;
            const decoder = new TextDecoder('utf-8');
            const jsonString = decoder.decode(value);
            handleIncomingData({ data: jsonString });
        }
        
        function handleIncomingData(event) {
            try {
                const data = JSON.parse(event.data);
                switch (data.type) {
                    case '3d_telemetry':
                        if (data.p !== undefined) robotState.pitch = data.p;
                        if (data.r !== undefined) robotState.roll = data.r;
                        if (data.el !== undefined) robotState.encoderL = data.el;
                        if (data.er !== undefined) robotState.encoderR = data.er;
                        break; 
                    case 'telemetry': 
                        updateUI(data); 
                        updateChart(data); 
                        if(data.pitch !== undefined) robotState.pitch = data.pitch;
                        if(data.roll !== undefined) robotState.roll = data.roll;
                        if(data.encoder_left !== undefined) robotState.encoderL = data.encoder_left;
                        if(data.encoder_right !== undefined) robotState.encoderR = data.encoder_right;
                        break;
                    case 'initial_state': handleConfigSegment(data); break;
                    case 'system_config': handleConfigSegment(data); break;
                    case 'pid_config': handleConfigSegment(data); break;
                    case 'motor_config': handleConfigSegment(data); break;
                    case 'log': addLogMessage(data.message, data.level); break;
                    case 'manual_tune_telemetry': updateManualTuneReadout(data); break;
                }
            } catch (e) {
                console.error("Blad parsowania JSON:", e, "Otrzymane dane:", event.data);
            }
        }

        function handleConfigSegment(data) {
            const segment = data.segment;
            if (!segment) {
                applyInitialState(data);
                return;
            }
            
            pendingConfigSegments[segment] = data;
            
            const expectedSegments = ['basic', 'system', 'pid', 'motor'];
            const hasAllSegments = expectedSegments.every(seg => pendingConfigSegments[seg]);
            
            if (hasAllSegments) {
                let combinedConfig = {};
                expectedSegments.forEach(seg => {
                    Object.assign(combinedConfig, pendingConfigSegments[seg]);
                });
                applyInitialState(combinedConfig);
                pendingConfigSegments = {};
                addLogMessage('Odebrano pelna konfiguracje (segmentowana)', 'info');
            }
        }

        async function sendBleMessage(message) {
            if (!rxCharacteristic) { 
                console.warn("Proba wyslania danych bez polaczenia BLE."); 
                return; 
            }
            try {
                const encoder = new TextEncoder();
                await rxCharacteristic.writeValue(encoder.encode(JSON.stringify(message)));
            } catch(error) { 
                console.error('Blad wysylania danych BLE:', error); 
            }
        }

        function updateManualTuneReadout(data) { 
            const encoderL = document.getElementById('manualEncoderL');
            const encoderR = document.getElementById('manualEncoderR');
            if (encoderL) encoderL.textContent = data.encoderL;
            if (encoderR) encoderR.textContent = data.encoderR;
        }

        function applyInitialState(data) {
            const balanceSwitch = document.getElementById('balanceSwitch');
            const holdPositionSwitch = document.getElementById('holdPositionSwitch');
            const speedModeSwitch = document.getElementById('speedModeSwitch');
            
            if (balanceSwitch) balanceSwitch.checked = data.balancingEnabled;
            if (holdPositionSwitch) holdPositionSwitch.checked = data.holdPositionEnabled;
            if (speedModeSwitch) speedModeSwitch.checked = data.speedModeEnabled;
            
            if (data.pwm_max_value) {
                const pwmResolution = document.getElementById('pwmResolutionVal');
                if (pwmResolution) pwmResolution.textContent = `10-bit (${data.pwm_max_value})`;
            }
            
            const params = { 
                expoJoystick: data.expo_joystick, 
                joystickSensitivity: data.joystick_sensitivity,
                maxSpeedJoystick: data.max_speed_joystick,
                minPwmLeftFwd: data.min_pwm_left_fwd, 
                minPwmLeftBwd: data.min_pwm_left_bwd, 
                minPwmRightFwd: data.min_pwm_right_fwd, 
                minPwmRightBwd: data.min_pwm_right_bwd, 
                joystickDeadzone: data.joystick_deadzone, 
                turnFactor: data.turn_factor, 
                kpBalance: data.kp_b, 
                kiBalance: data.ki_b, 
                kdBalance: data.kd_b,
                balancePidDerivativeFilterAlpha: data.filter_alpha,
                kpSpeed: data.kp_s, 
                kiSpeed: data.ki_s, 
                kdSpeed: data.kd_s, 
                kpPosition: data.kp_p, 
                kiPosition: data.ki_p, 
                kdPosition: data.kd_p, 
                kpRotation: data.kp_r, 
                kdRotation: data.kd_r,
                kpHeading: data.kp_h, 
                kiHeading: data.ki_h, 
                kdHeading: data.kd_h, 
                kpRoll: data.kp_roll,
                kiRoll: data.ki_roll,
                kdRoll: data.kd_roll,
                joystickAngleSensitivity: data.joystick_angle_sensitivity, 
                motorBacklash: data.motor_backlash, 
                encoderPPR: data.encoder_ppr, 
                wheelDiameterCm: data.wheel_diameter_cm, 
                trackWidthCm: data.track_width_cm, 
                maxTargetAngleFromSpeedPID: data.max_target_angle,
                maxTargetSpeedFromPosPID: data.max_target_speed, 
                speedPidDeadband: data.speed_pid_deadband, 
                positionPidDeadband: data.position_pid_deadband,
                turnToRollTarget: data.turn_to_roll_target,
                balanceDeadbandAngle: data.balance_deadband_angle
            };
            
            for (const [key, value] of Object.entries(params)) { 
                const input = document.getElementById(`${key}Input`); 
                if(input && value !== undefined) {
                    if (key === 'joystickDeadzone' || key === 'turnFactor' || key === 'expoJoystick' || key === 'joystickSensitivity') {
                        input.value = value / 100.0;
                    } else {
                        input.value = value;
                    }
                }
            }
        }

        function updateUI(data) {
            const robotStateVal = document.getElementById('robotStateVal');
            if (robotStateVal && data.robot_state !== undefined) robotStateVal.textContent = data.robot_state;
            
            if (data.pitch !== undefined) { 
                const displayPitch = data.pitch; 
                const angleVal = document.getElementById('angleVal');
                const angleIndicator = document.getElementById('angleIndicator');
                if (angleVal) angleVal.textContent = displayPitch.toFixed(1) + ' °';
                if (angleIndicator) angleIndicator.style.transform = 'rotate(' + displayPitch + 'deg)';
            }
            
            const rollVal = document.getElementById('rollVal');
            if (rollVal && data.roll !== undefined) rollVal.textContent = data.roll.toFixed(1) + ' °';
            
            const speedVal = document.getElementById('speedVal');
            if (speedVal && data.speed !== undefined) speedVal.textContent = parseFloat(data.speed).toFixed(0);
            
            if (data.target_angle !== undefined) { 
                finalTargetAngleForDisplay = data.target_angle;
                const targetAngleVal = document.getElementById('targetAngleVal');
                if (targetAngleVal) targetAngleVal.textContent = parseFloat(data.target_angle).toFixed(1) + ' °';
            }
            
            const balanceOutputVal = document.getElementById('balanceOutputVal');
            if (balanceOutputVal && data.balance_output !== undefined) balanceOutputVal.textContent = parseFloat(data.balance_output).toFixed(2);
            
            const leftMotorVal = document.getElementById('leftMotorVal');
            if (leftMotorVal && data.left_motor !== undefined) leftMotorVal.textContent = Math.round(data.left_motor);
            
            const rightMotorVal = document.getElementById('rightMotorVal');
            if (rightMotorVal && data.right_motor !== undefined) rightMotorVal.textContent = Math.round(data.right_motor);
            
            const loopTimeVal = document.getElementById('loopTimeVal');
            if (loopTimeVal && data.loop_time !== undefined) loopTimeVal.textContent = data.loop_time + ' μs';
            
            const encoderLeftVal = document.getElementById('encoderLeftVal');
            if (encoderLeftVal && data.encoder_left !== undefined) encoderLeftVal.textContent = data.encoder_left;
            
            const encoderRightVal = document.getElementById('encoderRightVal');
            if (encoderRightVal && data.encoder_right !== undefined) encoderRightVal.textContent = data.encoder_right;
            
            ['balanceSwitch', 'holdPositionSwitch'].forEach(id => { 
                const el = document.getElementById(id); 
                if (el && (!lastUserInteraction[id] || (Date.now() - lastUserInteraction[id] > INTERACTION_TIMEOUT))) { 
                    if (data[id.replace('Switch', 'Enabled')] !== undefined) { 
                        const wasChecked = el.checked, isChecked = data[id.replace('Switch', 'Enabled')]; 
                        el.checked = isChecked; 
                        if (id === 'holdPositionSwitch' && wasChecked && !isChecked) { 
                            addLogMessage("Tryb 'Trzymaj Pozycje' wylaczony (np. przez joystick).", "info"); 
                        } 
                    } 
                } 
            });
            
            const systemStatus = document.getElementById('systemStatus');
            const systemText = document.getElementById('systemText');
            const emergencyBanner = document.getElementById('emergency-banner');
            
            if (data.emergency_stop) { 
                if (systemStatus) systemStatus.className = 'status-indicator status-error'; 
                if (systemText) systemText.textContent = 'STOP AWARYJNY'; 
                if (emergencyBanner) emergencyBanner.style.display = 'block'; 
            } else { 
                if (systemStatus) systemStatus.className = 'status-indicator status-ok'; 
                if (systemText) systemText.textContent = 'OK'; 
                if (emergencyBanner) emergencyBanner.style.display = 'none'; 
            }
        }
        
        function addLogMessage(message, level) { 
            const logHistory = document.getElementById('log-history');
            if (!logHistory) return;
            
            const p = document.createElement('p'); 
            p.textContent = `[${new Date().toLocaleTimeString()}] [${level.toUpperCase()}] ${message}`; 
            if (level === 'error') p.style.color = '#ff6347'; 
            else if (level === 'warn') p.style.color = '#f7b731'; 
            else p.style.color = '#fff'; 
            logHistory.prepend(p); 
            if (logHistory.childElementCount > 100) logHistory.removeChild(logHistory.lastChild); 
        }

        const telemetryChart = new Chart(document.getElementById('telemetryChart'), { 
            type: 'line', 
            data: { labels: Array(100).fill(''), datasets: [] }, 
            options: { 
                animation: false, 
                responsive: true, 
                maintainAspectRatio: false, 
                scales: { 
                    x: { display: false }, 
                    y: { 
                        type: 'linear', 
                        display: true, 
                        position: 'left', 
                        ticks: { color: '#61dafb' }, 
                        title: { display: true, text: 'Wartosc', color: '#61dafb' } 
                    }, 
                    y1: { 
                        type: 'linear', 
                        display: true, 
                        position: 'right', 
                        ticks: { color: '#a2f279' }, 
                        title: { display: true, text: 'Wyjscie PID / PWM', color: '#a2f279' }, 
                        grid: { drawOnChartArea: false }, 
                    } 
                }, 
                plugins: { legend: { labels: { color: '#fff' } } } 
            } 
        });
        
        function updateChart(data) { 
            const chartData = telemetryChart.data; 
            if (chartData.labels.length >= 100) chartData.labels.shift(); 
            chartData.labels.push(''); 
            let localData = {...data}; 
            localData['target_angle'] = finalTargetAngleForDisplay; 
            
            for (const key in localData) { 
                if (availableTelemetry[key]) { 
                    let dataset = chartData.datasets.find(ds => ds.label === availableTelemetry[key].label); 
                    if (!dataset) { 
                        const axisId = (key.includes('output') || key.includes('motor')) ? 'y1' : 'y'; 
                        dataset = { 
                            label: availableTelemetry[key].label, 
                            data: Array(chartData.labels.length).fill(null), 
                            borderColor: availableTelemetry[key].color, 
                            fill: false, 
                            tension: 0.1, 
                            pointRadius: 0, 
                            yAxisID: axisId 
                        }; 
                        chartData.datasets.push(dataset); 
                    } 
                    if (dataset.data.length >= 100) dataset.data.shift(); 
                    dataset.data.push(data[key]); 
                } 
            } 
            
            chartData.datasets.forEach(ds => { 
                if (ds.data.length < chartData.labels.length) { 
                    if (ds.data.length >= 100) ds.data.shift(); 
                    ds.data.push(null); 
                } 
            }); 
            
            telemetryChart.update('none'); 
        }
        
        function setupManualTuningControls() { 
            document.querySelectorAll('.manual-tune-row').forEach(row => { 
                const input = row.querySelector('.tune-input'); 
                if (!input) return;
                const step = 10;
                
                const plusBtn = row.querySelector('.tune-plus');
                const minusBtn = row.querySelector('.tune-minus');
                const testBtn = row.querySelector('.test-btn');
                const stopBtn = row.querySelector('.stop-btn');
                
                if (plusBtn) {
                    plusBtn.addEventListener('click', () => {
                        input.value = Math.min(parseInt(input.value) + step, 1023);
                    }); 
                }
                
                if (minusBtn) {
                    minusBtn.addEventListener('click', () => {
                        input.value = Math.max(parseInt(input.value) - step, 0);
                    });
                }
                
                if (testBtn) {
                    testBtn.addEventListener('click', () => 
                        sendBleMessage({ 
                            type: 'set_direct_motor_control', 
                            motor: row.dataset.motor, 
                            direction: row.dataset.direction, 
                            pwm: parseInt(input.value) 
                        })
                    );
                }
                
                if (stopBtn) {
                    stopBtn.addEventListener('click', () => 
                        sendBleMessage({ 
                            type: 'set_direct_motor_control', 
                            motor: row.dataset.motor, 
                            direction: row.dataset.direction, 
                            pwm: 0 
                        })
                    );
                }
            }); 
            
            const manualTuneStopAll = document.getElementById('manualTuneStopAll');
            if (manualTuneStopAll) {
                manualTuneStopAll.addEventListener('click', () => 
                    sendBleMessage({ type: 'set_direct_motor_control', motor: 'all', pwm: 0 })
                );
            }
        }

        function setupControls() {
            const balanceSwitch = document.getElementById('balanceSwitch');
            if (balanceSwitch) {
                balanceSwitch.addEventListener('change', e => { 
                    lastUserInteraction['balanceSwitch'] = Date.now(); 
                    sendBleMessage({ type: 'balance_toggle', enabled: e.target.checked }); 
                });
            }
            
            const holdPositionSwitch = document.getElementById('holdPositionSwitch');
            if (holdPositionSwitch) {
                holdPositionSwitch.addEventListener('change', e => { 
                    lastUserInteraction['holdPositionSwitch'] = Date.now(); 
                    sendBleMessage({ type: 'hold_position_toggle', enabled: e.target.checked }); 
                });
            }
            
            const speedModeSwitch = document.getElementById('speedModeSwitch');
            if (speedModeSwitch) {
                speedModeSwitch.addEventListener('change', e => { 
                    sendBleMessage({ type: 'speed_mode_toggle', enabled: e.target.checked }); 
                });
            }
            
            const resetZeroBtn = document.getElementById('resetZeroBtn');
            if (resetZeroBtn) resetZeroBtn.addEventListener('click', () => sendBleMessage({ type: 'reset_zero' }));
            
            const trimPlusBtn = document.getElementById('trimPlusBtn');
            if (trimPlusBtn) trimPlusBtn.addEventListener('click', () => sendBleMessage({ type: 'adjust_zero', value: 1 }));
            
            const trimMinusBtn = document.getElementById('trimMinusBtn');
            if (trimMinusBtn) trimMinusBtn.addEventListener('click', () => sendBleMessage({ type: 'adjust_zero', value: -1 }));
            
            const trimRollPlusBtn = document.getElementById('trimRollPlusBtn');
            if (trimRollPlusBtn) trimRollPlusBtn.addEventListener('click', () => sendBleMessage({ type: 'adjust_roll', value: 1 }));
            
            const trimRollMinusBtn = document.getElementById('trimRollMinusBtn');
            if (trimRollMinusBtn) trimRollMinusBtn.addEventListener('click', () => sendBleMessage({ type: 'adjust_roll', value: -1 }));
            
            const saveBtn = document.getElementById('saveBtn');
            if (saveBtn) {
                saveBtn.addEventListener('click', () => { 
                    if(confirm("Czy na pewno chcesz nadpisac ustawienia w pamieci robota?")){ 
                        sendBleMessage({ type: 'save_tunings' }); 
                        addLogMessage('Wyslano polecenie ZAPISU do EEPROM.', 'info'); 
                    }
                });
            }
            
            const loadBtn = document.getElementById('loadBtn');
            if (loadBtn) {
                loadBtn.addEventListener('click', () => { 
                    if(confirm("UWAGA! Spowoduje to nadpisanie wszystkich niezapisanych zmian. Kontynuowac?")){ 
                        sendBleMessage({ type: 'load_from_eeprom' }); 
                        addLogMessage('Wyslano polecenie ODCZYTU z EEPROM.', 'info'); 
                    }
                });
            }
            
            const emergencyStopBtn = document.getElementById('emergencyStopBtn');
            if (emergencyStopBtn) {
                emergencyStopBtn.addEventListener('click', () => sendBleMessage({ type: 'emergency_stop' }));
            }
            
            const resetEncodersBtn = document.getElementById('resetEncodersBtn');
            if (resetEncodersBtn) {
                resetEncodersBtn.addEventListener('click', () => {
                    sendBleMessage({ type: 'reset_encoders' });
                    if (robotModel) {
                        robotModel.position.set(0, 0, 0);
                        robotModel.rotation.set(0, 0, 0);
                        robotState.lastEncoderL = 0;
                        robotState.lastEncoderR = 0;
                    }
                });
            }
            
            const calibrateMpuBtn = document.getElementById('calibrateMpuBtn');
            if (calibrateMpuBtn) {
                calibrateMpuBtn.addEventListener('click', () => sendBleMessage({ type: 'calibrate_mpu' }));
            }
            
            const setupGroupedInput = (ids, msgType) => { 
                ids.forEach(id => { 
                    const input = document.getElementById(id + 'Input');
                    const minusBtn = document.getElementById(id + 'Minus');
                    const plusBtn = document.getElementById(id + 'Plus');
                    
                    if (!input || !minusBtn || !plusBtn) {
                        console.warn(`Nie znaleziono wszystkich elementow dla ${id}`);
                        return;
                    }
                    
                    const step = parseFloat(input.step) || 1;
                    const isFloat = input.step && input.step.includes('.'); 
                    
                    const sendGroupUpdate = () => { 
                        let msg = { type: msgType }; 
                        let payload = {}; 
                        ids.forEach(i => { 
                            const inputElement = document.getElementById(i + 'Input'); 
                            if(inputElement) { 
                                let key;
                                if (i === 'joystickSensitivity') key = 'sensitivity';
                                else if (i === 'expoJoystick') key = 'expo';
                                else if (i === 'maxSpeedJoystick') key = 'maxSpeed';
                                else key = i.replace(/([A-Z])/g, "_$1").toLowerCase();
                                payload[key] = parseFloat(inputElement.value);
                            } 
                        }); 
                        
                        if (payload.joystick_deadzone !== undefined) payload.joystick_deadzone /= 100.0; 
                        if (payload.turn_factor !== undefined) payload.turn_factor /= 100.0; 
                        if (payload.expo !== undefined) payload.expo /= 100.0; 
                        if (payload.sensitivity !== undefined) payload.sensitivity /= 100.0;

                        msg.params = payload; 
                        sendBleMessage(msg); 
                    }; 
                    
                    const updateValue = (amount) => { 
                        let current = parseFloat(input.value);
                        let newValue = current + amount; 
                        if (isFloat) { 
                            const dp = (step.toString().split('.')[1] || '').length; 
                            newValue = parseFloat(newValue.toFixed(dp)); 
                        } 
                        input.value = Math.max(parseFloat(input.min), Math.min(parseFloat(input.max), newValue)); 
                        sendGroupUpdate(); 
                    }; 
                    
                    minusBtn.addEventListener('click', () => updateValue(-step)); 
                    plusBtn.addEventListener('click', () => updateValue(step)); 
                    input.addEventListener('change', sendGroupUpdate); 
                }); 
            };
            
            setupGroupedInput(['minPwmLeftFwd', 'minPwmLeftBwd', 'minPwmRightFwd', 'minPwmRightBwd'], 'set_min_pwm_group');
            setupGroupedInput(['joystickDeadzone', 'turnFactor', 'expoJoystick', 'maxSpeedJoystick', 'joystickSensitivity'], 'set_joystick_tuning');
            setupGroupedInput(['kpBalance', 'kiBalance', 'kdBalance', 'joystickAngleSensitivity', 'balancePidDerivativeFilterAlpha'], 'balance_pid_update');
            setupGroupedInput(['kpSpeed', 'kiSpeed', 'kdSpeed', 'maxTargetAngleFromSpeedPID', 'speedPidDeadband'], 'speed_pid_update');
            setupGroupedInput(['kpPosition', 'kiPosition', 'kdPosition', 'maxTargetSpeedFromPosPID', 'positionPidDeadband'], 'position_pid_update');
            setupGroupedInput(['kpRotation', 'kdRotation'], 'rotation_pid_update');
            setupGroupedInput(['kpHeading', 'kiHeading', 'kdHeading'], 'heading_pid_update');
            setupGroupedInput(['kpRoll', 'kiRoll', 'kdRoll'], 'roll_pid_update');
            setupGroupedInput(['encoderPPR', 'wheelDiameterCm', 'trackWidthCm', 'motorBacklash', 'turnToRollTarget', 'balanceDeadbandAngle'], 'calibration_update');
            
            setupManualTuningControls();
            setupDpadControls();
        }

        function setupDpadControls() {
            const dpadUp = document.getElementById('dpad-up');
            if (dpadUp) {
                dpadUp.addEventListener('click', () => {
                    const distInput = document.getElementById('dpadDistInput');
                    const distance = distInput ? parseFloat(distInput.value) : 20;
                    sendBleMessage({ type: 'execute_move', distance_cm: distance });
                });
            }
            
            const dpadDown = document.getElementById('dpad-down');
            if (dpadDown) {
                dpadDown.addEventListener('click', () => {
                    const distInput = document.getElementById('dpadDistInput');
                    const distance = distInput ? parseFloat(distInput.value) : 20;
                    sendBleMessage({ type: 'execute_move', distance_cm: -distance });
                });
            }
            
            const dpadLeft = document.getElementById('dpad-left');
            if (dpadLeft) {
                dpadLeft.addEventListener('click', () => {
                    const angleInput = document.getElementById('dpadAngleInput');
                    const angle = angleInput ? parseFloat(angleInput.value) : 10;
                    sendBleMessage({ type: 'execute_rotate', angle_deg: -angle });
                });
            }
            
            const dpadRight = document.getElementById('dpad-right');
            if (dpadRight) {
                dpadRight.addEventListener('click', () => {
                    const angleInput = document.getElementById('dpadAngleInput');
                    const angle = angleInput ? parseFloat(angleInput.value) : 10;
                    sendBleMessage({ type: 'execute_rotate', angle_deg: angle });
                });
            }
            
            const dpadStop = document.getElementById('dpad-stop');
            if (dpadStop) {
                dpadStop.addEventListener('click', () => sendBleMessage({ type: 'command_stop' }));
            }
        }
        
        function saveProfile() { 
            const nameInput = document.getElementById('profileNameInput');
            const name = nameInput ? nameInput.value : '';
            if (!name) { 
                alert('Wpisz nazwe profilu!'); 
                return; 
            } 
            const profileData = {}; 
            document.querySelectorAll('#allSettings input[type=number], #controls-card input[type=number]').forEach(input => { 
                profileData[input.id] = input.value; 
            }); 
            document.querySelectorAll('#allSettings input[type=checkbox], #controls-card input[type=checkbox]').forEach(input => { 
                profileData[input.id] = input.checked; 
            }); 
            localStorage.setItem(PROFILE_PREFIX + name, JSON.stringify(profileData)); 
            addLogMessage(`Zapisano profil: ${name}`, 'info'); 
            loadProfiles(); 
        }
        
        function loadProfiles() { 
            const select = document.getElementById('profileSelect');
            if (!select) return;
            
            select.innerHTML = '<option value="">Wybierz profil...</option>'; 
            for (let i = 0; i < localStorage.length; i++) { 
                const key = localStorage.key(i); 
                if (key && key.startsWith(PROFILE_PREFIX)) { 
                    const option = document.createElement('option'); 
                    option.value = key; 
                    option.textContent = key.replace(PROFILE_PREFIX, ''); 
                    select.appendChild(option); 
                } 
            } 
        }
        
        function applyProfileToPanel() { 
            const select = document.getElementById('profileSelect');
            const key = select ? select.value : '';
            if (!key) return; 
            
            try {
                const profileData = JSON.parse(localStorage.getItem(key) || '{}'); 
                for (const id in profileData) { 
                    const input = document.getElementById(id); 
                    if (input) { 
                        if (input.type === 'checkbox') {
                            input.checked = profileData[id];
                        } else {
                            input.value = profileData[id];
                        }
                    } 
                }
                addLogMessage(`Zaladowano profil: ${key.replace(PROFILE_PREFIX, '')} do panelu.`, 'info');
            } catch (error) {
                console.error('Blad ladowania profilu:', error);
                addLogMessage('Blad ladowania profilu', 'error');
            }
        }
        
        function sendProfileToRobot() { 
            applyProfileToPanel(); 
            setTimeout(() => { 
                document.querySelectorAll('#allSettings input[type=number], #controls-card input').forEach(input => { 
                    if (input.dispatchEvent) {
                        input.dispatchEvent(new Event('change', { bubbles: true })); 
                    }
                }); 
                addLogMessage('Wyslano wartosci z profilu do robota.', 'info'); 
            }, 200); 
        }
        
        function setupChartControls() { 
            const container = document.getElementById('chartControls');
            if (!container) return;
            
            container.innerHTML = ''; 
            Object.keys(availableTelemetry).forEach((key) => { 
                const label = document.createElement('label');
                const checkbox = document.createElement('input'); 
                checkbox.type = 'checkbox'; 
                checkbox.value = key; 
                checkbox.checked = (key === 'pitch' || key === 'target_angle' || key === 'speed'); 
                checkbox.addEventListener('change', (e) => { 
                    const varName = e.target.value; 
                    if (e.target.checked) { 
                        sendBleMessage({ type: 'subscribe_variable', name: varName }); 
                    } else { 
                        sendBleMessage({ type: 'unsubscribe_variable', name: varName }); 
                        const chartData = telemetryChart.data;
                        const datasetIndex = chartData.datasets.findIndex(ds => ds.label === availableTelemetry[varName].label); 
                        if (datasetIndex > -1) { 
                            chartData.datasets.splice(datasetIndex, 1); 
                            telemetryChart.update(); 
                        } 
                    } 
                }); 
                label.appendChild(checkbox); 
                label.append(` ${availableTelemetry[key].label}`); 
                container.appendChild(label); 
            }); 
        }
        
        function handleJoystickMove(e) { 
            if (!isDragging) return; 
            e.preventDefault(); 
            const rect = joystickCanvas.getBoundingClientRect(); 
            
            const clientX = e.clientX || (e.touches && e.touches ? e.touches.clientX : 0);
            const clientY = e.clientY || (e.touches && e.touches ? e.touches.clientY : 0);
            
            const x = clientX - rect.left - joystickCenter.x;
            const y = clientY - rect.top - joystickCenter.y; 
            const distance = Math.sqrt(x * x + y * y); 
            
            let finalX, finalY;

            if (distance > joystickRadius) { 
                const angle = Math.atan2(y, x); 
                finalX = joystickRadius * Math.cos(angle); 
                finalY = joystickRadius * Math.sin(angle); 
            } else { 
                finalX = x; 
                finalY = y; 
            } 
            drawJoystick(finalX, finalY); 
            sendBleMessage({ type: 'joystick', x: finalX / joystickRadius, y: -finalY / joystickRadius });
        }
        
        function startJoystickDrag(e){
            isDragging = true;
            handleJoystickMove(e);
        }

        function endJoystickDrag(e){
            if (!isDragging) return;
            isDragging = false;
            drawJoystick(0, 0); 
            sendBleMessage({ type: 'joystick', x: 0, y: 0 });
        }
        
        function pollGamepad() { 
            const gamepads = navigator.getGamepads(); 
            if (!gamepads[gamepadIndex]) return; 
            const gp = gamepads[gamepadIndex]; 
            const deadzone = 0.15; 
            
            let joyX = gp.axes || 0;
            let joyY = gp.axes[1] || 0;
            
            const magnitude = Math.sqrt(joyX*joyX + joyY*joyY); 
            if (magnitude < deadzone) { joyX = 0; joyY = 0; } 

            if (joyX !== lastGamepadState.x || joyY !== lastGamepadState.y) { 
                sendBleMessage({ type: 'joystick', x: joyX, y: -joyY }); 
                lastGamepadState.x = joyX; 
                lastGamepadState.y = joyY; 
            }

            gp.buttons.forEach((button, i) => {
                if (button.pressed && !lastGamepadState.buttons[i]) {
                    handleGamepadButtonPress(i);
                }
                lastGamepadState.buttons[i] = button.pressed;
            });

            requestAnimationFrame(pollGamepad); 
        }
        
        function handleGamepadButtonPress(index) {
            console.log("Gamepad button pressed: ", index);
            const buttonMap = {
                0: 'balanceSwitch',
                1: 'emergencyStopBtn', 
                2: 'holdPositionSwitch',
                3: 'speedModeSwitch',
                8: 'resetEncodersBtn',
                9: 'resetZeroBtn'
            };
            
            const element = document.getElementById(buttonMap[index]);
            if (element) element.click();
        }

        function setupGamepadControls() { 
            const statusEl = document.getElementById('gamepadStatus');
            if (!statusEl) return;
            
            window.addEventListener("gamepadconnected", (event) => { 
                gamepadIndex = event.gamepad.index; 
                statusEl.textContent = 'Polaczony'; 
                statusEl.style.color = '#a2f279'; 
                addLogMessage(`Kontroler polaczony: ${event.gamepad.id}`, 'info');
                lastGamepadState.buttons = Array(event.gamepad.buttons.length).fill(false);
                pollGamepad(); 
            }); 
            window.addEventListener("gamepaddisconnected", (event) => { 
                statusEl.textContent = 'Brak'; 
                statusEl.style.color = '#f7b731'; 
                addLogMessage('Kontroler odlaczony.', 'warn'); 
                if (gamepadPollInterval) {
                    cancelAnimationFrame(gamepadPollInterval); 
                }
            }); 
        }
        
        function setupStateSync() { 
            document.addEventListener('visibilitychange', () => { 
                if (document.visibilityState === 'visible') { 
                    if (bleDevice && bleDevice.gatt && bleDevice.gatt.connected) { 
                        sendBleMessage({ type: 'request_state' }); 
                    } 
                } 
            }); 
        }
        
        function setupDiagnosticControls() { 
            const startBtn = document.getElementById('startDiagnosticBtn');
            const stopBtn = document.getElementById('stopDiagnosticBtn');
            
            if (startBtn) {
                startBtn.addEventListener('click', () => { 
                    sendBleMessage({ type: 'start_diagnostic' }); 
                    startBtn.style.display = 'none'; 
                    if (stopBtn) stopBtn.style.display = 'inline-block'; 
                    addLogMessage('Rozpoczeto analizator stanu pinow.', 'info'); 
                });
            }
            
            if (stopBtn) {
                stopBtn.addEventListener('click', () => { 
                    sendBleMessage({ type: 'stop_diagnostic' }); 
                    stopBtn.style.display = 'none'; 
                    if (startBtn) startBtn.style.display = 'inline-block'; 
                    addLogMessage('Zakonczono analizator.', 'info'); 
                });
            }
        }
        
        function setup3DVisualization() {
            const container = document.getElementById('canvas-3d-container');
            if (!container) {
                console.error('Nie znaleziono kontenera 3D');
                return;
            }

            try {
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x20232a);

                camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
                camera.position.set(0, 8, 25); 

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(container.clientWidth, container.clientHeight);
                container.innerHTML = '';
                container.appendChild(renderer.domElement);

                if (typeof THREE.OrbitControls !== 'undefined') {
                    controls = new THREE.OrbitControls(camera, renderer.domElement);
                    controls.enablePan = false;
                    controls.target.set(0, 2, 0); 
                    controls.update();
                } else {
                    console.warn('OrbitControls nie zostaly zaladowane - wizualizacja 3D bedzie statyczna');
                    addLogMessage('Blad ladowania kontrolek 3D - widok statyczny', 'warn');
                }

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
                directionalLight.position.set(10, 20, 15);
                scene.add(directionalLight);
                
                const floorGeometry = new THREE.PlaneGeometry(200, 200);
                const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x4a4f58, roughness: 0.8 }); 
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.position.y = -2.3; 
                scene.add(floor);

                const loader = new THREE.TextureLoader();
                loader.load(
                    'https://i.imgur.com/gA3t1d3.jpg',
                    function (texture) {
                        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                        texture.repeat.set(10, 10);
                        floor.material.map = texture;
                        floor.material.needsUpdate = true;
                    },
                    undefined,
                    function (err) {
                        console.warn('Nie udalo sie zaladowac tekstury podlogi - uzywam domyslnego koloru');
                    }
                );

                robotModel = new THREE.Group();
                
                const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x1A1A1A, roughness: 0.6 });
                const body = new THREE.Mesh(new THREE.BoxGeometry(7, 3, 5), bodyMaterial);
                body.position.y = 0;
                robotModel.add(body);

                const mast = new THREE.Mesh(new THREE.BoxGeometry(1.5, 7, 1.5), bodyMaterial);
                mast.position.y = 5;
                robotModel.add(mast);

                const batteryMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFF00, roughness: 0.8 });
                const battery = new THREE.Mesh(new THREE.BoxGeometry(4, 2, 1), batteryMaterial);
                battery.position.set(0, 9.5, -0.5);
                robotModel.add(battery);

                const strapMaterial = new THREE.MeshStandardMaterial({ color: 0x101010 });
                const strap = new THREE.Mesh(new THREE.BoxGeometry(1.7, 2.2, 1.7), strapMaterial);
                strap.position.set(0, 9.5, 0);
                robotModel.add(strap);
                
                const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0xF0F0F0, roughness: 0.5 });
                const tireMaterial = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 });
                
                function createWheel() {
                    const wheel = new THREE.Group();
                    const tire = new THREE.Mesh(new THREE.CylinderGeometry(4.1, 4.1, 2, 32), tireMaterial);
                    wheel.add(tire);
                    const rim = new THREE.Mesh(new THREE.CylinderGeometry(3.5, 3.5, 2.2, 32), wheelMaterial);
                    wheel.add(rim);

                    const spokeGeometry = new THREE.BoxGeometry(3.5, 0.4, 0.4);
                    for (let i = 0; i < 7; i++) {
                        const spoke = new THREE.Mesh(spokeGeometry, wheelMaterial);
                        const angle = (i / 7) * Math.PI * 2;
                        spoke.rotation.z = angle;
                        wheel.add(spoke);
                    }
                    return wheel;
                }

                leftWheel = createWheel();
                leftWheel.position.x = -6.5; 
                robotModel.add(leftWheel);

                rightWheel = createWheel();
                rightWheel.position.x = 6.5; 
                robotModel.add(rightWheel);
                
                [leftWheel, rightWheel].forEach(w => w.rotation.z = Math.PI / 2);

                scene.add(robotModel);

                function animate() {
                    requestAnimationFrame(animate);

                    const degToRad = Math.PI / 180;
                    const wheelCircumferenceM = (Math.PI * WHEEL_DIAMETER_CM) / 100.0;
                    const trackWidthM = TRACK_WIDTH_CM / 100.0;
                    
                    const deltaL = robotState.encoderL - robotState.lastEncoderL;
                    const deltaR = robotState.encoderR - robotState.lastEncoderR;
                    robotState.lastEncoderL = robotState.encoderL;
                    robotState.lastEncoderR = robotState.encoderR;

                    const deltaRevolutionsL = deltaL / IMPULSES_PER_REVOLUTION;
                    const deltaRevolutionsR = deltaR / IMPULSES_PER_REVOLUTION;

                    leftWheel.rotation.x -= deltaRevolutionsL * 2 * Math.PI;
                    rightWheel.rotation.x -= deltaRevolutionsR * 2 * Math.PI;

                    const deltaDistanceL = deltaRevolutionsL * wheelCircumferenceM;
                    const deltaDistanceR = deltaRevolutionsR * wheelCircumferenceM;

                    const deltaDistanceCenter = (deltaDistanceL + deltaDistanceR) / 2.0;
                    const deltaRotationAngleRad = (deltaDistanceR - deltaDistanceL) / trackWidthM;
                    
                    robotModel.position.x += Math.sin(robotModel.rotation.y) * deltaDistanceCenter * 100;
                    robotModel.position.z += Math.cos(robotModel.rotation.y) * deltaDistanceCenter * 100;
                    
                    robotModel.rotation.order = 'YXZ';
                    robotModel.rotation.y -= deltaRotationAngleRad;
                    robotModel.rotation.x = robotState.pitch * degToRad;
                    robotModel.rotation.z = robotState.roll * degToRad;

                    if (controls) controls.update();
                    renderer.render(scene, camera);
                }
                animate();

                window.addEventListener('resize', () => {
                    if (!container || !renderer || !camera) return;
                    camera.aspect = container.clientWidth / container.clientHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(container.clientWidth, container.clientHeight);
                }, false);
                
                addLogMessage('Wizualizacja 3D zostala pomyslnie zainicjalizowana', 'info');
                
            } catch (error) {
                console.error('Blad inicjalizacji 3D:', error);
                addLogMessage('Blad inicjalizacji wizualizacji 3D', 'error');
                const container = document.getElementById('canvas-3d-container');
                if (container) {
                    container.innerHTML = '<div style="color: #ff6347; text-align: center; padding: 50px;">Blad ladowania wizualizacji 3D</div>';
                }
            }
        }
        
        // Inicjalizacja wszystkich komponentow
        const connectBleBtn = document.getElementById('connectBleBtn');
        if (connectBleBtn) connectBleBtn.addEventListener('click', connectBLE);
        
        resizeJoystick();
        setupChartControls();
        setupControls();
        loadProfiles();
        setupStateSync();
        setupDiagnosticControls();
        setupGamepadControls();
        setup3DVisualization();

        if (joystickCanvas) {
            joystickCanvas.addEventListener('mousedown', startJoystickDrag);
            joystickCanvas.addEventListener('touchstart', startJoystickDrag, { passive: false });
        }
        
        document.addEventListener('mousemove', handleJoystickMove);
        document.addEventListener('touchmove', handleJoystickMove, { passive: false });
        document.addEventListener('mouseup', endJoystickDrag);
        document.addEventListener('touchend', endJoystickDrag);

        const saveProfileBtn = document.getElementById('saveProfileBtn');
        if (saveProfileBtn) saveProfileBtn.addEventListener('click', saveProfile);
        
        const applyProfileBtn = document.getElementById('applyProfileBtn');
        if (applyProfileBtn) applyProfileBtn.addEventListener('click', sendProfileToRobot);
        
        const profileSelect = document.getElementById('profileSelect');
        if (profileSelect) profileSelect.addEventListener('change', applyProfileToPanel);
        
        // POPRAWIONA obsluga akordeonow z dodanym sprawdzaniem bledow
        document.querySelectorAll('.accordion-header').forEach(header => {
            header.addEventListener('click', event => {
                event.preventDefault();
                const content = header.nextElementSibling;
                
                if (!content || !content.classList.contains('accordion-content')) {
                    console.error('Nie znaleziono odpowiedniego elementu accordion-content dla:', header.textContent);
                    return;
                }
                
                const isActive = header.classList.toggle('active');
                
                if (isActive) {
                    // Rozwin akordeon
                    content.classList.add('active');
                    content.style.maxHeight = (content.scrollHeight + 30) + "px";
                } else {
                    // Zwin akordeon
                    content.classList.remove('active');
                    content.style.maxHeight = "0px";
                }
                
                console.log('Akordeon:', header.textContent, isActive ? 'rozwiniety' : 'zwiniety');
            });
        });

        addLogMessage('Aplikacja zostala pomyslnie zainicjalizowana', 'info');
    });
    
    // Globalna funkcja resize dostepna dla window.onresize
    window.onresize = () => { 
        resizeJoystick(); 
    };
</script>
</body>
</html>