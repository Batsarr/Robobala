<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Robot LQR - Panel Sterowania v32.9</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; margin: 0; padding: 15px; background-color: #282c34; color: #fff; font-size: 14px; }
        h1 { color: #61dafb; font-size: 1.8em; }
        h2 { color: #61dafb; font-size: 1.4em; margin-top: 0; margin-bottom: 15px; }
        .main-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(340px, 1fr)); gap: 15px; align-items: start; max-width: 1920px; margin: auto; }
        .card { background-color: #3a3f47; border-radius: 8px; padding: 15px; box-shadow: 0 2px 6px rgba(0,0,0,0.2); }
        .info-grid, .status-grid { display: grid; grid-template-columns: auto 1fr; gap: 8px; text-align: left; font-size: 1em; margin-top: 10px; align-items: center;}
        .info-grid strong, .status-grid strong { color: #a2f279; }
        button { background-color: #61dafb; color: #282c34; border: none; padding: 8px 12px; border-radius: 5px; font-weight: bold; cursor: pointer; transition: background-color 0.3s, opacity 0.3s, box-shadow 0.2s; font-size: 0.9em; }
        button:hover { background-color: #a2f279; }
        button:disabled { background-color: #4a4f58; color: #888; cursor: not-allowed; opacity: 0.6; }
        .gamepad-flash { box-shadow: 0 0 10px 3px #a2f279 !important; }
        #emergencyStopBtn { background-color: #ff6347; color: white; width: 100%; margin-top: 15px; }
        .control-row { display: flex; align-items: center; justify-content: space-between; width: 100%; margin-top: 10px; }
        .control-label { font-size: 1.1em; font-weight: bold; }
        .switch { position: relative; display: inline-block; width: 50px; height: 28px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider.round { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ff6347; transition: .4s; border-radius: 28px; }
        .slider.round:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #a2f279; }
        input:checked + .slider:before { transform: translateX(22px); }
        input:disabled + .slider { background-color: #4a4f58; cursor: not-allowed; }
        fieldset { border: 1px solid #4a4f58; border-radius: 8px; margin-top: 15px; padding: 10px 15px; }
        legend { color: #61dafb; font-weight: bold; padding: 0 10px; font-size: 1.1em; }
        #joystickWrapper { position: relative; width: 180px; height: 180px; border-radius: 50%; background-color: #4a4f58; border: 3px solid #61dafb; margin: 15px auto; }
        #joystickCanvas { width: 100%; height: 100%; display: block; }
        #chart-wrapper { position: relative; height: 320px; border-radius: 8px; overflow: hidden; background-color: #20232a; }
        #log-history { text-align: left; height: 350px; overflow-y: auto; background-color: #20232a; padding: 10px; border-radius: 8px; font-family: monospace; white-space: pre-wrap; }
        .status-indicator { width: 14px; height: 14px; border-radius: 50%; display: inline-block; }
        .status-ok { background-color: #a2f279; }
        .status-warn { background-color: #f7b731; }
        .status-error { background-color: #ff6347; }
        .status-disconnected { background-color: #888; }
        #emergency-banner { display: none; background-color: #ff6347; color: white; padding: 10px; font-weight: bold; position: fixed; top: 0; left: 0; width: 100%; z-index: 1000; }
        .angle-display { display: flex; align-items: center; justify-content: space-between; }
        .angle-indicator-wrapper { position: relative; width: 34px; height: 34px; background-color: #20232a; border-radius: 50%; border: 1px solid #61dafb; }
        .angle-indicator-needle { position: absolute; bottom: 50%; left: calc(50% - 1px); width: 2px; height: 50%; background-color: #ff6347; transform-origin: bottom center; transition: transform 0.1s linear; }
        .chart-controls { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin-top: 10px; font-size: 0.9em; }
        .chart-controls label { color: #fff; }
        .setting-container { display: grid; grid-template-columns: 1fr auto; gap: 10px; align-items: center; margin: 8px 0; }
        .setting-container label { font-size: 1em; font-weight: bold; color: #a2f279; text-align: left; }
        .numeric-input-wrapper { display: flex; align-items: center; flex-shrink: 0; }
        .numeric-input-wrapper button { background-color: #4a4f58; color: #61dafb; padding: 4px 8px; font-size: 1em; line-height: 1; min-width: 30px; }
        .numeric-input-wrapper input[type=number] { width: 90px; text-align: center; font-size: 1em; background-color: #20232a; color: #fff; border: 1px solid #61dafb; border-radius: 5px; margin: 0 4px; padding: 4px; -moz-appearance: textfield; }
        input[type=number]::-webkit-inner-spin-button, input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        .manual-tune-row { display: grid; grid-template-columns: 1fr auto auto; gap: 10px; align-items: center; margin-bottom: 8px; }
        .manual-tune-row label { text-align: left; font-weight: bold; color: #a2f279; }
        .manual-tune-row .test-btn { background-color: #a2f279; }
        .manual-tune-row .stop-btn { background-color: #ff6347; }
        .manual-tune-readout { margin-top: 15px; font-size: 1.2em; font-weight: bold; display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .trim-controls { display: flex; justify-content: space-between; align-items: center; margin-top: 10px; }
        .trim-controls span { font-weight: bold; }
        .trim-controls button { min-width: 40px; font-size: 1.2em; }
        .dpad-container { display: grid; grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 1fr 1fr; gap: 5px; max-width: 150px; margin: 15px auto; }
        .dpad-btn { background-color: #61dafb; color: #282c34; border-radius: 5px; font-size: 2em; line-height: 1; padding: 5px; cursor: pointer; border: none; }
        .dpad-btn:hover { background-color: #a2f279; }
        #dpad-up { grid-column: 2; grid-row: 1; }
        #dpad-left { grid-column: 1; grid-row: 2; }
        #dpad-right { grid-column: 3; grid-row: 2; }
        #dpad-down { grid-column: 2; grid-row: 3; }
        #dpad-stop { grid-column: 2; grid-row: 2; background-color: #ff6347; color: white; }
        .dpad-input-group { display: grid; grid-template-columns: 1fr auto; gap: 10px; align-items: center; margin: 10px 0; }
        .dpad-input-group label { text-align: right; font-weight: bold; color: #a2f279; }
        .dpad-input-group input { width: 100%; box-sizing: border-box; }
        .accordion-header { background-color: #4a4f58; color: #61dafb; cursor: pointer; padding: 12px 15px; border: none; text-align: left; outline: none; font-size: 1.1em; font-weight: bold; width: 100%; border-radius: 8px; margin-top: 5px; transition: background-color 0.3s; position: relative; }
        .accordion-header:hover { background-color: #5a6068; }
        .accordion-header.active { background-color: #61dafb; color: #282c34; border-bottom-left-radius: 0; border-bottom-right-radius: 0;}
        .accordion-header::after { content: '+'; position: absolute; right: 15px; font-size: 1.4em; transition: transform 0.3s; }
        .accordion-header.active::after { content: '-'; }
        .accordion-content { max-height: 0; overflow: hidden; transition: max-height 0.4s ease-out; background-color: #3a3f47; border-bottom-left-radius: 8px; border-bottom-right-radius: 8px;}
        .accordion-content.active { padding: 15px; }
        .pwm-info { background-color: #20232a; padding: 10px; border-radius: 5px; margin-bottom: 15px; border-left: 4px solid #61dafb; }
        .pwm-info strong { color: #a2f279; }
        .physics-section { background-color: #2a2f35; padding: 15px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid #a2f279; }
        .physics-section h4 { color: #a2f279; margin-top: 0; margin-bottom: 10px; }
        .parameter-group { background-color: #20232a; padding: 12px; border-radius: 6px; margin-bottom: 12px; }
        .parameter-group h5 { color: #61dafb; margin: 0 0 8px 0; font-size: 1.1em; }
        .help-icon { display: inline-block; width: 16px; height: 16px; border-radius: 50%; background-color: #61dafb; color: #282c34; font-size: 12px; font-weight: bold; text-align: center; line-height: 16px; margin-left: 8px; cursor: pointer; user-select: none; }
        .help-text { background-color: #20232a; color: #fff; border-radius: 6px; padding: 10px; border: 1px solid #61dafb; margin-top: 8px; text-align: left; font-size: 0.9em; line-height: 1.4; width: 100%; box-sizing: border-box; max-height: 0; overflow: hidden; transition: max-height 0.3s ease-out, padding 0.3s ease-out; padding-top: 0; padding-bottom: 0; grid-column: 1 / -1; }
        .help-text.visible { max-height: 200px; padding-top: 10px; padding-bottom: 10px; }
        .sequence-step { display: grid; grid-template-columns: 1fr 100px auto; gap: 10px; align-items: center; background-color: #2a2f35; padding: 8px; border-radius: 6px; margin-bottom: 8px; transition: background-color 0.3s; }
        .sequence-step.executing { background-color: #a2f279; color: #282c34; }
        .sequence-step.executing select, .sequence-step.executing input { color: #282c34; border-color: #282c34; }
        .sequence-step select, .sequence-step input { width: 100%; background-color: #20232a; color: #fff; border: 1px solid #61dafb; border-radius: 4px; padding: 5px; }
        .sequence-step .remove-step-btn { background-color: #ff6347; padding: 5px 10px; }
        .modal-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); z-index: 2000; display: none; justify-content: center; align-items: center; }
        .modal-content { background-color: #3a3f47; padding: 20px; border-radius: 8px; width: 90%; max-width: 500px; box-shadow: 0 5px 15px rgba(0,0,0,0.5); }
        .mapping-row { display: grid; grid-template-columns: 1fr 100px 100px; gap: 10px; align-items: center; margin-bottom: 10px; }
        .mapping-label { text-align: left; font-weight: bold; }
        .mapping-button { font-size: 0.8em; padding: 6px 8px; }
        .mapping-display { background-color: #20232a; padding: 6px; border-radius: 4px; font-family: monospace; }
        .preset-actions { display: grid; grid-template-columns: 1fr; gap: 10px; margin-top: 10px; }
        #applySelectedPresetBtn { background-color: #a2f279; }
        #sendCurrentSettingsBtn { background-color: #f7b731; }
        #saveCurrentAsPresetBtn { background-color: #61dafb; }
    </style>
</head>
<body>
    <div id="emergency-banner">ZATRZYMANIE AWARYJNE</div>

    <div id="gamepad-mapping-modal" class="modal-backdrop">
        <div class="modal-content">
            <h2>Mapowanie Przyciskow Gamepada</h2>
            <div id="gamepad-mapping-list"></div>
            <button id="close-modal-btn" style="margin-top: 20px;">Zamknij</button>
        </div>
    </div>

    <h1>Robot LQR - Panel Sterowania</h1>
    <div class="main-grid">
        <div class="card" id="controls-card">
            <h2>Sterowanie</h2>
            <div id="joystickWrapper"><canvas id="joystickCanvas"></canvas></div>
            <div class="control-row"><span class="control-label">Balansowanie</span><label class="switch"><input type="checkbox" id="balanceSwitch"><span class="slider round"></span></label></div>
            <div class="control-row"><span class="control-label">Trzymaj Pozycje</span><label class="switch"><input type="checkbox" id="holdPositionSwitch"><span class="slider round"></span></label></div>
            <div class="control-row"><span class="control-label">Tryb Predkosci</span><label class="switch"><input type="checkbox" id="speedModeSwitch"><span class="slider round"></span></label></div>
            <div class="control-row"><span class="control-label">LQR Aktywny</span><label class="switch"><input type="checkbox" id="lqrEnabledSwitch" checked><span class="slider round"></span></label></div>
            
            <fieldset style="padding: 10px 10px 5px 10px;"><legend>Strojenie Glowne</legend>
                <div class="setting-container"><label for="joystickOutputScaleInput">Skala Wyjscia (%)</label><div class="numeric-input-wrapper"><button id="joystickOutputScaleMinus">-</button><input type="number" class="config-value" id="joystickOutputScaleInput" min="10" max="100" step="5" value="100"><button id="joystickOutputScalePlus">+</button></div></div>
                <div class="setting-container"><label for="expoJoystickInput">Expo Joysticka (%)</label><div class="numeric-input-wrapper"><button id="expoJoystickMinus">-</button><input type="number" class="config-value" id="expoJoystickInput" min="0" max="90" step="1" value="0"><button id="expoJoystickPlus">+</button></div></div>
                <div class="setting-container"><label for="maxSpeedJoystickInput">Max. predkosc (imp/s)</label><div class="numeric-input-wrapper"><button id="maxSpeedJoystickMinus">-</button><input type="number" class="config-value" id="maxSpeedJoystickInput" min="200" max="4000" step="100" value="800"><button id="maxSpeedJoystickPlus">+</button></div></div>
                <div class="setting-container"><label for="joystickAngleSensitivityInput">Czulosc Kata (st.)</label><div class="numeric-input-wrapper"><button id="joystickAngleSensitivityMinus">-</button><input type="number" class="config-value" id="joystickAngleSensitivityInput" min="1" max="30" step="0.5" value="10"><button id="joystickAngleSensitivityPlus">+</button></div></div>
                <div class="setting-container"><label for="turnFactorInput">Czulosc Skretu (%)</label><div class="numeric-input-wrapper"><button id="turnFactorMinus">-</button><input type="number" class="config-value" id="turnFactorInput" min="0" max="100" step="5" value="25"><button id="turnFactorPlus">+</button></div></div>
                
                <hr style="border-color: #4a4f58; margin: 10px 0;">
                <h5 style="color: #61dafb; margin: 0 0 8px 0; font-size: 1.1em; text-align: left;">Korekty Ruchu</h5>
                <div class="setting-container"><label for="headingCorrectionFactorInput">Sila Korekty Kursu</label><div class="numeric-input-wrapper"><button id="headingCorrectionFactorMinus">-</button><input type="number" class="config-value" id="headingCorrectionFactorInput" min="0" max="5" step="0.05" value="0.4"><button id="headingCorrectionFactorPlus">+</button></div></div>
                
                <div class="setting-container">
                    <label for="speedToAngleFactorInput">Wsp. Predkosci na Kat<span class="help-icon">?</span></label>
                    <div class="numeric-input-wrapper">
                        <button id="speedToAngleFactorMinus">-</button>
                        <input type="number" class="config-value" id="speedToAngleFactorInput" min="0.001" max="0.1" step="0.001" value="0.01">
                        <button id="speedToAngleFactorPlus">+</button>
                    </div>
                    <div class="help-text"><strong>Wplyw:</strong> Kluczowy parametr dla trybu predkosci. Okresla, jak bardzo robot ma sie pochylac, aby osiagnac zadana predkosc. Wieksza wartosc = wieksza agresywnosc i szybsze przyspieszanie.</div>
                </div>

            </fieldset>
            
            <hr style="border-color: #4a4f58; margin: 15px 0;">
            <button id="open-gamepad-modal-btn" style="width: 100%; background-color:#f7b731;">Mapowanie Przyciskow Gamepada</button>
            <button id="resetZeroBtn" style="margin-top:10px;">Resetuj Osie</button>
            <div class="trim-controls">
                <button id="trimMinusBtn">-</button>
                <span>Korekta Pionu (Pitch)</span>
                <button id="trimPlusBtn">+</button>
            </div>
            <div class="trim-controls">
                <button id="trimRollMinusBtn">-</button>
                <span>Korekta Przechylu (Roll)</span>
                <button id="trimRollPlusBtn">+</button>
            </div>
            <button id="resetEncodersBtn" style="margin-top:10px; background-color:#f7b731;">Resetuj Enkodery</button>
            <button id="emergencyStopBtn">STOP AWARYJNY</button>
        </div>
        
        <div class="card">
            <h2>Status Robota</h2>
            <button id="connectBleBtn" style="width: 100%; margin-bottom: 15px;">POLACZ Z ROBOTEM</button>
            <div class="status-grid">
                <strong>Polaczenie:</strong> <div><span id="connectionStatus" class="status-indicator status-disconnected"></span> <span id="connectionText">Rozlaczony</span></div>
                <strong>Gamepad:</strong> <span id="gamepadStatus" style="font-weight:bold; color: #f7b731;">Brak</span>
                <strong>Tryb Pracy:</strong> <span id="robotStateVal" style="font-weight:bold; color: #61dafb;">IDLE</span>
                <strong>Czas Petli:</strong> <span id="loopTimeVal">0 &micro;s</span>
                <strong>Wolna Sterta (RAM):</strong> <span id="freeHeapVal" style="font-weight:bold; color: #f7b731;">0 B</span>
            </div>
            <div class="info-grid">
                <strong>Kat (Pitch):</strong> <div class="angle-display"><span id="angleVal">0.0 &deg;</span><div class="angle-indicator-wrapper"><div id="angleIndicator" class="angle-indicator-needle"></div></div></div>
                <strong>Predkosc (imp/s):</strong> <span id="speedVal">0</span>
                <strong>Zadany Kat:</strong> <span id="targetAngleVal">0.0 &deg;</span>
                <strong>LQR Wyjscie:</strong> <span id="lqrOutputVal">0</span>
                <strong>Enkoder L:</strong> <span id="encoderLeftVal">0</span>
                <strong>Enkoder P:</strong> <span id="encoderRightVal">0</span>
            </div>
        </div>
        
        <div class="card">
             <button class="accordion-header" onclick="toggleAccordion(this)">Sterowanie Autonomiczne</button>
             <div class="accordion-content">
                <fieldset>
                    <legend>Sterowanie Precyzyjne (D-Pad)</legend>
                    <div class="dpad-input-group"><label for="dpadDistInput">Dystans (cm):</label><input type="number" id="dpadDistInput" value="20"></div>
                    <div class="dpad-input-group"><label for="dpadAngleInput">Kat (st.):</label><input type="number" id="dpadAngleInput" value="90"></div>
                    <div class="dpad-container">
                        <button id="dpad-up" class="dpad-btn" data-dpad="up">&#8593;</button>
                        <button id="dpad-left" class="dpad-btn" data-dpad="left">&#8592;</button>
                        <button id="dpad-stop" class="dpad-btn" data-dpad="stop">&#215;</button>
                        <button id="dpad-right" class="dpad-btn" data-dpad="right">&#8594;</button>
                        <button id="dpad-down" class="dpad-btn" data-dpad="down">&#8595;</button>
                    </div>
                </fieldset>
                <fieldset style="margin-top: 15px;">
                    <legend>Kreator Sekwencji Ruchow</legend>
                    <div id="sequence-list"></div>
                    <button id="add-sequence-step-btn" style="width:100%; margin: 10px 0;">Dodaj Krok</button>
                    <div style="display:flex; gap:10px; justify-content:center;">
                        <button id="run-sequence-btn" style="background-color: #a2f279;">Uruchom</button>
                        <button id="stop-sequence-btn" style="background-color: #ff6347;" disabled>Zatrzymaj</button>
                        <button id="clear-sequence-btn" style="background-color: #f7b731;">Wyczysc</button>
                    </div>
                </fieldset>
                
                <fieldset style="margin-top: 15px;">
                    <legend>Strojenie Autonomii</legend>
                    <div class="setting-container">
                        <label for="positionPGainInput">Agresywnosc Ruchu (P)<span class="help-icon">?</span></label>
                        <div class="numeric-input-wrapper">
                            <button id="positionPGainMinus">-</button>
                            <input type="number" class="config-value" id="positionPGainInput" min="0.001" max="0.1" step="0.001" value="0.005">
                            <button id="positionPGainPlus">+</button>
                        </div>
                        <div class="help-text"><strong>Wplyw:</strong> Sila, z jaka robot wraca do celu. Wieksza wartosc = szybszy, bardziej agresywny ruch. Zbyt duza moze powodowac oscylacje.</div>
                    </div>
                    <div class="setting-container">
                        <label for="positionDGainInput">Hamowanie (D)<span class="help-icon">?</span></label>
                        <div class="numeric-input-wrapper">
                            <button id="positionDGainMinus">-</button>
                            <input type="number" class="config-value" id="positionDGainInput" min="0" max="0.5" step="0.001" value="0.01">
                            <button id="positionDGainPlus">+</button>
                        </div>
                        <div class="help-text"><strong>Wplyw:</strong> Tlumienie ruchu. Wieksza wartosc = robot mocniej hamuje, zblizajac sie do celu, co zapobiega 'przestrzeleniu' pozycji.</div>
                    </div>
                    <div class="setting-container">
                        <label for="rotationPGainInput">Agresywnosc Obrotu<span class="help-icon">?</span></label>
                        <div class="numeric-input-wrapper">
                            <button id="rotationPGainMinus">-</button>
                            <input type="number" class="config-value" id="rotationPGainInput" min="0.1" max="10" step="0.1" value="2.5">
                            <button id="rotationPGainPlus">+</button>
                        </div>
                        <div class="help-text"><strong>Wplyw:</strong> Sila, z jaka robot wykonuje obrot do celu. Wieksza wartosc = szybszy obrot.</div>
                    </div>
                </fieldset>

                <fieldset style="margin-top: 15px;">
                    <legend>Diagnostyka</legend>
                     <button id="calibrateMpuBtn" style="width:100%; background-color:#f7b731;">Kalibruj MPU (DMP)</button>
                </fieldset>
            </div>
        </div>
        
        <div class="card">
            <button class="accordion-header" onclick="toggleAccordion(this)">Wykres Telemetryczny</button>
            <div class="accordion-content">
                <div id="chart-wrapper"><canvas id="telemetryChart"></canvas></div>
                <div class="chart-controls" id="chartControls"></div>
            </div>
        </div>
        
        <div class="card">
            <h2>Konfiguracja</h2>
            <fieldset>
                <legend>Profile Ustawien LQR</legend>
                <div class="profile-controls">
                    <select id="lqrPresetSelect" style="width: 100%; padding: 5px;"></select>
                </div>
                 <div class="preset-actions">
                    <button id="applySelectedPresetBtn">Zastosuj Wybrany Preset</button>
                    <button id="sendCurrentSettingsBtn">Wyslij Aktualne Ustawienia (sekwencyjnie)</button>
                    <button id="saveCurrentAsPresetBtn">Zapisz Aktualne jako Nowy Preset</button>
                </div>
            </fieldset>
            
            <div id="allSettings">
                <button class="accordion-header" onclick="toggleAccordion(this)">1. Wagi LQR (Strojenie Niestandardowe)</button>
                <div class="accordion-content">
                    <div class="setting-container">
                        <label for="q1AngleInput">Q1 - Kara za Kat</label>
                        <div class="numeric-input-wrapper"><button id="q1AngleMinus">-</button><input type="number" class="lqr-input config-value" id="q1AngleInput" min="0" max="1000" step="5" value="100"><button id="q1AnglePlus">+</button></div>
                    </div>
                    <div class="setting-container">
                        <label for="q2AngularVelInput">Q2 - Kara za Predkosc Katowa</label>
                        <div class="numeric-input-wrapper"><button id="q2AngularVelMinus">-</button><input type="number" class="lqr-input config-value" id="q2AngularVelInput" min="0" max="100" step="1" value="10"><button id="q2AngularVelPlus">+</button></div>
                    </div>
                    <div class="setting-container">
                        <label for="q3PositionInput">Q3 - Kara za Pozycje</label>
                        <div class="numeric-input-wrapper"><button id="q3PositionMinus">-</button><input type="number" class="lqr-input config-value" id="q3PositionInput" min="0" max="1000" step="10" value="1"><button id="q3PositionPlus">+</button></div>
                    </div>
                    <div class="setting-container">
                        <label for="q4VelocityInput">Q4 - Kara za Predkosc</label>
                        <div class="numeric-input-wrapper"><button id="q4VelocityMinus">-</button><input type="number" class="lqr-input config-value" id="q4VelocityInput" min="0" max="100" step="1" value="5"><button id="q4VelocityPlus">+</button></div>
                    </div>
                    <div class="setting-container">
                        <label for="rControlInput">R - Kara za Sterowanie</label>
                        <div class="numeric-input-wrapper"><button id="rControlMinus">-</button><input type="number" class="lqr-input config-value" id="rControlInput" min="0.001" max="10" step="0.01" value="0.1"><button id="rControlPlus">+</button></div>
                    </div>
                    <div class="setting-container">
                        <label for="lqrOutputScalarInput">Skala Wyjscia LQR</label>
                        <div class="numeric-input-wrapper"><button id="lqrOutputScalarMinus">-</button><input type="number" class="config-value" id="lqrOutputScalarInput" min="0.1" max="50.0" step="0.1" value="20.0"><button id="lqrOutputScalarPlus">+</button></div>
                    </div>
                </div>
                
                <button class="accordion-header" onclick="toggleAccordion(this)">2. Parametry Sprzetowe</button>
                <div class="accordion-content">
                    <div class="physics-section">
                        <h4>Parametry Fizyczne Robota</h4>
                        <div class="setting-container">
                            <label for="mBodyInput">Masa korpusu (kg)</label>
                            <div class="numeric-input-wrapper"><button id="mBodyMinus" disabled>-</button><input type="number" class="config-value" id="mBodyInput" value="0.150" disabled><button id="mBodyPlus" disabled>+</button></div>
                        </div>
                        <div class="setting-container">
                            <label for="mWheelInput">Masa kola (kg)</label>
                            <div class="numeric-input-wrapper"><button id="mWheelMinus" disabled>-</button><input type="number" class="config-value" id="mWheelInput" value="0.055" disabled><button id="mWheelPlus" disabled>+</button></div>
                        </div>
                        <div class="setting-container">
                            <label for="LInput">Wys. srodka masy (m)</label>
                            <div class="numeric-input-wrapper"><button id="LMinus" disabled>-</button><input type="number" class="config-value" id="LInput" value="0.087" disabled><button id="LPlus" disabled>+</button></div>
                        </div>
                        <div style="background-color: #20232a; padding: 10px; border-radius: 5px; margin-top: 10px; border-left: 4px solid #f7b731; text-align: left;">
                            <strong>INFO:</strong> Te parametry nie sa uzywane przy obecnym, statycznym modelu LQR wgranym na robota.
                        </div>
                    </div>
                    <div class="parameter-group">
                        <h5>Kalibracja Mechaniczna</h5>
                        <div class="setting-container">
                            <label for="wheelDiameterCmInput">Srednica kola (cm)</label>
                            <div class="numeric-input-wrapper"><button id="wheelDiameterCmMinus">-</button><input type="number" class="config-value" id="wheelDiameterCmInput" min="3" max="30" step="0.1" value="8.2"><button id="wheelDiameterCmPlus">+</button></div>
                        </div>
                        <div class="setting-container">
                            <label for="trackWidthCmInput">Rozstaw kol (cm)</label>
                            <div class="numeric-input-wrapper"><button id="trackWidthCmMinus">-</button><input type="number" class="config-value" id="trackWidthCmInput" min="5" max="50" step="0.1" value="13.0"><button id="trackWidthCmPlus">+</button></div>
                        </div>
                        <div class="setting-container">
                            <label for="encoderPprInput">Impulsy na obrot (PPR)</label>
                            <div class="numeric-input-wrapper"><button id="encoderPprMinus">-</button><input type="number" class="config-value" id="encoderPprInput" min="100" max="5000" step="10" value="820"><button id="encoderPprPlus">+</button></div>
                        </div>
                    </div>
                </div>

                <button class="accordion-header" onclick="toggleAccordion(this)">3. Kalibracja PWM Silnikow</button>
                <div class="accordion-content">
                    <div class="pwm-info">
                        <strong>Info:</strong> Minimalne wartosci PWM to prog, ponizej ktorego silnik nie kreci sie. Ustal je testujac kazdy silnik osobno.
                    </div>
                    <div class="manual-tune-row" data-motor="left" data-direction="fwd"><label>Lewy (Przod)</label><div class="numeric-input-wrapper"><button class="tune-minus">-</button><input type="number" class="config-value tune-input" id="minPwmLeftFwdInput" min="0" max="1023" step="1" value="640"><button class="tune-plus">+</button></div><div><button class="test-btn">Testuj</button><button class="stop-btn">Stop</button></div></div>
                    <div class="manual-tune-row" data-motor="left" data-direction="bwd"><label>Lewy (Tyl)</label><div class="numeric-input-wrapper"><button class="tune-minus">-</button><input type="number" class="config-value tune-input" id="minPwmLeftBwdInput" min="0" max="1023" step="1" value="640"><button class="tune-plus">+</button></div><div><button class="test-btn">Testuj</button><button class="stop-btn">Stop</button></div></div>
                    <div class="manual-tune-row" data-motor="right" data-direction="fwd"><label>Prawy (Przod)</label><div class="numeric-input-wrapper"><button class="tune-minus">-</button><input type="number" class="config-value tune-input" id="minPwmRightFwdInput" min="0" max="1023" step="1" value="640"><button class="tune-plus">+</button></div><div><button class="test-btn">Testuj</button><button class="stop-btn">Stop</button></div></div>
                    <div class="manual-tune-row" data-motor="right" data-direction="bwd"><label>Prawy (Tyl)</label><div class="numeric-input-wrapper"><button class="tune-minus">-</button><input type="number" class="config-value tune-input" id="minPwmRightBwdInput" min="0" max="1023" step="1" value="640"><button class="tune-plus">+</button></div><div><button class="test-btn">Testuj</button><button class="stop-btn">Stop</button></div></div>
                    <hr style="border-color: #4a4f58; margin: 15px 0;">
                    <button id="manualTuneStopAll" style="width:100%; margin-top:15px; background-color:#ff6347;">ZATRZYMAJ WSZYSTKO</button>
                </div>
            </div>
            
            <div class="button-group" style="display:flex; gap:10px; justify-content:center; margin-top:20px;">
                <button id="loadBtn">Wczytaj z EEPROM</button>
                <button id="saveBtn">Zapisz na Robocie</button>
            </div>
        </div>
        <div class="card">
            <button class="accordion-header active" onclick="toggleAccordion(this)">Logi Systemowe</button>
            <div class="accordion-content active">
                <div id="log-history"></div>
                <div style="margin-top: 10px; display: flex; gap: 10px; justify-content: center; align-items: center;">
                    <button onclick="clearLogs()" style="background-color: #f7b731;">Wyczysc Logi</button>
                </div>
            </div>
        </div>
    </div>

<script>
    const CUSTOM_PRESET_PREFIX = 'lqr_custom_preset_';
    let bleDevice, rxCharacteristic, txCharacteristic;
    const SERVICE_UUID = "4fafc201-1fb5-459e-8fcc-c5c9c331914b";
    const RX_UUID = "beb5483e-36e1-4688-b7f5-ea07361b26a9";
    const TX_UUID = "beb5483e-36e1-4688-b7f5-ea07361b26a8";
    let chunkBuffers = {};
    let isSequenceRunning = false;
    let currentSequenceStep = 0;
    const MAX_SEQUENCE_STEPS = 10;
    let lastKnownRobotState = 'IDLE';

    const joystickCanvas = document.getElementById('joystickCanvas');
    const joystickCtx = joystickCanvas.getContext('2d');
    let joystickCenter, joystickRadius, knobRadius, isDragging = false;
    let lastJoystickSendTime = 0;
    const JOYSTICK_SEND_INTERVAL = 50;
    
    let gamepadIndex = null;
    let lastGamepadState = [];
    let lastGamepadAxes = { x: 0, y: 0 };
    let gamepadMappings = {};
    const GAMEPAD_MAPPING_KEY = 'lqr_gamepad_mappings';
    const GAMEPAD_AXIS_THRESHOLD = 0.15;
    
    const availableActions = {
        'toggle_balance': { label: 'Wlacz/Wylacz Balansowanie', elementId: 'balanceSwitch' },
        'toggle_hold_position': { label: 'Wlacz/Wylacz Trzymanie Pozycji', elementId: 'holdPositionSwitch' },
        'toggle_speed_mode': { label: 'Wlacz/Wylacz Tryb Predkosci', elementId: 'speedModeSwitch' },
        'emergency_stop': { label: 'STOP AWARYJNY', elementId: 'emergencyStopBtn' },
        'reset_zero': { label: 'Resetuj Osie (Pion)', elementId: 'resetZeroBtn' },
        'trim_plus': { label: 'Korekta Pionu (+)', elementId: 'trimPlusBtn' },
        'trim_minus': { label: 'Korekta Pionu (-)', elementId: 'trimMinusBtn' },
    };
    
    // [UZUPELNIONY BLOK 1/4] Definicja zmiennych do wykresu
    const availableTelemetry = {
        'pitch': { label: 'Pitch (Kat)', color: '#61dafb' },
        'target_angle': { label: 'Zadany Kat', color: '#a2f279' },
        'speed': { label: 'Predkosc', color: '#f7b731' },
        'lqr_output': { label: 'LQR Wyjscie', color: '#ff9ff3' },
    };

    const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));
    const debounce = (func, delay) => {
        let timeout;
        return function(...args) {
            const context = this;
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(context, args), delay);
        };
    };

    function addLogMessage(message, level = 'info') {
        const logHistory = document.getElementById('log-history');
        if (!logHistory) return;
        const timestamp = new Date().toLocaleTimeString();
        let color = '#fff';
        if (level === 'error') color = '#ff6347';
        else if (level === 'warn') color = '#f7b731';
        const logEntry = document.createElement('div');
        logEntry.style.color = color;
        logEntry.textContent = `[${timestamp}] ${message}`;
        logHistory.prepend(logEntry);
        while (logHistory.children.length > 200) {
            logHistory.removeChild(logHistory.lastChild);
        }
    }
    
    function clearLogs() {
        document.getElementById('log-history').innerHTML = '';
    }

    function toggleAccordion(header) {
        const content = header.nextElementSibling;
        const isActive = header.classList.contains('active');
        if (!isActive) {
            header.classList.add('active');
            content.style.maxHeight = content.scrollHeight + "px";
        } else {
            header.classList.remove('active');
            content.style.maxHeight = '0px';
        }
    }
    
    function updateAccordionHeight(content) {
        if (content && content.style.maxHeight !== '0px') {
            content.style.maxHeight = content.scrollHeight + 'px';
        }
    }

    async function connectBLE() {
        addLogMessage('[UI] Prosze o wybranie urzadzenia Bluetooth...', 'info');
        try {
            bleDevice = await navigator.bluetooth.requestDevice({
                filters: [{ services: [SERVICE_UUID] }],
                optionalServices: [SERVICE_UUID]
            });
            addLogMessage(`[UI] Laczenie z ${bleDevice.name}...`, 'info');
            document.getElementById('connectBleBtn').disabled = true;
            document.getElementById('connectionText').textContent = 'Laczenie...';
            bleDevice.addEventListener('gattserverdisconnected', onDisconnected);
            const server = await bleDevice.gatt.connect();
            const service = await server.getPrimaryService(SERVICE_UUID);
            rxCharacteristic = await service.getCharacteristic(RX_UUID);
            txCharacteristic = await service.getCharacteristic(TX_UUID);
            await txCharacteristic.startNotifications();
            txCharacteristic.addEventListener('characteristicvaluechanged', handleBleNotification);
            document.getElementById('connectionStatus').className = 'status-indicator status-ok';
            document.getElementById('connectionText').textContent = 'Polaczony';
            addLogMessage('[UI] Polaczono! Automatyczna synchronizacja za 1s...', 'info');
            setTimeout(() => sendBleMessage({ type: 'request_state' }), 1000);
        } catch (error) {
            addLogMessage(`[UI] Blad polaczenia BLE: ${error}`, 'error');
            document.getElementById('connectionStatus').className = 'status-indicator status-error';
            document.getElementById('connectionText').textContent = 'Blad polaczenia';
            document.getElementById('connectBleBtn').disabled = false;
        }
    }

    function onDisconnected() {
        addLogMessage('[UI] Rozlaczono z robotem.', 'warn');
        document.getElementById('connectionStatus').className = 'status-indicator status-disconnected';
        document.getElementById('connectionText').textContent = 'Rozlaczony';
        ['balanceSwitch', 'holdPositionSwitch', 'speedModeSwitch'].forEach(id => {
            const el = document.getElementById(id);
            if (el) el.checked = false;
        });
        document.getElementById('connectBleBtn').disabled = false;
        rxCharacteristic = null;
        txCharacteristic = null;
        chunkBuffers = {};
    }

    function handleBleNotification(event) {
        const value = event.target.value;
        const decoder = new TextDecoder('utf-8');
        const jsonString = decoder.decode(value);
        try {
            const data = JSON.parse(jsonString);
            if (data.type === 'chunk') {
                if (!chunkBuffers[data.id]) {
                    chunkBuffers[data.id] = { chunks: new Array(data.total), receivedCount: 0, totalCount: data.total };
                }
                const buffer = chunkBuffers[data.id];
                if (!buffer.chunks[data.i]) {
                    buffer.chunks[data.i] = data.data;
                    buffer.receivedCount++;
                }
                if (buffer.receivedCount === buffer.totalCount) {
                    const completeMessageString = buffer.chunks.join('');
                    delete chunkBuffers[data.id];
                    processCompleteMessage(JSON.parse(completeMessageString));
                }
            } else {
                processCompleteMessage(data);
            }
        } catch (e) {
            addLogMessage(`[UI] Blad parsowania JSON: ${e}. Dane: ${jsonString}`, 'error');
        }
    }

    async function sendBleMessage(message) {
        if (!rxCharacteristic) { return; }
        try {
            const encoder = new TextEncoder();
            await rxCharacteristic.writeValueWithoutResponse(encoder.encode(JSON.stringify(message)));
        } catch (error) { addLogMessage(`[UI] Blad wysylania danych BLE: ${error}`, 'error'); }
    }

    function processCompleteMessage(data) {
        let previousRobotState = lastKnownRobotState;
        switch (data.type) {
            case 'telemetry':
                if(data.robot_state) lastKnownRobotState = data.robot_state;
                updateTelemetryUI(data);
                updateChart(data); // [UZUPELNIONY BLOK 2/4] Wywolanie funkcji aktualizacji wykresu
                checkAndExecuteNextSequenceStep(previousRobotState);
                break;
            case 'full_config':
                applyFullConfig(data);
                break;
            case 'log':
                addLogMessage(`[ROBOT] ${data.message}`, data.level);
                break;
            case 'memory_info':
                if (data.free_heap !== undefined) document.getElementById('freeHeapVal').textContent = `${data.free_heap} B`;
                break;
        }
    }
    
    function applyFullConfig(data) {
        ['balanceSwitch', 'holdPositionSwitch', 'speedModeSwitch', 'lqrEnabledSwitch'].forEach(id => {
            const el = document.getElementById(id);
            if (el) el.checked = data[id.replace('Switch', 'Enabled')];
        });
        
        const params = {
            joystickOutputScale: data.joystick_output_scale * 100, expoJoystick: data.expo_joystick * 100, maxSpeedJoystick: data.max_speed_joystick, joystickAngleSensitivity: data.joystick_angle_sensitivity, turnFactor: data.turn_factor * 100,
            headingCorrectionFactor: data.heading_correction_factor, speedToAngleFactor: data.speed_to_angle_factor,
            positionPGain: data.position_p_gain, positionDGain: data.position_d_gain, rotationPGain: data.rotation_p_gain,
            q1Angle: data.q1_angle, q2AngularVel: data.q2_angular_vel, q3Position: data.q3_position, q4Velocity: data.q4_velocity, rControl: data.r_control, lqrOutputScalar: data.lqr_output_scalar,
            mBody: data.m_body, mWheel: data.m_wheel, L: data.L,
            wheelDiameterCm: data.wheel_diameter_cm, trackWidthCm: data.track_width_cm, encoderPpr: data.encoder_ppr,
            minPwmLeftFwd: data.min_pwm_left_fwd, minPwmLeftBwd: data.min_pwm_left_bwd, minPwmRightFwd: data.min_pwm_right_fwd, minPwmRightBwd: data.min_pwm_right_bwd,
        };

        for (const [key, value] of Object.entries(params)) {
            const input = document.getElementById(key + 'Input');
            if (input && value !== undefined) {
                input.value = value;
            }
        }
        addLogMessage("[UI] Parametry robota zsynchronizowane z panelem.", "info");
    }

    function updateTelemetryUI(data) {
        if (data.robot_state !== undefined) document.getElementById('robotStateVal').textContent = data.robot_state;
        if (data.pitch !== undefined) {
            document.getElementById('angleVal').textContent = data.pitch.toFixed(1) + ' \u00B0';
            document.getElementById('angleIndicator').style.transform = `rotate(${data.pitch}deg)`;
        }
        if (data.speed !== undefined) document.getElementById('speedVal').textContent = parseFloat(data.speed).toFixed(0);
        if (data.target_angle !== undefined) document.getElementById('targetAngleVal').textContent = parseFloat(data.target_angle).toFixed(1) + ' \u00B0';
        if (data.lqr_output !== undefined) document.getElementById('lqrOutputVal').textContent = parseFloat(data.lqr_output).toFixed(2);
        if (data.loop_time !== undefined) document.getElementById('loopTimeVal').textContent = data.loop_time + ' \u00B5s';
        if (data.encoder_left !== undefined) document.getElementById('encoderLeftVal').textContent = data.encoder_left;
        if (data.encoder_right !== undefined) document.getElementById('encoderRightVal').textContent = data.encoder_right;
        
        const emergencyBanner = document.getElementById('emergency-banner');
        if (data.emergency_stop) {
            emergencyBanner.style.display = 'block';
        } else {
            emergencyBanner.style.display = 'none';
        }
    }

    // [UZUPELNIONY BLOK 3/4] Inicjalizacja, aktualizacja i kontrola wykresu
    const telemetryChart = new Chart(document.getElementById('telemetryChart'), {
        type: 'line', data: { labels: Array(100).fill(''), datasets: [] }, options: { animation: false, responsive: true, maintainAspectRatio: false, scales: { x: { display: false }, y: { type: 'linear', display: true, position: 'left', ticks: { color: '#61dafb' }, title: { display: true, text: 'Wartosc', color: '#61dafb' } }, y1: { type: 'linear', display: true, position: 'right', ticks: { color: '#a2f279' }, title: { display: true, text: 'Wyjscie LQR / PWM', color: '#a2f279' }, grid: { drawOnChartArea: false }, } }, plugins: { legend: { labels: { color: '#fff' } } } }
    });

    function updateChart(data) {
        const chartData = telemetryChart.data;
        if (chartData.labels.length >= 100) chartData.labels.shift();
        chartData.labels.push('');
        
        for (const [key, value] of Object.entries(data)) {
            if (availableTelemetry[key] && value !== undefined) {
                let dataset = chartData.datasets.find(ds => ds.label === availableTelemetry[key].label);
                if (!dataset) continue; 
                if (dataset.data.length >= 100) dataset.data.shift();
                dataset.data.push(value);
            }
        }
        chartData.datasets.forEach(ds => {
            if (ds.data.length < chartData.labels.length) {
                if (ds.data.length >= 100) ds.data.shift();
                ds.data.push(null);
            }
        });
        telemetryChart.update('none');
    }
    
    function setupChartControls() {
        const container = document.getElementById('chartControls');
        container.innerHTML = '';
        Object.keys(availableTelemetry).forEach((key) => {
            const label = document.createElement('label'), checkbox = document.createElement('input');
            checkbox.type = 'checkbox'; checkbox.value = key;
            checkbox.checked = (key === 'pitch' || key === 'target_angle');
            checkbox.addEventListener('change', (e) => {
                const varName = e.target.value;
                sendBleMessage({ type: e.target.checked ? 'subscribe_variable' : 'unsubscribe_variable', name: varName });
                if (e.target.checked) {
                    const chartData = telemetryChart.data;
                    if (!chartData.datasets.find(ds => ds.label === availableTelemetry[varName].label)) {
                         const axisId = (varName.includes('output')) ? 'y1' : 'y';
                         chartData.datasets.push({ label: availableTelemetry[varName].label, data: Array(chartData.labels.length).fill(null), borderColor: availableTelemetry[varName].color, fill: false, tension: 0.1, pointRadius: 0, yAxisID: axisId });
                    }
                } else {
                    const chartData = telemetryChart.data;
                    const datasetIndex = chartData.datasets.findIndex(ds => ds.label === availableTelemetry[varName].label);
                    if (datasetIndex > -1) { 
                        chartData.datasets.splice(datasetIndex, 1);
                    }
                }
                telemetryChart.update();
            });
            label.appendChild(checkbox);
            label.append(` ${availableTelemetry[key].label}`);
            container.appendChild(label);
            
            if (checkbox.checked) {
                checkbox.dispatchEvent(new Event('change'));
            }
        });
    }

    function populatePresetSelect() {
        const select = document.getElementById('lqrPresetSelect');
        select.innerHTML = '';
        
        const builtInPresets = {
            1: '1. Wbudowany: Zbalansowany', 2: '2. Wbudowany: Bardzo Sztywny', 3: '3. Wbudowany: Miekki',
            4: '4. Wbudowany: Szybka Jazda', 5: '5. Wbudowany: Powolna Jazda', 6: '6. Wbudowany: Mocne Trzymanie Pozycji',
            7: '7. Wbudowany: Tylko Balans', 8: '8. Wbudowany: Eksperymentalny', 9: '9. Wbudowany: Precyzja Autonomiczna'
        };

        for (const [index, name] of Object.entries(builtInPresets)) {
            const option = document.createElement('option');
            option.value = index;
            option.textContent = name;
            select.appendChild(option);
        }

        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key.startsWith(CUSTOM_PRESET_PREFIX)) {
                const presetName = key.substring(CUSTOM_PRESET_PREFIX.length);
                const option = document.createElement('option');
                option.value = key;
                option.textContent = `Wlasny: ${presetName}`;
                select.appendChild(option);
            }
        }
    }

    async function applySelectedPreset() {
        const select = document.getElementById('lqrPresetSelect');
        const selectedValue = select.value;

        if (selectedValue.startsWith(CUSTOM_PRESET_PREFIX)) {
            const presetData = JSON.parse(localStorage.getItem(selectedValue));
            if (presetData) {
                addLogMessage(`[UI] Ladowanie wlasnego presetu '${selectedValue.substring(CUSTOM_PRESET_PREFIX.length)}' do pol.`, 'info');
                for (const [key, value] of Object.entries(presetData)) {
                    const input = document.getElementById(key + 'Input');
                    if (input) input.value = value;
                }
                await sendLqrSettingsSequentially();
            } else {
                addLogMessage(`[UI] Blad: nie znaleziono danych dla presetu '${selectedValue}'.`, 'error');
            }
        } else {
            const index = parseInt(selectedValue);
            addLogMessage(`[UI] Wysylanie polecenia zastosowania wbudowanego presetu #${index}...`, 'info');
            await sendBleMessage({ type: 'apply_preset', index: index });
        }
    }

    function saveCurrentAsPreset() {
        const presetName = prompt("Podaj nazwe dla nowego presetu:", "");
        if (presetName && presetName.trim() !== "") {
            const presetData = {};
            const keysToSave = ['q1Angle', 'q2AngularVel', 'q3Position', 'q4Velocity', 'rControl', 'lqrOutputScalar'];
            keysToSave.forEach(key => {
                const input = document.getElementById(key + 'Input');
                if(input) presetData[key] = parseFloat(input.value);
            });
            localStorage.setItem(CUSTOM_PRESET_PREFIX + presetName.trim(), JSON.stringify(presetData));
            addLogMessage(`[UI] Zapisano wlasny preset '${presetName.trim()}'.`, 'info');
            populatePresetSelect();
        } else {
            addLogMessage('[UI] Anulowano zapisywanie presetu.', 'warn');
        }
    }

    async function sendLqrSettingsSequentially() {
        const btn = document.getElementById('sendCurrentSettingsBtn');
        btn.disabled = true;
        const paramsToSend = [
            { id: 'q1AngleInput', key: 'q1_angle' }, { id: 'q2AngularVelInput', key: 'q2_angular_vel' },
            { id: 'q3PositionInput', key: 'q3_position' }, { id: 'q4VelocityInput', key: 'q4_velocity' },
            { id: 'rControlInput', key: 'r_control' }, { id: 'lqrOutputScalarInput', key: 'lqr_output_scalar' }
        ];
        for (let i = 0; i < paramsToSend.length; i++) {
            const param = paramsToSend[i];
            const input = document.getElementById(param.id);
            if (input) {
                const value = parseFloat(input.value);
                const message = { type: 'lqr_update', params: { [param.key]: value } };
                btn.textContent = `Wysylanie ${i + 1}/${paramsToSend.length}...`;
                await sendBleMessage(message);
                await sleep(50);
            }
        }
        btn.textContent = 'Wyslij Aktualne Ustawienia (sekwencyjnie)';
        btn.disabled = false;
        addLogMessage('[UI] Zakonczono sekwencyjne wysylanie parametrow LQR.', 'info');
    }

    function setupNumericInputs() {
        document.querySelectorAll('.setting-container').forEach(container => {
            const input = container.querySelector('input[type=number]');
            const minusBtn = container.querySelector('.numeric-input-wrapper button:first-child');
            const plusBtn = container.querySelector('.numeric-input-wrapper button:last-child');
            if (!input || !minusBtn || !plusBtn || input.disabled) return;

            const step = parseFloat(input.step) || 1;
            const isFloat = input.step.includes('.');
            
            const updateValue = (amount) => {
                let current = parseFloat(input.value);
                let newValue = current + amount;
                if (isFloat) {
                    const dp = (step.toString().split('.')[1] || '').length;
                    newValue = parseFloat(newValue.toFixed(dp));
                }
                input.value = Math.max(parseFloat(input.min), Math.min(parseFloat(input.max), newValue));
                input.dispatchEvent(new Event('change', { bubbles: true }));
            };
            minusBtn.addEventListener('click', () => updateValue(-step));
            plusBtn.addEventListener('click', () => updateValue(step));
        });
    }

    const debouncedSenders = {};
    function setupEventListeners() {
        document.getElementById('connectBleBtn').addEventListener('click', connectBLE);
        
        ['balanceSwitch', 'holdPositionSwitch', 'speedModeSwitch', 'lqrEnabledSwitch'].forEach(id => {
            document.getElementById(id).addEventListener('change', (e) => {
                const typeMap = {
                    'balanceSwitch': 'balance_toggle', 'holdPositionSwitch': 'hold_position_toggle', 
                    'speedModeSwitch': 'speed_mode_toggle', 'lqrEnabledSwitch': 'lqr_enabled_toggle'
                };
                sendBleMessage({ type: typeMap[id], enabled: e.target.checked });
            });
        });

        document.getElementById('resetZeroBtn').addEventListener('click', () => sendBleMessage({ type: 'reset_zero' }));
        document.getElementById('trimPlusBtn').addEventListener('click', () => sendBleMessage({ type: 'adjust_zero', value: 1 }));
        document.getElementById('trimMinusBtn').addEventListener('click', () => sendBleMessage({ type: 'adjust_zero', value: -1 }));
        document.getElementById('trimRollPlusBtn').addEventListener('click', () => sendBleMessage({ type: 'adjust_roll', value: 1 }));
        document.getElementById('trimRollMinusBtn').addEventListener('click', () => sendBleMessage({ type: 'adjust_roll', value: -1 }));
        document.getElementById('emergencyStopBtn').addEventListener('click', () => sendBleMessage({ type: 'emergency_stop' }));
        document.getElementById('saveBtn').addEventListener('click', () => { if (confirm("Czy na pewno chcesz nadpisac ustawienia w pamieci robota?")) sendBleMessage({ type: 'save_tunings' }); });
        document.getElementById('loadBtn').addEventListener('click', () => { if (confirm("UWAGA! Spowoduje to nadpisanie wszystkich niezapisanych zmian. Kontynuowac?")) sendBleMessage({ type: 'load_from_eeprom' }); });
        document.getElementById('resetEncodersBtn').addEventListener('click', () => sendBleMessage({ type: 'reset_encoders' }));
        document.getElementById('calibrateMpuBtn').addEventListener('click', () => sendBleMessage({ type: 'calibrate_mpu' }));
        
        const configGroups = {
            'set_joystick_tuning': ['joystickOutputScale', 'expoJoystick', 'maxSpeedJoystick', 'joystickAngleSensitivity', 'turnFactor'],
            'calibration_update': ['positionPGain', 'positionDGain', 'rotationPGain', 'wheelDiameterCm', 'trackWidthCm', 'encoderPpr', 'headingCorrectionFactor', 'speedToAngleFactor'],
            'set_min_pwm': ['minPwmLeftFwd', 'minPwmLeftBwd', 'minPwmRightFwd', 'minPwmRightBwd']
        };

        for (const [type, keys] of Object.entries(configGroups)) {
            debouncedSenders[type] = debounce(() => {
                const params = {};
                keys.forEach(key => {
                    const input = document.getElementById(key + 'Input');
                    if(input) {
                        let value = parseFloat(input.value);
                        if (key === 'turnFactor' || key === 'joystickOutputScale' || key === 'expoJoystick') value /= 100;
                        params[key.replace(/([A-Z])/g, "_$1").toLowerCase()] = value;
                    }
                });
                sendBleMessage({ type, params });
            }, 300);

            keys.forEach(key => {
                const input = document.getElementById(key + 'Input');
                if(input) input.addEventListener('change', debouncedSenders[type]);
            });
        }

        document.getElementById('applySelectedPresetBtn').addEventListener('click', applySelectedPreset);
        document.getElementById('saveCurrentAsPresetBtn').addEventListener('click', saveCurrentAsPreset);
        document.getElementById('sendCurrentSettingsBtn').addEventListener('click', sendLqrSettingsSequentially);

        document.querySelectorAll('.help-icon').forEach(icon => {
            icon.addEventListener('click', (e) => {
                e.stopPropagation();
                const container = icon.closest('.setting-container');
                const helpText = container.querySelector('.help-text');
                if (helpText) {
                    helpText.classList.toggle('visible');
                    const accordionContent = container.closest('.accordion-content');
                    if (accordionContent) updateAccordionHeight(accordionContent);
                }
            });
        });
    }
    
    function flashElement(element) {
        if (!element) return;
        const target = element.tagName === 'INPUT' ? element.closest('.switch') || element.closest('.control-row') || element : element;
        target.classList.add('gamepad-flash');
        setTimeout(() => target.classList.remove('gamepad-flash'), 300);
    }

    function loadGamepadMappings() {
        const saved = localStorage.getItem(GAMEPAD_MAPPING_KEY);
        gamepadMappings = saved ? JSON.parse(saved) : {};
    }

    function saveGamepadMappings() {
        localStorage.setItem(GAMEPAD_MAPPING_KEY, JSON.stringify(gamepadMappings));
    }

    function renderMappingModal() {
        const list = document.getElementById('gamepad-mapping-list');
        list.innerHTML = '';
        for (const [action, config] of Object.entries(availableActions)) {
            const row = document.createElement('div');
            row.className = 'mapping-row';
            const buttonIndex = Object.keys(gamepadMappings).find(key => gamepadMappings[key] === action);
            row.innerHTML = `
                <span class="mapping-label">${config.label}</span>
                <span class="mapping-display">${buttonIndex ? `Przycisk ${buttonIndex}` : 'Brak'}</span>
                <button class="mapping-button" data-action="${action}">Przypisz</button>
            `;
            list.appendChild(row);
        }
    }

    function pollGamepad() {
        if (gamepadIndex === null) return;
        const gp = navigator.getGamepads()[gamepadIndex];
        if (!gp) return;

        let x = gp.axes[0], y = gp.axes[1];
        if (Math.abs(x) < GAMEPAD_AXIS_THRESHOLD) x = 0;
        if (Math.abs(y) < GAMEPAD_AXIS_THRESHOLD) y = 0;
        if (x !== lastGamepadAxes.x || y !== lastGamepadAxes.y) {
            if (Date.now() - lastJoystickSendTime > JOYSTICK_SEND_INTERVAL) {
                sendBleMessage({ type: 'joystick', x: x, y: -y });
                drawJoystick(x * joystickRadius, y * joystickRadius);
                lastJoystickSendTime = Date.now();
            }
        }
        lastGamepadAxes = { x, y };

        gp.buttons.forEach((button, i) => {
            if (button.pressed && !lastGamepadState[i]) {
                const action = gamepadMappings[i];
                if (action && availableActions[action]) {
                    const config = availableActions[action];
                    const element = document.getElementById(config.elementId);
                    if (element) {
                        element.click();
                        flashElement(element);
                        addLogMessage(`[Gamepad] Akcja: ${config.label}`, 'info');
                    }
                }
            }
            lastGamepadState[i] = button.pressed;
        });
    }

    function setupGamepad() {
        loadGamepadMappings();
        const modal = document.getElementById('gamepad-mapping-modal');
        document.getElementById('open-gamepad-modal-btn').addEventListener('click', () => {
            renderMappingModal();
            modal.style.display = 'flex';
        });
        document.getElementById('close-modal-btn').addEventListener('click', () => {
            modal.style.display = 'none';
        });
        document.getElementById('gamepad-mapping-list').addEventListener('click', (e) => {
            if (e.target.classList.contains('mapping-button')) {
                const action = e.target.dataset.action;
                e.target.textContent = 'Nacisnij...';
                e.target.disabled = true;

                const listener = (event) => {
                    const buttonIndex = event.detail;
                    Object.keys(gamepadMappings).forEach(key => {
                        if (gamepadMappings[key] === action) delete gamepadMappings[key];
                    });
                    gamepadMappings[buttonIndex] = action;
                    saveGamepadMappings();
                    renderMappingModal();
                    window.removeEventListener('gamepadbuttonpress', listener);
                };
                window.addEventListener('gamepadbuttonpress', listener, { once: true });
            }
        });
        
        let lastGpStateForEvent = [];
        const gamepadEventLoop = () => {
            if(gamepadIndex !== null){
                const gp = navigator.getGamepads()[gamepadIndex];
                if (gp) {
                    gp.buttons.forEach((button, i) => {
                        if(button.pressed && !lastGpStateForEvent[i]){
                            window.dispatchEvent(new CustomEvent('gamepadbuttonpress', { detail: i }));
                        }
                    });
                    lastGpStateForEvent = gp.buttons.map(b => b.pressed);
                }
            }
            requestAnimationFrame(gamepadEventLoop);
        };

        window.addEventListener("gamepadconnected", (e) => {
            gamepadIndex = e.gamepad.index;
            document.getElementById('gamepadStatus').textContent = 'Polaczony';
            addLogMessage(`[UI] Kontroler podlaczony: ${e.gamepad.id}`, 'info');
            lastGamepadState = Array(e.gamepad.buttons.length).fill(false);
            lastGpStateForEvent = Array(e.gamepad.buttons.length).fill(false);
        });
        window.addEventListener("gamepaddisconnected", (e) => {
            if (gamepadIndex === e.gamepad.index) {
                gamepadIndex = null;
                document.getElementById('gamepadStatus').textContent = 'Brak';
                addLogMessage('[UI] Kontroler odlaczony.', 'warn');
            }
        });
        gamepadEventLoop();
    }
    
    function resizeJoystick() {
        const wrapper = document.getElementById('joystickWrapper');
        joystickCanvas.width = wrapper.offsetWidth;
        joystickCanvas.height = wrapper.offsetHeight;
        joystickCenter = { x: joystickCanvas.width / 2, y: joystickCanvas.height / 2 };
        joystickRadius = Math.min(joystickCanvas.width, joystickCanvas.height) / 2 * 0.9;
        knobRadius = joystickRadius / 3;
        drawJoystick(0, 0);
    }

    function drawJoystick(x, y) {
        joystickCtx.clearRect(0, 0, joystickCanvas.width, joystickCanvas.height);
        joystickCtx.beginPath();
        joystickCtx.arc(joystickCenter.x, joystickCenter.y, joystickRadius, 0, Math.PI * 2);
        joystickCtx.fillStyle = '#4a4f58';
        joystickCtx.fill();
        joystickCtx.beginPath();
        joystickCtx.arc(joystickCenter.x + x, joystickCenter.y + y, knobRadius, 0, Math.PI * 2);
        joystickCtx.fillStyle = '#a2f279';
        joystickCtx.fill();
    }

    function handleJoystickMove(e) {
        if (!isDragging) return;
        e.preventDefault();
        const rect = joystickCanvas.getBoundingClientRect();
        const clientX = e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : 0);
        const clientY = e.clientY || (e.touches && e.touches[0] ? e.touches[0].clientY : 0);
        const x = clientX - rect.left - joystickCenter.x;
        const y = clientY - rect.top - joystickCenter.y;
        const distance = Math.sqrt(x * x + y * y);
        let finalX = x, finalY = y;
        if (distance > joystickRadius) {
            const angle = Math.atan2(y, x);
            finalX = joystickRadius * Math.cos(angle);
            finalY = joystickRadius * Math.sin(angle);
        }
        drawJoystick(finalX, finalY);
        const now = Date.now();
        if (now - lastJoystickSendTime > JOYSTICK_SEND_INTERVAL) {
            sendBleMessage({ type: 'joystick', x: finalX / joystickRadius, y: -finalY / joystickRadius });
            lastJoystickSendTime = now;
        }
    }

    function startJoystickDrag(e) { isDragging = true; handleJoystickMove(e); }

    function endJoystickDrag(e) {
        if (!isDragging) return;
        isDragging = false;
        drawJoystick(0, 0);
        sendBleMessage({ type: 'joystick', x: 0, y: 0 });
        lastJoystickSendTime = 0;
    }

    function setupDpadControls() {
        document.querySelectorAll('.dpad-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const action = e.currentTarget.dataset.dpad;
                if (action === 'up') sendBleMessage({ type: 'execute_move', distance_cm: parseFloat(document.getElementById('dpadDistInput').value) });
                else if (action === 'down') sendBleMessage({ type: 'execute_move', distance_cm: -parseFloat(document.getElementById('dpadDistInput').value) });
                else if (action === 'left') sendBleMessage({ type: 'execute_rotate', angle_deg: -parseFloat(document.getElementById('dpadAngleInput').value) });
                else if (action === 'right') sendBleMessage({ type: 'execute_rotate', angle_deg: parseFloat(document.getElementById('dpadAngleInput').value) });
                else if (action === 'stop') sendBleMessage({ type: 'command_stop' });
            });
        });
    }

    function setupSequenceControls() {
        document.getElementById('add-sequence-step-btn').addEventListener('click', addSequenceStep);
        document.getElementById('run-sequence-btn').addEventListener('click', runSequence);
        document.getElementById('stop-sequence-btn').addEventListener('click', stopSequenceExecution);
        document.getElementById('clear-sequence-btn').addEventListener('click', clearSequence);
    }

    function addSequenceStep() {
        const list = document.getElementById('sequence-list');
        if (list.children.length >= MAX_SEQUENCE_STEPS) return;
        const stepDiv = document.createElement('div');
        stepDiv.className = 'sequence-step';
        stepDiv.innerHTML = `
            <select class="sequence-type">
                <option value="move_fwd">Przod (cm)</option><option value="move_bwd">Tyl (cm)</option>
                <option value="rotate_r">Obrot Prawo (st.)</option><option value="rotate_l">Obrot Lewo (st.)</option>
            </select>
            <input type="number" class="sequence-value" value="10">
            <button class="remove-step-btn">&times;</button>
        `;
        list.appendChild(stepDiv);
        updateAccordionHeight(list.closest('.accordion-content'));
        stepDiv.querySelector('.remove-step-btn').addEventListener('click', () => {
            stepDiv.remove();
            updateAccordionHeight(list.closest('.accordion-content'));
        });
    }

    function runSequence() {
        if (isSequenceRunning) return;
        const normalizedState = lastKnownRobotState.includes("BEZCZYN") ? "IDLE" : lastKnownRobotState;
        if (normalizedState !== 'IDLE' && normalizedState !== 'UTRZYMUJE POZYCJE') {
            addLogMessage(`[UI] Nie mozna rozpoczac sekwencji. Robot w stanie '${lastKnownRobotState}'.`, 'error');
            return;
        }
        const steps = document.querySelectorAll('.sequence-step');
        if (steps.length === 0) return;
        isSequenceRunning = true;
        currentSequenceStep = 0;
        updateSequenceUI();
        addLogMessage(`[UI] Rozpoczeto sekwencje z ${steps.length} krokow.`, 'info');
        executeNextSequenceStep();
    }
    
    function stopSequenceExecution() {
        if (!isSequenceRunning) return;
        isSequenceRunning = false;
        sendBleMessage({ type: 'command_stop' });
        updateSequenceUI();
        addLogMessage('[UI] Sekwencja zatrzymana.', 'warn');
    }

    function clearSequence() {
        if (isSequenceRunning) stopSequenceExecution();
        const list = document.getElementById('sequence-list');
        list.innerHTML = '';
        updateAccordionHeight(list.closest('.accordion-content'));
    }
    
    function updateSequenceUI() {
        document.querySelectorAll('.sequence-step').forEach((step, index) => {
            step.classList.toggle('executing', isSequenceRunning && index === currentSequenceStep);
        });
        document.getElementById('run-sequence-btn').disabled = isSequenceRunning;
        document.getElementById('add-sequence-step-btn').disabled = isSequenceRunning;
        document.getElementById('clear-sequence-btn').disabled = isSequenceRunning;
        document.getElementById('stop-sequence-btn').disabled = !isSequenceRunning;
    }

    function checkAndExecuteNextSequenceStep(previousState) {
        if (!isSequenceRunning) return;
        const isRobotIdle = lastKnownRobotState.includes('BEZCZYN') || lastKnownRobotState.includes('UTRZYMUJE');
        const wasRobotWorking = previousState.includes('RUCH') || previousState.includes('OBROT');
        if (isRobotIdle && wasRobotWorking) {
            addLogMessage(`[UI] Krok ${currentSequenceStep + 1} zakonczony.`, 'info');
            currentSequenceStep++;
            executeNextSequenceStep();
        }
    }

    function executeNextSequenceStep() {
        const steps = document.querySelectorAll('.sequence-step');
        if (!isSequenceRunning || currentSequenceStep >= steps.length) {
            if (isSequenceRunning) { 
                isSequenceRunning = false;
                addLogMessage('[UI] Sekwencja ukonczona.', 'info');
            }
            updateSequenceUI();
            return;
        }
        updateSequenceUI();
        const stepNode = steps[currentSequenceStep];
        const type = stepNode.querySelector('.sequence-type').value;
        const value = parseFloat(stepNode.querySelector('.sequence-value').value);
        let command = {};
        switch (type) {
            case 'move_fwd': command = { type: 'execute_move', distance_cm: value }; break;
            case 'move_bwd': command = { type: 'execute_move', distance_cm: -value }; break;
            case 'rotate_r': command = { type: 'execute_rotate', angle_deg: value }; break;
            case 'rotate_l': command = { type: 'execute_rotate', angle_deg: -value }; break;
        }
        addLogMessage(`[UI] Wysylanie kroku ${currentSequenceStep + 1}/${steps.length}: ${command.type}(${value}).`, 'info');
        sendBleMessage(command);
    }

    function setupManualTuningControls() {
        document.querySelectorAll('.manual-tune-row').forEach(row => {
            const input = row.querySelector('.tune-input');
            const testBtn = row.querySelector('.test-btn');
            const stopBtn = row.querySelector('.stop-btn');
            testBtn.addEventListener('click', () => {
                sendBleMessage({ type: 'set_direct_motor_control', motor: row.dataset.motor, direction: row.dataset.direction, pwm: parseInt(input.value) });
            });
            stopBtn.addEventListener('click', () => {
                sendBleMessage({ type: 'set_direct_motor_control', motor: row.dataset.motor, direction: 'fwd', pwm: 0 });
            });
        });
        document.getElementById('manualTuneStopAll').addEventListener('click', () => {
            sendBleMessage({ type: 'set_direct_motor_control', motor: 'all', pwm: 0 });
        });
    }

    document.addEventListener('DOMContentLoaded', () => {
        setupEventListeners();
        resizeJoystick();
        setupNumericInputs();
        setupGamepad();
        populatePresetSelect();
        setupDpadControls();
        setupSequenceControls();
        setupManualTuningControls();
        setupChartControls(); // [UZUPELNIONY BLOK 4/4] Wywolanie funkcji tworzacej kontrolki wykresu
        
        document.querySelectorAll('.accordion-header').forEach(header => {
            const content = header.nextElementSibling;
            if (header.classList.contains('active')) {
                 setTimeout(() => { if(content) content.style.maxHeight = content.scrollHeight + 'px'; }, 100);
            } else {
                if(content) content.style.maxHeight = '0px';
            }
        });

        const gamepadPollingLoop = () => {
            pollGamepad();
            requestAnimationFrame(gamepadPollingLoop);
        };
        gamepadPollingLoop();
        
        joystickCanvas.addEventListener('mousedown', startJoystickDrag);
        joystickCanvas.addEventListener('touchstart', startJoystickDrag, { passive: false });
        document.addEventListener('mousemove', handleJoystickMove);
        document.addEventListener('touchmove', handleJoystickMove, { passive: false });
        document.addEventListener('mouseup', endJoystickDrag);
        document.addEventListener('touchend', endJoystickDrag);
    });
    window.onresize = resizeJoystick;

</script>
</body>
</html>