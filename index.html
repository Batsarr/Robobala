<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Robot PID - Panel Sterowania v3.0 (Advanced AutoTest)</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <style>
        body { font-family: Arial, sans-serif; text-align: center; margin: 0; padding: 15px; background-color: #282c34; color: #fff; font-size: 14px; }
        h1 { color: #61dafb; font-size: 1.8em; }
        h2 { color: #61dafb; font-size: 1.4em; margin-top: 0; margin-bottom: 15px; }
        .main-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(340px, 1fr)); gap: 15px; align-items: start; max-width: 1920px; margin: auto; }
        .card { background-color: #3a3f47; border-radius: 8px; padding: 15px; box-shadow: 0 2px 6px rgba(0,0,0,0.2); }
        .info-grid, .status-grid { display: grid; grid-template-columns: auto 1fr; gap: 8px; text-align: left; font-size: 1em; margin-top: 10px; align-items: center;}
        .info-grid strong, .status-grid strong { color: #a2f279; }
        button { background-color: #61dafb; color: #282c34; border: none; padding: 8px 12px; border-radius: 5px; font-weight: bold; cursor: pointer; transition: background-color 0.3s, opacity 0.3s, box-shadow 0.2s; font-size: 0.9em; }
        button:hover { background-color: #a2f279; }
        button:disabled { background-color: #4a4f58; color: #888; cursor: not-allowed; opacity: 0.6; }
        .gamepad-flash { box-shadow: 0 0 10px 3px #a2f279 !important; }
        #emergencyStopBtn { background-color: #ff6347; color: white; width: 100%; margin-top: 15px; }
        .control-row { display: flex; align-items: center; justify-content: space-between; width: 100%; margin-top: 10px; }
        .control-label { font-size: 1.1em; font-weight: bold; }
        .switch { position: relative; display: inline-block; width: 50px; height: 28px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider.round { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ff6347; transition: .4s; border-radius: 28px; }
        .slider.round:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #a2f279; }
        input:checked + .slider:before { transform: translateX(22px); }
        input[type="checkbox"].slider-checkbox + .slider { background-color: #4a4f58; }
        input[type="checkbox"].slider-checkbox:checked + .slider { background-color: #a2f279; }
        input:disabled + .slider { background-color: #4a4f58; cursor: not-allowed; }
        fieldset { border: 1px solid #4a4f58; border-radius: 8px; margin-top: 15px; padding: 10px 15px; }
        legend { color: #61dafb; font-weight: bold; padding: 0 10px; font-size: 1.1em; }
        #joystickWrapper { position: relative; width: 180px; height: 180px; border-radius: 50%; background-color: #4a4f58; border: 3px solid #61dafb; margin: 15px auto; touch-action: none; }
        #joystickCanvas { width: 100%; height: 100%; display: block; }
        #chart-wrapper { position: relative; height: 320px; border-radius: 8px; overflow: hidden; background-color: #20232a; }
        #log-history { text-align: left; height: 350px; overflow-y: auto; background-color: #20232a; padding: 10px; border-radius: 8px; font-family: monospace; white-space: pre-wrap; }
        .status-indicator { width: 14px; height: 14px; border-radius: 50%; display: inline-block; }
        .status-ok { background-color: #a2f279; }
        .status-warn { background-color: #f7b731; }
        .status-error { background-color: #ff6347; }
        .status-disconnected { background-color: #888; }
        #emergency-banner { display: none; background-color: #ff6347; color: white; padding: 10px; font-weight: bold; position: fixed; top: 0; left: 0; width: 100%; z-index: 1000; }
        .angle-display { display: flex; align-items: center; justify-content: space-between; }
        .angle-indicator-wrapper { position: relative; width: 34px; height: 34px; background-color: #20232a; border-radius: 50%; border: 1px solid #61dafb; }
        .angle-indicator-needle { position: absolute; bottom: 50%; left: calc(50% - 1px); width: 2px; height: 50%; background-color: #ff6347; transform-origin: bottom center; transition: transform 0.1s linear; }
        .chart-controls { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin-top: 10px; font-size: 0.9em; }
        .chart-controls label { color: #fff; }
        .setting-container { display: grid; grid-template-columns: 1fr auto; gap: 10px; align-items: center; margin: 8px 0; }
        .setting-container label { font-size: 1em; font-weight: bold; color: #a2f279; text-align: left; }
        .numeric-input-wrapper { display: flex; align-items: center; flex-shrink: 0; }
        .numeric-input-wrapper button { background-color: #4a4f58; color: #61dafb; padding: 4px 8px; font-size: 1em; line-height: 1; min-width: 30px; }
        .numeric-input-wrapper input[type=number] { width: 90px; text-align: center; font-size: 1em; background-color: #20232a; color: #fff; border: 1px solid #61dafb; border-radius: 5px; margin: 0 4px; padding: 4px; -moz-appearance: textfield; }
        input[type=number]::-webkit-inner-spin-button, input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        .manual-tune-row { background-color: #2a2f35; padding: 10px; border-radius: 6px; margin-bottom: 12px; }
        .pwm-input-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .pwm-input-row label { font-weight: bold; color: #a2f279; }
        .pwm-button-row { display: flex; justify-content: flex-end; gap: 10px; }
        .pwm-button-row button { flex-grow: 1; max-width: 100px; }
        .test-btn { background-color: #a2f279; }
        .stop-btn { background-color: #ff6347; }
        .auto-btn { background-color: #f7b731; }
        .trim-controls { display: flex; justify-content: space-between; align-items: center; margin-top: 10px; }
        .trim-controls span { font-weight: bold; }
        .trim-controls button { min-width: 40px; font-size: 1.2em; }
        .accordion-header { background-color: #4a4f58; color: #61dafb; cursor: pointer; padding: 12px 15px; border: none; text-align: left; outline: none; font-size: 1.1em; font-weight: bold; width: 100%; border-radius: 8px; margin-top: 5px; transition: background-color 0.3s; position: relative; }
        .accordion-header:hover { background-color: #5a6068; }
        .accordion-header.active { background-color: #61dafb; color: #282c34; border-bottom-left-radius: 0; border-bottom-right-radius: 0;}
        .accordion-header::after { content: '+'; position: absolute; right: 15px; font-size: 1.4em; transition: transform 0.3s; }
        .accordion-header.active::after { content: '-'; }
        .accordion-content { max-height: 0; overflow: hidden; transition: max-height 0.4s ease-out; background-color: #3a3f47; border-bottom-left-radius: 8px; border-bottom-right-radius: 8px;}
        .accordion-content.active { padding: 15px; }
        .pwm-info { background-color: #20232a; padding: 10px; border-radius: 5px; margin-bottom: 15px; border-left: 4px solid #61dafb; }
        .pwm-info strong { color: #a2f279; }
        .parameter-group { background-color: #20232a; padding: 12px; border-radius: 6px; margin-bottom: 12px; }
        .parameter-group h5 { color: #61dafb; margin: 0 0 8px 0; font-size: 1.1em; }
        .help-icon { display: inline-block; width: 16px; height: 16px; border-radius: 50%; background-color: #61dafb; color: #282c34; font-size: 12px; font-weight: bold; text-align: center; line-height: 16px; margin-left: 8px; cursor: pointer; user-select: none; }
        .help-text { background-color: #20232a; color: #fff; border-radius: 6px; padding: 10px; border: 1px solid #61dafb; margin-top: 8px; text-align: left; font-size: 0.9em; line-height: 1.4; width: 100%; box-sizing: border-box; max-height: 0; overflow: hidden; transition: max-height 0.3s ease-out, padding 0.3s ease-out; padding-top: 0; padding-bottom: 0; grid-column: 1 / -1; }
        .help-text.visible { max-height: 200px; padding-top: 10px; padding-bottom: 10px; }
        .modal-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); z-index: 2000; display: none; justify-content: center; align-items: center; }
        .modal-content { background-color: #3a3f47; padding: 20px; border-radius: 8px; width: 90%; max-width: 500px; box-shadow: 0 5px 15px rgba(0,0,0,0.5); }
        .mapping-row { display: grid; grid-template-columns: 1fr 100px 100px; gap: 10px; align-items: center; margin-bottom: 10px; }
        .mapping-label { text-align: left; font-weight: bold; }
        .mapping-button { font-size: 0.8em; padding: 6px 8px; }
        .mapping-display { background-color: #20232a; padding: 6px; border-radius: 4px; font-family: monospace; }
        .preset-actions { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px; }
        #applySelectedPresetBtn { background-color: #a2f279; }
        #saveCurrentAsPresetBtn { background-color: #61dafb; }
        #autotestStatusPanel { background-color: #20232a; padding: 12px; border-radius: 6px; }
        #autotestStatusPanel h5 { color: #61dafb; margin: 0 0 10px 0; font-size: 1.1em; text-align: left; }
        #statusProgressBar { width: 100%; -webkit-appearance: none; appearance: none; height: 8px; }
        #statusProgressBar::-webkit-progress-bar { background-color: #4a4f58; border-radius: 4px; }
        #statusProgressBar::-webkit-progress-value { background-color: #a2f279; border-radius: 4px; transition: width 0.3s ease; }
        .radio-selector-group { display: flex; flex-direction: column; gap: 8px; }
        .radio-selector-item input[type="radio"] { display: none; }
        .radio-selector-item label { display: block; padding: 10px; background-color: #4a4f58; color: #fff; border-radius: 5px; cursor: pointer; transition: background-color 0.3s, color 0.3s; text-align: left; padding-left: 35px; position: relative; }
        .radio-selector-item label::before { content: ''; position: absolute; left: 10px; top: 50%; transform: translateY(-50%); width: 18px; height: 18px; border: 2px solid #61dafb; border-radius: 50%; transition: border-color 0.3s; }
        .radio-selector-item label::after { content: ''; position: absolute; left: 14px; top: 50%; transform: translateY(-50%); width: 10px; height: 10px; background-color: #a2f279; border-radius: 50%; opacity: 0; transition: opacity 0.3s; }
        .radio-selector-item input[type="radio"]:checked + label { background-color: #61dafb; color: #282c34; font-weight: bold; }
        .radio-selector-item input[type="radio"]:checked + label::before { border-color: #282c34; }
        .radio-selector-item input[type="radio"]:checked + label::after { opacity: 1; }
        #validationResultPanel { display: none; background-color: #20232a; padding: 12px; border-radius: 6px; margin-top: 15px; }
        #validationResultPanel h5 { color: #61dafb; margin: 0 0 10px 0; font-size: 1.1em; text-align: left; }
        #validationResultPanel p { margin: 5px 0; text-align: left;}
        #validationResultPanel strong { color: #a2f279; }
    </style>
</head>
<body>
    <div id="emergency-banner">ZATRZYMANIE AWARYJNE</div>
    <div id="gamepad-mapping-modal" class="modal-backdrop">
        <div class="modal-content">
            <h2>Mapowanie Przyciskow Gamepada</h2>
            <div id="gamepad-mapping-list"></div>
            <button id="close-modal-btn" style="margin-top: 20px;">Zamknij</button>
        </div>
    </div>

    <h1>Robot PID - Panel Sterowania</h1>
    <div class="main-grid">
        <div class="card" id="controls-card">
            <h2>Sterowanie</h2>
            <div id="joystickWrapper"><canvas id="joystickCanvas"></canvas></div>
            <div class="control-row"><span class="control-label">Balansowanie</span><label class="switch"><input type="checkbox" id="balanceSwitch"><span class="slider round"></span></label></div>
            <div class="control-row"><span class="control-label">Trzymaj Pozycje</span><label class="switch"><input type="checkbox" id="holdPositionSwitch"><span class="slider round"></span></label></div>
            <div class="control-row"><span class="control-label">Tryb Predkosci</span><label class="switch"><input type="checkbox" id="speedModeSwitch"><span class="slider round"></span></label></div>
            <button id="open-gamepad-modal-btn" style="width: 100%; background-color:#f7b731; margin-top: 15px;">Mapowanie Przyciskow Gamepada</button>
            <button id="resetZeroBtn" style="margin-top:10px; width:100%;">Resetuj Osie</button>
            <div class="trim-controls"> <button id="trimMinusBtn">-</button> <span>Korekta Pionu (Pitch)</span> <button id="trimPlusBtn">+</button> </div>
            <button id="resetEncodersBtn" style="margin-top:10px; background-color:#f7b731; width: 100%;">Resetuj Enkodery</button>
            <button id="emergencyStopBtn">STOP AWARYJNY</button>
        </div>
        <div class="card">
            <h2>Status Robota</h2>
            <button id="connectBleBtn" style="width: 100%; margin-bottom: 15px;">POLACZ Z ROBOTEM</button>
            <div class="status-grid">
                <strong>Polaczenie:</strong> <div><span id="connectionStatus" class="status-indicator status-disconnected"></span> <span id="connectionText">Rozlaczony</span></div>
                <strong>Gamepad:</strong> <span id="gamepadStatus" style="font-weight:bold; color: #f7b731;">Brak</span>
                <strong>Tryb Pracy:</strong> <span id="robotStateVal" style="font-weight:bold; color: #61dafb;">IDLE</span>
            </div>
            <div class="info-grid">
                <strong>Kat (Pitch):</strong> <div class="angle-display"><span id="angleVal">0.0 &deg;</span><div class="angle-indicator-wrapper"><div id="angleIndicator" class="angle-indicator-needle"></div></div></div>
                <strong>Kat (Yaw):</strong> <span id="yawVal">0.0 &deg;</span>
                <strong>Predkosc (imp/s):</strong> <span id="speedVal">0</span>
                <strong>Enkoder L:</strong> <span id="encoderLeftVal">0</span>
                <strong>Enkoder P:</strong> <span id="encoderRightVal">0</span>
            </div>
             <fieldset style="margin-top: 15px;">
                <legend>Diagnostyka</legend>
                <button id="calibrateMpuBtn" style="width:100%; background-color:#f7b731;">Kalibruj MPU (DMP)</button>
            </fieldset>
        </div>
        <div class="card">
            <button class="accordion-header" onclick="toggleAccordion(this)">Wykres Telemetryczny</button>
            <div class="accordion-content">
                <div id="chart-wrapper"><canvas id="telemetryChart"></canvas></div>
                <div class="chart-controls" id="chartControls"></div>
            </div>
        </div>
        <div class="card">
            <h2>Konfiguracja</h2>
            <fieldset>
                <legend>Profile Ustawien PID</legend>
                <div class="profile-controls"> <select id="pidPresetSelect" style="width: 100%; padding: 5px;"></select> </div>
                <div class="preset-actions">
                    <button id="applySelectedPresetBtn">Zastosuj</button>
                    <button id="saveCurrentAsPresetBtn">Zapisz jako Nowy</button>
                </div>
                <button id="deleteSelectedPresetBtn" style="width:100%; margin-top: 10px; background-color: #ff6347;">Usun Wybrany Preset</button>
            </fieldset>
            <div id="allSettings">
                <button class="accordion-header" onclick="toggleAccordion(this)">1. Strojenie Joysticka</button>
                <div class="accordion-content">
                    <div class="setting-container"><label for="joystickSensitivityInput">Czulosc Globalna (%)<span class="help-icon">?</span></label><div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="joystickSensitivityInput" min="10" max="100" step="5" value="100"><button>+</button></div><div class="help-text">Mnoznik dla wszystkich wartosci z joysticka. Zmniejsz, aby robot byl mniej czuly.</div></div>
                    <div class="setting-container"><label for="expoJoystickInput">Expo Joysticka (%)<span class="help-icon">?</span></label><div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="expoJoystickInput" min="0" max="90" step="1" value="0"><button>+</button></div><div class="help-text">Dodaje krzywa wykladnicza. Wieksza wartosc = wieksza precyzja przy malych wychyleniach.</div></div> 
                    <div class="setting-container"><label for="maxSpeedJoystickInput">Max. predkosc (imp/s)<span class="help-icon">?</span></label><div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="maxSpeedJoystickInput" min="200" max="4000" step="100" value="800"><button>+</button></div><div class="help-text">Maksymalna predkosc zadana w trybie predkosci przy pelnym wychyleniu joysticka.</div></div> 
                    <div class="setting-container"><label for="joystickAngleSensitivityInput">Czulosc Kata (st.)<span class="help-icon">?</span></label><div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="joystickAngleSensitivityInput" min="1" max="30" step="0.5" value="10"><button>+</button></div><div class="help-text">Maksymalny kat pochylenia zadany w trybie kata przy pelnym wychyleniu joysticka.</div></div> 
                    <div class="setting-container"><label for="turnFactorInput">Czulosc Skretu (%)<span class="help-icon">?</span></label><div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="turnFactorInput" min="0" max="100" step="5" value="25"><button>+</button></div><div class="help-text">Jak szybko robot ma sie obracac w miejscu przy maksymalnym wychyleniu joysticka w poziomie.</div></div> 
                    <div class="setting-container"><label for="joystickDeadzoneInput">Strefa Martwa (%)<span class="help-icon">?</span></label><div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="joystickDeadzoneInput" min="0" max="50" step="1" value="0"><button>+</button></div><div class="help-text">Obszar wokol srodka joysticka, w ktorym ruch jest ignorowany.</div></div>
                </div>

                <button class="accordion-header" onclick="toggleAccordion(this)">2. PID Balansu (Podstawowy)</button>
                <div class="accordion-content"> 
                    <div class="setting-container"> <label for="balanceKpInput">Kp - Sila<span class="help-icon">?</span></label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="balanceKpInput" step="1" value="95"><button>+</button></div> <div class="help-text"><strong>Wplyw:</strong> Sztywnosc utrzymania pionu. Zwieksz dla szybszej reakcji na wychylenie. Zbyt duza wartosc powoduje oscylacje.</div> </div> 
                    <div class="setting-container"> <label for="balanceKiInput">Ki - Korekta<span class="help-icon">?</span></label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="balanceKiInput" step="0.01" value="0"><button>+</button></div> <div class="help-text"><strong>Wplyw:</strong> Usuwa dlugotrwaly blad (np. gdy robot dryfuje). Zwiekszaj bardzo ostroznie, czesto nie jest potrzebny.</div> </div> 
                    <div class="setting-container"> <label for="balanceKdInput">Kd - Tlumienie<span class="help-icon">?</span></label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="balanceKdInput" step="0.01" value="3.23"><button>+</button></div> <div class="help-text"><strong>Wplyw:</strong> Hamuje oscylacje i uspokaja robota. Przewiduje przyszly blad. Zbyt duza wartosc spowalnia reakcje.</div> </div> 
                    <div class="setting-container"> <label for="balanceFilterAlphaInput">Filtr Pochodnej (%)<span class="help-icon">?</span></label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="balanceFilterAlphaInput" min="1" max="100" step="1" value="100"><button>+</button></div> <div class="help-text">Wygladza odczyt pochodnej, redukujac wplyw szumow. 100% = brak filtrowania. Zmniejsz, jesli robot jest nerwowy.</div> </div>
                </div>

                <button class="accordion-header" onclick="toggleAccordion(this)">3. PID Kaskadowy (Predkosc/Pozycja)</button>
                <div class="accordion-content">
                    <div class="parameter-group"><h5>PID Predkosci</h5>
                        <div class="setting-container"> <label for="speedKpInput">Kp - Reakcja</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="speedKpInput" step="0.01" value="0.05"><button>+</button></div> </div>
                        <div class="setting-container"> <label for="speedKiInput">Ki - Eliminacja bledu</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="speedKiInput" step="0.001" value="0.0"><button>+</button></div> </div>
                        <div class="setting-container"> <label for="speedKdInput">Kd - Tlumienie</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="speedKdInput" step="0.001" value="0.0"><button>+</button></div> </div>
                        <div class="setting-container"> <label for="maxTargetAngleInput">Max. kat z PID Predk. (st.)</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="maxTargetAngleInput" step="0.5" value="15.0"><button>+</button></div> </div>
                        <div class="setting-container"> <label for="speedDeadbandInput">Strefa martwa (imp/s)</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="speedDeadbandInput" step="1" value="5"><button>+</button></div> </div>
                    </div>
                     <div class="parameter-group"><h5>PID Pozycji</h5>
                        <div class="setting-container"> <label for="positionKpInput">Kp - Sila powrotu</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="positionKpInput" step="0.1" value="2.5"><button>+</button></div> </div>
                        <div class="setting-container"> <label for="positionKiInput">Ki - Korekta</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="positionKiInput" step="0.001" value="0.006"><button>+</button></div> </div>
                        <div class="setting-container"> <label for="positionKdInput">Kd - Hamowanie</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="positionKdInput" step="0.05" value="1.0"><button>+</button></div> </div>
                        <div class="setting-container"> <label for="maxTargetSpeedInput">Max. predkosc z PID Poz. (imp/s)</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="maxTargetSpeedInput" step="50" value="1000"><button>+</button></div> </div>
                        <div class="setting-container"> <label for="positionDeadbandInput">Margines bledu (imp.)</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="positionDeadbandInput" step="1" value="15"><button>+</button></div> </div>
                    </div>
                </div>

                <button class="accordion-header" onclick="toggleAccordion(this)">4. PID Obrotu i Kursu</button>
                <div class="accordion-content">
                    <div class="parameter-group"><h5>PID Obrotu (Autonomiczny)</h5>
                        <div class="setting-container"> <label for="rotationKpInput">Kp - Sila obrotu</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="rotationKpInput" step="0.1" value="1.0"><button>+</button></div> </div>
                        <div class="setting-container"> <label for="rotationKdInput">Kd - Tlumienie</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="rotationKdInput" step="0.1" value="1.0"><button>+</button></div> </div>
                    </div>
                    <div class="parameter-group"><h5>PID Utrzymania Kursu (podczas jazdy prosto)</h5>
                        <div class="setting-container"> <label for="headingKpInput">Kp - Sila korekty</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="headingKpInput" step="0.05" value="0.8"><button>+</button></div> </div>
                        <div class="setting-container"> <label for="headingKiInput">Ki - Precyzja</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="headingKiInput" step="0.005" value="0.02"><button>+</button></div> </div>
                        <div class="setting-container"> <label for="headingKdInput">Kd - Tlumienie</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="headingKdInput" step="0.01" value="0.1"><button>+</button></div> </div>
                    </div>
                </div>

                <button class="accordion-header" onclick="toggleAccordion(this)">5. Parametry Sprzetowe i Mechaniczne</button>
                <div class="accordion-content"> 
                    <div class="setting-container"> <label for="wheelDiameterInput">Srednica kola (cm)</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="wheelDiameterInput" step="0.1" value="8.2"><button>+</button></div> </div> 
                    <div class="setting-container"> <label for="trackWidthInput">Rozstaw kol (cm)</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="trackWidthInput" step="0.1" value="12.5"><button>+</button></div> </div> 
                    <div class="setting-container"> <label for="encoderPprInput">Impulsy na obrot (PPR)</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="encoderPprInput" step="10" value="820"><button>+</button></div> </div> 
                    <hr style="border-color: #4a4f58; margin: 10px 0;">
                    <div class="setting-container"> <label for="turnToRollTargetInput">Kat przechylu przy skrecie (st.)</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="turnToRollTargetInput" step="0.1" value="5.0"><button>+</button></div> </div> 
                    <div class="setting-container"> <label for="balanceDeadbandAngleInput">Strefa martwa balansu (st.)</label> <div class="numeric-input-wrapper"><button>-</button><input type="number" class="config-value" id="balanceDeadbandAngleInput" step="0.1" value="0.5"><button>+</button></div> </div>
                </div>

                <button class="accordion-header" onclick="toggleAccordion(this)">6. Kalibracja PWM Silnikow</button>
                <div class="accordion-content"> 
                    <div class="pwm-info"> <strong>Info:</strong> Uzyj przycisku <strong>"Auto"</strong>, aby automatycznie znalezc prog startowy silnika, lub <strong>"Testuj"</strong>, aby sprawdzic recznie wpisana wartosc. <strong>Wazne:</strong> Przed testem podnies robota, aby kola mogly sie swobodnie krecic! </div> 
                     <div class="setting-container"> <label for="pwmTuneStartInput">Rozpocznij auto-szukanie od PWM</label> <div class="numeric-input-wrapper"> <button id="pwmTuneStartMinus">-</button> <input type="number" id="pwmTuneStartInput" min="1" max="800" step="10" value="400"> <button id="pwmTuneStartPlus">+</button> </div> </div> <hr style="border-color: #4a4f58; margin: 15px 0;">
                    <div class="manual-tune-row" data-motor="left" data-direction="fwd"> <div class="pwm-input-row"> <label>Lewy (Przod)</label> <div class="numeric-input-wrapper"><button class="tune-minus">-</button><input type="number" class="config-value tune-input" id="minPwmLeftFwdInput" min="0" max="1023" step="1" value="640"><button>+</button></div> </div> <div class="pwm-button-row"> <button class="test-btn">Testuj</button><button class="stop-btn">Stop</button><button class="auto-btn">Auto</button></div> </div> 
                    <div class="manual-tune-row" data-motor="left" data-direction="bwd"> <div class="pwm-input-row"> <label>Lewy (Tyl)</label> <div class="numeric-input-wrapper"><button class="tune-minus">-</button><input type="number" class="config-value tune-input" id="minPwmLeftBwdInput" min="0" max="1023" step="1" value="640"><button>+</button></div> </div> <div class="pwm-button-row"> <button class="test-btn">Testuj</button><button class="stop-btn">Stop</button><button class="auto-btn">Auto</button></div> </div> 
                    <div class="manual-tune-row" data-motor="right" data-direction="fwd"> <div class="pwm-input-row"> <label>Prawy (Przod)</label> <div class="numeric-input-wrapper"><button class="tune-minus">-</button><input type="number" class="config-value tune-input" id="minPwmRightFwdInput" min="0" max="1023" step="1" value="640"><button>+</button></div> </div> <div class="pwm-button-row"> <button class="test-btn">Testuj</button><button class="stop-btn">Stop</button><button class="auto-btn">Auto</button></div> </div> 
                    <div class="manual-tune-row" data-motor="right" data-direction="bwd"> <div class="pwm-input-row"> <label>Prawy (Tyl)</label> <div class="numeric-input-wrapper"><button class="tune-minus">-</button><input type="number" class="config-value tune-input" id="minPwmRightBwdInput" min="0" max="1023" step="1" value="640"><button>+</button></div> </div> <div class="pwm-button-row"> <button class="test-btn">Testuj</button><button class="stop-btn">Stop</button><button class="auto-btn">Auto</button></div> </div> 
                    <button id="manualTuneStopAll" style="width:100%; margin-top:15px; background-color:#ff6347;">ZATRZYMAJ WSZYSTKIE SILNIKI</button> 
                </div>
            </div>
            <div class="button-group" style="display:flex; gap:10px; justify-content:center; margin-top:20px;"> 
                <button id="loadBtn">Wczytaj z Robota</button> 
                <button id="saveBtn">Zapisz na Robocie</button> 
            </div>
        </div>
        
        <div class="card">
            <button class="accordion-header" onclick="toggleAccordion(this)">Auto Testy PID</button>
            <div class="accordion-content">
                
                <div id="autotestSelector" class="radio-selector-group">
                    <div class="radio-selector-item">
                        <input type="radio" id="test-balance" name="autotest-type" value="balance">
                        <label for="test-balance">1. Strojenie Balansu</label>
                    </div>
                    <div class="radio-selector-item">
                        <input type="radio" id="test-linear" name="autotest-type" value="linear">
                        <label for="test-linear">2. Strojenie Jazdy Liniowej</label>
                    </div>
                    <div class="radio-selector-item">
                        <input type="radio" id="test-turn" name="autotest-type" value="turn">
                        <label for="test-turn">3. Strojenie Obrotu i Kursu</label>
                    </div>
                     <div class="radio-selector-item">
                        <input type="radio" id="test-square" name="autotest-type" value="square_validation">
                        <label for="test-square">4. Walidacja: Test Kwadratu</label>
                    </div>
                </div>

                <div id="autotestOptions" style="margin-top: 15px;">
                    <!-- Opcje beda dynamicznie wstawiane tutaj przez JS -->
                </div>
        
                <hr style="border-color: #4a4f58; margin: 15px 0;">
        
                <div id="autotestStatusPanel">
                    <h5>Status Sesji</h5>
                    <div class="info-grid">
                        <strong>Testowane Parametry:</strong> <span id="statusTestedParams">---</span>
                        <strong>Najlepszy Wynik:</strong> <span id="statusBestScore" style="font-weight: bold; color: #a2f279;">---</span>
                        <strong>Postep:</strong> 
                        <div>
                            <progress id="statusProgressBar" value="0" max="100"></progress>
                            <span id="statusProgressText" style="font-size:0.9em;">Wybierz test i rozpocznij...</span>
                        </div>
                        <strong>Status:</strong> <span id="statusStateText" style="font-weight: bold;">Bezczynny</span>
                    </div>
                </div>
                
                <div id="validationResultPanel">
                    <h5>Wynik Walidacji Kwadratu</h5>
                    <p><strong>Blad Pozycji Koncowej:</strong> <span id="validationPosError">---</span> cm</p>
                    <p><strong>Blad Kursu Koncowego:</strong> <span id="validationYawError">---</span> st.</p>
                    <hr style="border-color: #4a4f58; margin: 10px 0;">
                    <p id="validationSuggestion" style="font-style: italic;">---</p>
                </div>
        
                <button id="autotestActionBtn" style="width:100%; margin-top:15px;" disabled>Wybierz test, aby rozpoczac</button>
                <button id="autotestCancelBtn" style="width:100%; margin-top:10px; background-color:#ff6347; display:none;">Anuluj Sesje</button>
        
            </div>
        </div>

        <div class="card" id="log-card" style="grid-column: 1 / -1;">
            <h2>Logi Systemowe</h2>
            <div id="log-history"></div>
            <div style="margin-top: 10px; display: flex; gap: 10px; justify-content: center; align-items: center;">
                <button onclick="clearLogs()" style="background-color: #f7b731;">Wyczysc Logi</button>
            </div>
        </div>
    </div>

<script>
    // =======================================================================================
    // WERSJA 3.0 (UI dla PID) - PELNA IMPLEMENTACJA AUTO TESTOW
    // =======================================================================================
    
    // ... (CALA LOGIKA JAVASCRIPT ZOSTANIE WSTAWIONA TUTAJ)
</script>
<script>
    // =======================================================================================
    // === BLOK 1: INICJALIZACJA I PODSTAWOWE FUNKCJE ===
    // =======================================================================================
    let isApplyingConfig = false;
    let lastKnownRobotState = 'IDLE';

    const parameterMapping = {
        'balanceKpInput': 'kp_b', 'balanceKiInput': 'ki_b', 'balanceKdInput': 'kd_b',
        'balanceFilterAlphaInput': 'balance_pid_derivative_filter_alpha', 
        'joystickAngleSensitivityInput': 'joystick_angle_sensitivity',
        'speedKpInput': 'kp_s', 'speedKiInput': 'ki_s', 'speedKdInput': 'kd_s',
        'maxTargetAngleInput': 'max_target_angle_from_speed_pid', 'speedDeadbandInput': 'speed_pid_deadband',
        'positionKpInput': 'kp_p', 'positionKiInput': 'ki_p', 'positionKdInput': 'kd_p',
        'maxTargetSpeedFromPosPID': 'max_target_speed_from_pos_pid', 'positionDeadbandInput': 'position_pid_deadband',
        'rotationKpInput': 'kp_r', 'rotationKdInput': 'kd_r',
        'headingKpInput': 'kp_h', 'headingKiInput': 'ki_h', 'headingKdInput': 'kd_h',
        'joystickSensitivityInput': 'joystick_sensitivity', 'expoJoystickInput': 'expo_joystick', 'maxSpeedJoystickInput': 'max_speed_joystick',
        'turnFactorInput': 'turn_factor', 'joystickDeadzoneInput': 'joystick_deadzone',
        'wheelDiameterInput': 'wheel_diameter_cm', 'trackWidthInput': 'track_width_cm', 'encoderPprInput': 'encoder_ppr',
        'turnToRollTargetInput': 'turn_to_roll_target', 'balanceDeadbandAngleInput': 'balance_deadband_angle',
        'minPwmLeftFwdInput': 'min_pwm_left_fwd', 'minPwmLeftBwdInput': 'min_pwm_left_bwd',
        'minPwmRightFwdInput': 'min_pwm_right_fwd', 'minPwmRightBwdInput': 'min_pwm_right_bwd'
    };
    
    document.addEventListener('DOMContentLoaded', () => {
        initJoystick();
        setupChartControls();
        populatePresetSelect();
        setupNumericInputs();
        setupEventListeners();
        setupManualTuneButtons();
        setupGamepadMappingModal();
        setupAutoTestEventListeners();
        loadGamepadMappings();
        renderMappingModal();
        pollGamepad();
        window.addEventListener('resize', initJoystick);
        document.querySelectorAll('.accordion-header.active').forEach(header => {
            const content = header.nextElementSibling;
            if (content) { content.style.maxHeight = content.scrollHeight + "px"; }
        });
    });

    let bleDevice, rxCharacteristic, txCharacteristic;
    const SERVICE_UUID = "4fafc201-1fb5-459e-8fcc-c5c9c331914b";
    const RX_UUID = "beb5483e-36e1-4688-b7f5-ea07361b26a9";
    const TX_UUID = "beb5483e-36e1-4688-b7f5-ea07361b26a8";
    let bleBuffer = '';
    let joystickCenter, joystickRadius, knobRadius, isDragging = false;
    let lastJoystickSendTime = 0;
    const JOYSTICK_SEND_INTERVAL = 25;
    let gamepadIndex = null;
    let lastGamepadState = [];
    let gamepadMappings = {};
    const GAMEPAD_MAPPING_KEY = 'pid_gamepad_mappings_v3';
    let isMappingButton = false;
    let actionToMap = null;
    const CUSTOM_PRESET_PREFIX = 'pid_custom_preset_v3_';

    const availableActions = { 
        'toggle_balance': { label: 'Wlacz/Wylacz Balansowanie', elementId: 'balanceSwitch' }, 
        'toggle_hold_position': { label: 'Wlacz/Wylacz Trzymanie Pozycji', elementId: 'holdPositionSwitch' }, 
        'toggle_speed_mode': { label: 'Wlacz/Wylacz Tryb Predkosci', elementId: 'speedModeSwitch' }, 
        'emergency_stop': { label: 'STOP AWARYJNY', elementId: 'emergencyStopBtn' }, 
        'reset_zero': { label: 'Resetuj Osie (Pion)', elementId: 'resetZeroBtn' }, 
        'trim_plus': { label: 'Korekta Pionu (+)', elementId: 'trimPlusBtn' }, 
        'trim_minus': { label: 'Korekta Pionu (-)', elementId: 'trimMinusBtn' },
        'start_autotest_cycle': { label: 'Uruchom Cykl Auto Testu', elementId: 'autotestActionBtn' }
    };
    const availableTelemetry = { 
        'pitch': { label: 'Pitch (Kat)', color: '#61dafb' }, 
        'yaw': { label: 'Yaw (Kurs)', color: '#f368e0' }, 
        'speed': { label: 'Predkosc', color: '#f7b731' },
        'output': { label: 'Wyjscie PID', color: '#ff6347'}
    };
    const builtInPresetsData = { 
        '1': { name: "1. PID Zbalansowany (Startowy)", params: { balanceKpInput: 95.0, balanceKiInput: 0.0, balanceKdInput: 3.23, speedKpInput: 0.05, positionKpInput: 2.5, positionKiInput: 0.006, positionKdInput: 1.0 }}, 
        '2': { name: "2. PID Mieciutki (Plynny)", params: { balanceKpInput: 80.0, balanceKiInput: 0.0, balanceKdInput: 2.8, speedKpInput: 0.03, positionKpInput: 1.8, positionKiInput: 0.004, positionKdInput: 0.8 }}, 
        '3': { name: "3. PID Agresywny (Sztywny)", params: { balanceKpInput: 110.0, balanceKiInput: 0.0, balanceKdInput: 4.0, speedKpInput: 0.07, positionKpInput: 3.5, positionKiInput: 0.01, positionKdInput: 1.5 }}
    };

    function initJoystick() { const wrapper = document.getElementById('joystickWrapper'); const size = wrapper.clientWidth; const joystickCanvas = document.getElementById('joystickCanvas'); const joystickCtx = joystickCanvas.getContext('2d'); joystickCanvas.width = size; joystickCanvas.height = size; joystickCenter = { x: size / 2, y: size / 2 }; joystickRadius = size / 2 * 0.75; knobRadius = size / 2 * 0.25; drawJoystick(joystickCtx, joystickCenter.x, joystickCenter.y); }
    function drawJoystick(ctx, x, y) { ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); ctx.beginPath(); ctx.arc(joystickCenter.x, joystickCenter.y, joystickRadius, 0, 2 * Math.PI); ctx.fillStyle = 'rgba(255, 255, 255, 0.1)'; ctx.fill(); ctx.beginPath(); ctx.arc(x, y, knobRadius, 0, 2 * Math.PI); ctx.fillStyle = '#61dafb'; ctx.fill(); }
    function getJoystickPosition(event) { const rect = document.getElementById('joystickCanvas').getBoundingClientRect(); const touch = event.touches ? event.touches[0] : event; return { x: touch.clientX - rect.left, y: touch.clientY - rect.top }; }
    function handleJoystickStart(event) { event.preventDefault(); isDragging = true; }
    function handleJoystickMove(event) { if (!isDragging) return; event.preventDefault(); const joystickCanvas = document.getElementById('joystickCanvas'); const joystickCtx = joystickCanvas.getContext('2d'); let { x, y } = getJoystickPosition(event); const dx = x - joystickCenter.x; const dy = y - joystickCenter.y; const distance = Math.sqrt(dx * dx + dy * dy); if (distance > joystickRadius) { x = joystickCenter.x + (dx / distance) * joystickRadius; y = joystickCenter.y + (dy / distance) * joystickRadius; } drawJoystick(joystickCtx, x, y); const now = Date.now(); if (now - lastJoystickSendTime > JOYSTICK_SEND_INTERVAL) { const joyX = (x - joystickCenter.x) / joystickRadius; const joyY = -(y - joystickCenter.y) / joystickRadius; sendBleMessage({ type: 'joystick', x: joyX, y: joyY }); lastJoystickSendTime = now; } }
    function handleJoystickEnd(event) { if (!isDragging) return; event.preventDefault(); isDragging = false; const joystickCanvas = document.getElementById('joystickCanvas'); const joystickCtx = joystickCanvas.getContext('2d'); drawJoystick(joystickCtx, joystickCenter.x, joystickCenter.y); sendBleMessage({ type: 'joystick', x: 0, y: 0 }); }
    
    function pollGamepad() { if (gamepadIndex !== null) { const gp = navigator.getGamepads()[gamepadIndex]; if (!gp) return; if (isMappingButton && actionToMap) { gp.buttons.forEach((button, i) => { if (button.pressed && !lastGamepadState[i]) { Object.keys(gamepadMappings).forEach(key => { if (gamepadMappings[key] === actionToMap) delete gamepadMappings[key]; }); gamepadMappings[i] = actionToMap; saveGamepadMappings(); addLogMessage(`[UI] Akcja '${availableActions[actionToMap].label}' przypisana do przycisku ${i}.`, 'success'); isMappingButton = false; actionToMap = null; renderMappingModal(); } }); } else { gp.buttons.forEach((button, i) => { if (button.pressed && !lastGamepadState[i]) { const action = gamepadMappings[i]; if (action && availableActions[action]) { const element = document.getElementById(availableActions[action].elementId); if (element && !element.disabled) { element.click(); flashElement(element); } } } }); } lastGamepadState = gp.buttons.map(b => b.pressed); let x = gp.axes[0] || 0; let y = gp.axes[1] || 0; if (Math.abs(x) < 0.15) x = 0; if (Math.abs(y) < 0.15) y = 0; sendBleMessage({ type: 'joystick', x: x, y: -y }); } requestAnimationFrame(pollGamepad); }
    window.addEventListener('gamepadconnected', (e) => { gamepadIndex = e.gamepad.index; document.getElementById('gamepadStatus').textContent = 'Polaczony'; document.getElementById('gamepadStatus').style.color = '#a2f279'; addLogMessage(`[UI] Gamepad polaczony: ${e.gamepad.id}`, 'success'); });
    window.addEventListener('gamepaddisconnected', (e) => { gamepadIndex = null; document.getElementById('gamepadStatus').textContent = 'Brak'; document.getElementById('gamepadStatus').style.color = '#f7b731'; addLogMessage('[UI] Gamepad rozlaczony.', 'warn'); });
    
    function startMapping(action, buttonElement) { if (gamepadIndex === null) { addLogMessage("Podlacz gamepada, aby rozpoczac mapowanie!", "warn"); return; } isMappingButton = true; actionToMap = action; document.querySelectorAll('.mapping-button').forEach(btn => btn.textContent = "Przypisz"); buttonElement.textContent = "Czekam..."; addLogMessage(`[UI] Nasluchiwanie na przycisk dla akcji: ${availableActions[action].label}...`, "info"); }
    function renderMappingModal() { const list = document.getElementById('gamepad-mapping-list'); list.innerHTML = ''; for (const [action, config] of Object.entries(availableActions)) { const row = document.createElement('div'); row.className = 'mapping-row'; const buttonIndex = Object.keys(gamepadMappings).find(key => gamepadMappings[key] === action); row.innerHTML = `<span class="mapping-label">${config.label}</span><span class="mapping-display">${buttonIndex !== undefined ? `Przycisk ${buttonIndex}` : 'Brak'}</span><button class="mapping-button" data-action="${action}">Przypisz</button>`; list.appendChild(row); } list.querySelectorAll('.mapping-button').forEach(button => { button.addEventListener('click', (e) => { const action = e.target.dataset.action; startMapping(action, e.target); }); }); }
    
    const debounce = (func, delay) => { let timeout; return function(...args) { const context = this; clearTimeout(timeout); timeout = setTimeout(() => func.apply(context, args), delay); }; };
    function addLogMessage(message, level = 'info') { const logHistory = document.getElementById('log-history'); if (!logHistory) return; const timestamp = new Date().toLocaleTimeString(); let color = '#fff'; if (level === 'error') color = '#ff6347'; else if (level === 'warn') color = '#f7b731'; else if (level === 'success') color = '#a2f279'; const logEntry = document.createElement('div'); logEntry.style.color = color; logEntry.textContent = `[${timestamp}] ${message}`; logHistory.prepend(logEntry); while (logHistory.children.length > 200) { logHistory.removeChild(logHistory.lastChild); } }
    function clearLogs() { document.getElementById('log-history').innerHTML = ''; }
    function toggleAccordion(header) { const content = header.nextElementSibling; header.classList.toggle('active'); if (content.style.maxHeight && content.style.maxHeight !== '0px') { content.style.maxHeight = '0px'; } else { content.style.maxHeight = content.scrollHeight + "px"; } }
    function updateAccordionHeight(content) { if (content && content.style.maxHeight !== '0px') { content.style.maxHeight = content.scrollHeight + 'px'; } }
    
    async function connectBLE() { addLogMessage('[UI] Prosze o wybranie urzadzenia Bluetooth...', 'info'); try { bleDevice = await navigator.bluetooth.requestDevice({ filters: [{ services: [SERVICE_UUID] }], optionalServices: [SERVICE_UUID] }); addLogMessage(`[UI] Laczenie z ${bleDevice.name}...`, 'info'); document.getElementById('connectBleBtn').disabled = true; document.getElementById('connectionText').textContent = 'Laczenie...'; bleDevice.addEventListener('gattserverdisconnected', onDisconnected); const server = await bleDevice.gatt.connect(); const service = await server.getPrimaryService(SERVICE_UUID); rxCharacteristic = await service.getCharacteristic(RX_UUID); txCharacteristic = await service.getCharacteristic(TX_UUID); await txCharacteristic.startNotifications(); txCharacteristic.addEventListener('characteristicvaluechanged', handleBleNotification); document.getElementById('connectionStatus').className = 'status-indicator status-ok'; document.getElementById('connectionText').textContent = 'Polaczony'; addLogMessage('[UI] Polaczono! Zadam konfiguracji...', 'success'); setTimeout(() => { sendBleMessage({ type: 'request_full_config' }); }, 500); } catch (error) { addLogMessage(`[UI] Blad polaczenia BLE: ${error}`, 'error'); document.getElementById('connectionStatus').className = 'status-indicator status-error'; document.getElementById('connectionText').textContent = 'Blad polaczenia'; document.getElementById('connectBleBtn').disabled = false; } }
    function onDisconnected() { addLogMessage('[UI] Rozlaczono z robotem.', 'warn'); document.getElementById('connectionStatus').className = 'status-indicator status-disconnected'; document.getElementById('connectionText').textContent = 'Rozlaczony'; ['balanceSwitch', 'holdPositionSwitch', 'speedModeSwitch'].forEach(id => { const el = document.getElementById(id); if (el) el.checked = false; }); document.getElementById('connectBleBtn').disabled = false; rxCharacteristic = null; txCharacteristic = null; }
    
    function handleBleNotification(event) {
        const value = event.target.value;
        const decoder = new TextDecoder('utf-8');
        bleBuffer += decoder.decode(value);
        let newlineIndex;
        while ((newlineIndex = bleBuffer.indexOf('\n')) !== -1) {
            const line = bleBuffer.substring(0, newlineIndex).trim();
            bleBuffer = bleBuffer.substring(newlineIndex + 1);
            if (line) {
                try {
                    const data = JSON.parse(line);
                    if (tuningSession && tuningSession.isCollecting) tuningSession.recordTelemetry(data);
                    processCompleteMessage(data);
                } catch (e) { addLogMessage(`[UI] Blad parsowania JSON: ${e}. Dane: ${line}`, 'error'); }
            }
        }
    }

    async function sendBleMessage(message) { if (!rxCharacteristic) return; try { const encoder = new TextEncoder(); await rxCharacteristic.writeValueWithoutResponse(encoder.encode(JSON.stringify(message) + '\n')); } catch (error) { addLogMessage(`[UI] Blad wysylania danych BLE: ${error}`, 'error'); } }
    
    function processCompleteMessage(data) {
        if(data.type === 'telemetry' && data.robot_state) {
            const previousState = lastKnownRobotState;
            lastKnownRobotState = data.robot_state;
            if(tuningSession) tuningSession.onStateChange(previousState, lastKnownRobotState);
        }

        switch (data.type) {
            case 'telemetry':
                updateTelemetryUI(data);
                updateChart(data);
                break;
            case 'full_config':
                isApplyingConfig = true;
                applyFullConfig(data.params);
                isApplyingConfig = false;
                break;
            case 'log':
                addLogMessage(`[ROBOT] ${data.message}`, data.level);
                break;
            case 'single_pwm_result':
                const p = data.params;
                const inputId = `minPwm${p.motor.charAt(0).toUpperCase() + p.motor.slice(1)}${p.direction.charAt(0).toUpperCase() + p.direction.slice(1)}Input`;
                document.getElementById(inputId).value = p.value;
                addLogMessage(`[UI] Auto-strojenie dla ${p.motor} ${p.direction} zakonczone. Wynik: ${p.value}`, 'success');
                break;
            case 'validation_result':
                 if(tuningSession && tuningSession.testType === 'square_validation') {
                    tuningSession.processValidationResult(data);
                 }
                 break;
        }
    }

    function applyFullConfig(params) {
        for (const [inputId, snakeKey] of Object.entries(parameterMapping)) {
            const input = document.getElementById(inputId);
            if (input && params[snakeKey] !== undefined) {
                let value = params[snakeKey];
                if (['turn_factor', 'expo_joystick', 'joystick_sensitivity', 'joystick_deadzone', 'balance_pid_derivative_filter_alpha'].includes(snakeKey)) {
                     value = (value * 100);
                }
                input.value = value;
            }
        }
    }
    
    function updateTelemetryUI(data) {
        if (data.robot_state !== undefined) document.getElementById('robotStateVal').textContent = data.robot_state;
        if (data.pitch !== undefined) {
            document.getElementById('angleVal').textContent = data.pitch.toFixed(1) + ' \u00B0';
            document.getElementById('angleIndicator').style.transform = `rotate(${data.pitch}deg)`;
        }
        if (data.yaw !== undefined) document.getElementById('yawVal').textContent = data.yaw.toFixed(1) + ' \u00B0';
        if (data.speed !== undefined) document.getElementById('speedVal').textContent = parseFloat(data.speed).toFixed(0);
        if (data.encoder_left !== undefined) document.getElementById('encoderLeftVal').textContent = data.encoder_left;
        if (data.encoder_right !== undefined) document.getElementById('encoderRightVal').textContent = data.encoder_right;
        const emergencyBanner = document.getElementById('emergency-banner');
        if (emergencyBanner) emergencyBanner.style.display = data.emergency_stop ? 'block' : 'none';
    }

    const telemetryChart = new Chart(document.getElementById('telemetryChart'), { type: 'line', data: { labels: Array(100).fill(''), datasets: [] }, options: { animation: false, responsive: true, maintainAspectRatio: false, scales: { x: { display: false }, y: { type: 'linear', display: true, position: 'left', ticks: { color: '#61dafb' }, title: { display: true, text: 'Wartosc', color: '#61dafb' } } }, plugins: { legend: { labels: { color: '#fff' } } } } });
    
    function updateChart(data) {
        const chartData = telemetryChart.data;
        if (chartData.labels.length >= 100) chartData.labels.shift();
        chartData.labels.push('');
        for (const [key, value] of Object.entries(data)) {
            if (availableTelemetry[key] && value !== undefined) {
                let dataset = chartData.datasets.find(ds => ds.label === availableTelemetry[key].label);
                if (!dataset) continue;
                if (dataset.data.length >= 100) dataset.data.shift();
                dataset.data.push(value);
            }
        }
        chartData.datasets.forEach(ds => {
            if (ds.data.length < chartData.labels.length) {
                if (ds.data.length >= 100) ds.data.shift();
                ds.data.push(null);
            }
        });
        telemetryChart.update('none');
    }
    
    function setupChartControls() {
        const container = document.getElementById('chartControls');
        container.innerHTML = '';
        Object.keys(availableTelemetry).forEach((key) => {
            const label = document.createElement('label'), checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.value = key;
            checkbox.checked = (key === 'pitch');
            checkbox.addEventListener('change', (e) => {
                const varName = e.target.value;
                if (e.target.checked) {
                    if (!telemetryChart.data.datasets.find(ds => ds.label === availableTelemetry[varName].label)) {
                        telemetryChart.data.datasets.push({ label: availableTelemetry[varName].label, data: Array(telemetryChart.data.labels.length).fill(null), borderColor: availableTelemetry[varName].color, fill: false, tension: 0.1, pointRadius: 0 });
                    }
                } else {
                    const datasetIndex = telemetryChart.data.datasets.findIndex(ds => ds.label === availableTelemetry[varName].label);
                    if (datasetIndex > -1) telemetryChart.data.datasets.splice(datasetIndex, 1);
                }
                telemetryChart.update();
            });
            label.appendChild(checkbox);
            label.append(` ${availableTelemetry[key].label}`);
            container.appendChild(label);
            if (checkbox.checked) checkbox.dispatchEvent(new Event('change'));
        });
    }

    function populatePresetSelect() { const select = document.getElementById('pidPresetSelect'); select.innerHTML = ''; for (const [index, preset] of Object.entries(builtInPresetsData)) { const option = document.createElement('option'); option.value = index; option.textContent = preset.name; select.appendChild(option); } for (let i = 0; i < localStorage.length; i++) { const key = localStorage.key(i); if (key.startsWith(CUSTOM_PRESET_PREFIX)) { const presetName = key.substring(CUSTOM_PRESET_PREFIX.length); const option = document.createElement('option'); option.value = key; option.textContent = `Wlasny: ${presetName}`; select.appendChild(option); } } }
    async function applySelectedPreset() { const select = document.getElementById('pidPresetSelect'); const selectedValue = select.value; let presetData; if (selectedValue.startsWith(CUSTOM_PRESET_PREFIX)) { presetData = JSON.parse(localStorage.getItem(selectedValue)); } else { presetData = builtInPresetsData[selectedValue]?.params; } if (presetData) { isApplyingConfig = true; for (const [key, value] of Object.entries(presetData)) { const input = document.getElementById(key); if (input) { input.value = value; } } isApplyingConfig = false; addLogMessage('[UI] Zastosowano wartosci presetu. Zapisz na robocie, aby wyslac.', 'info'); } }
    function saveCurrentAsPreset() { const presetName = prompt("Podaj nazwe dla nowego presetu:", ""); if (presetName && presetName.trim() !== "") { const presetData = {}; Object.keys(parameterMapping).forEach(inputId => { const input = document.getElementById(inputId); if (input) { presetData[inputId] = parseFloat(input.value); } }); localStorage.setItem(CUSTOM_PRESET_PREFIX + presetName.trim(), JSON.stringify(presetData)); addLogMessage(`[UI] Zapisano wlasny preset '${presetName.trim()}'.`, 'success'); populatePresetSelect(); } }
    function deleteSelectedPreset() { const select = document.getElementById('pidPresetSelect'); const selectedValue = select.value; if (!selectedValue.startsWith(CUSTOM_PRESET_PREFIX)) { addLogMessage('[UI] Nie mozna usunac wbudowanego presetu.', 'warn'); return; } if (confirm(`Czy na pewno chcesz usunac preset '${selectedValue.substring(CUSTOM_PRESET_PREFIX.length)}'?`)) { localStorage.removeItem(selectedValue); addLogMessage(`[UI] Usunieto preset.`, 'info'); populatePresetSelect(); } }

    function setupNumericInputs() { document.querySelectorAll('.numeric-input-wrapper').forEach(wrapper => { const container = wrapper.closest('.setting-container') || wrapper.closest('.pwm-input-row'); if (!container) return; const input = container.querySelector('input[type=number]'); const minusBtn = wrapper.querySelector('button:first-child'); const plusBtn = wrapper.querySelector('button:last-child'); if (!input || !minusBtn || !plusBtn || input.disabled) return; const step = parseFloat(input.step) || 1; const isFloat = input.step.includes('.'); const updateValue = (amount) => { let current = parseFloat(input.value); if (isNaN(current)) current = 0; let newValue = current + amount; if (isFloat) { const dp = (step.toString().split('.')[1] || '').length; newValue = parseFloat(newValue.toFixed(dp)); } const min = parseFloat(input.min); const max = parseFloat(input.max); if (!isNaN(min)) newValue = Math.max(min, newValue); if (!isNaN(max)) newValue = Math.min(max, newValue); input.value = newValue; input.dispatchEvent(new Event('change', { bubbles: true })); }; minusBtn.addEventListener('click', () => updateValue(-step)); plusBtn.addEventListener('click', () => updateValue(step)); }); }

    function sendFullConfigToRobot() { const params = {}; for (const [inputId, snakeKey] of Object.entries(parameterMapping)) { const input = document.getElementById(inputId); if (input) { let value = parseFloat(input.value); if (['turn_factor', 'expo_joystick', 'joystick_sensitivity', 'joystick_deadzone', 'balance_pid_derivative_filter_alpha'].includes(snakeKey)) { value /= 100.0; } params[snakeKey] = value; } } addLogMessage('[UI] Wysylam pelna konfiguracje do robota...', 'info'); sendBleMessage({ type: 'full_config', params }); }

    function setupEventListeners() {
        const sendSingleParam = (inputId, value) => { if (isApplyingConfig) return; const snakeKey = parameterMapping[inputId]; if (snakeKey) { if (['turn_factor', 'expo_joystick', 'joystick_sensitivity', 'joystick_deadzone', 'balance_pid_derivative_filter_alpha'].includes(snakeKey)) { value /= 100.0; } sendBleMessage({ type: 'set_param', key: snakeKey, value: value }); } };
        const debouncedSendSingleParam = debounce(sendSingleParam, 400);
        document.querySelectorAll('.config-value').forEach(input => { input.addEventListener('change', (e) => { debouncedSendSingleParam(e.target.id, parseFloat(e.target.value)); }); });
        document.getElementById('joystickCanvas').addEventListener('mousedown', handleJoystickStart); document.addEventListener('mousemove', handleJoystickMove); document.addEventListener('mouseup', handleJoystickEnd); document.getElementById('joystickCanvas').addEventListener('touchstart', handleJoystickStart, { passive: false }); document.addEventListener('touchmove', handleJoystickMove, { passive: false }); document.addEventListener('touchend', handleJoystickEnd); document.addEventListener('touchcancel', handleJoystickEnd);
        document.getElementById('connectBleBtn').addEventListener('click', connectBLE);
        ['balanceSwitch', 'holdPositionSwitch', 'speedModeSwitch'].forEach(id => { document.getElementById(id).addEventListener('change', (e) => { const typeMap = { 'balanceSwitch': 'balance_toggle', 'holdPositionSwitch': 'hold_position_toggle', 'speedModeSwitch': 'speed_mode_toggle' }; sendBleMessage({ type: typeMap[id], enabled: e.target.checked }); }); });
        const toolButtons = { 'resetZeroBtn': { type: 'reset_zero' }, 'trimPlusBtn': { type: 'adjust_zero', value: 1 }, 'trimMinusBtn': { type: 'adjust_zero', value: -1 }, 'resetEncodersBtn': { type: 'reset_encoders' }, 'emergencyStopBtn': { type: 'emergency_stop' } };
        for (const [id, msg] of Object.entries(toolButtons)) { document.getElementById(id)?.addEventListener('click', () => sendBleMessage(msg)); }
        document.getElementById('saveBtn').addEventListener('click', () => { if (confirm("Czy na pewno chcesz wyslac i zapisac cala konfiguracje na robocie?")) { sendFullConfigToRobot(); setTimeout(() => { sendBleMessage({ type: 'save_tunings' }); }, 200); } });
        document.getElementById('loadBtn').addEventListener('click', () => { if (confirm("UWAGA! Spowoduje to nadpisanie wszystkich niezapisanych zmian w panelu. Kontynuowac?")) { sendBleMessage({ type: 'request_full_config' }); } });
        document.getElementById('calibrateMpuBtn')?.addEventListener('click', () => sendBleMessage({ type: 'calibrate_mpu' }));
        document.getElementById('applySelectedPresetBtn').addEventListener('click', applySelectedPreset); document.getElementById('saveCurrentAsPresetBtn').addEventListener('click', saveCurrentAsPreset); document.getElementById('deleteSelectedPresetBtn').addEventListener('click', deleteSelectedPreset);
        document.querySelectorAll('.help-icon').forEach(icon => { icon.addEventListener('click', (e) => { e.stopPropagation(); const container = icon.closest('.setting-container'); const helpText = container.querySelector('.help-text'); if (helpText) { helpText.classList.toggle('visible'); const accordionContent = container.closest('.accordion-content'); if (accordionContent) updateAccordionHeight(accordionContent); } }); });
    }

    function setupManualTuneButtons() { document.querySelectorAll('.manual-tune-row').forEach(row => { const motor = row.dataset.motor; const direction = row.dataset.direction; const input = row.querySelector('.tune-input'); const testBtn = row.querySelector('.test-btn'); const stopBtn = row.querySelector('.stop-btn'); const autoBtn = row.querySelector('.auto-btn'); testBtn.addEventListener('click', () => { sendBleMessage({ type: 'manual_tune_motor', motor, direction, pwm: parseInt(input.value) }); }); stopBtn.addEventListener('click', () => { sendBleMessage({ type: 'manual_tune_motor', motor, direction, pwm: 0 }); }); autoBtn.addEventListener('click', (e) => { if (confirm("UWAGA! Upewnij sie, ze robot jest uniesiony, a kola moga sie swobodnie obracac. Kontynuowac?")) { const startValue = parseInt(document.getElementById('pwmTuneStartInput').value); sendBleMessage({ type: 'autotune_single_pwm', motor, direction, start_pwm: startValue }); e.target.disabled = true; e.target.textContent = 'Szukanie...'; addLogMessage(`[UI] Rozpoczynam auto-strojenie dla ${motor} ${direction}...`, 'info'); } }); }); document.getElementById('manualTuneStopAll').addEventListener('click', () => { sendBleMessage({ type: 'manual_tune_stop_all' }); }); }
    function setupGamepadMappingModal() { document.getElementById('open-gamepad-modal-btn').addEventListener('click', () => { document.getElementById('gamepad-mapping-modal').style.display = 'flex'; }); document.getElementById('close-modal-btn').addEventListener('click', () => { document.getElementById('gamepad-mapping-modal').style.display = 'none'; }); }
    function flashElement(element) { if (!element) return; const target = element.tagName === 'INPUT' ? element.closest('.switch') || element.closest('.control-row') || element : element; target.classList.add('gamepad-flash'); setTimeout(() => target.classList.remove('gamepad-flash'), 300); }
    function loadGamepadMappings() { const saved = localStorage.getItem(GAMEPAD_MAPPING_KEY); gamepadMappings = saved ? JSON.parse(saved) : {}; }
    function saveGamepadMappings() { localStorage.setItem(GAMEPAD_MAPPING_KEY, JSON.stringify(gamepadMappings)); }

    // =======================================================================================
    // === BLOK 2: LOGIKA SYSTEMU AUTO TESTOW ===
    // =======================================================================================
    let tuningSession = null;
    // ... (reszta logiki w kolejnym bloku)
</script>
<script>
    const testConfigurations = {
        'balance': {
            label: 'Strojenie Balansu',
            paramsToTune: { kp_b: { id: 'balanceKpInput', step: 5.0 }, kd_b: { id: 'balanceKdInput', step: 0.2 } }
        },
        'linear': {
            label: 'Strojenie Jazdy Liniowej',
            paramsToTune: { kp_s: { id: 'speedKpInput', step: 0.005 }, kp_p: { id: 'positionKpInput', step: 0.2 }, kd_p: { id: 'positionKdInput', step: 0.1 }, max_target_angle_from_speed_pid: { id: 'maxTargetAngleInput', step: 0.5 } }
        },
        'turn': {
            label: 'Strojenie Obrotu i Kursu',
            paramsToTune: { kp_r: { id: 'rotationKpInput', step: 0.1 }, kd_r: { id: 'rotationKdInput', step: 0.1 }, kp_h: { id: 'headingKpInput', step: 0.1 }, ki_h: { id: 'headingKiInput', step: 0.005 }, kd_h: { id: 'headingKdInput', step: 0.01 } }
        },
        'square_validation': { label: 'Walidacja: Test Kwadratu', paramsToTune: {} }
    };
    
    class TuningSession {
        constructor(testType, options) {
            this.testType = testType;
            this.config = testConfigurations[testType];
            this.options = options;
            this.paramsToTune = this.config.paramsToTune;
            this.paramKeys = Object.keys(this.paramsToTune);
            this.state = 'idle';
            this.isCollecting = false;
            this.telemetryBuffer = [];
            this.currentCycle = 0;
            this.totalCycles = options.totalCycles;
            this.bestScore = -1.0;
            this.bestParams = {};
            this.safeParams = {};
            this.testParams = {};
            this.paramIndex = 0;
            this.lastChange = 1;
        }

        recordTelemetry(data) { if (this.isCollecting && data.type === 'telemetry') this.telemetryBuffer.push(data); }

        onStateChange(previousState, newState) {
            if (!this.isCollecting) return;
            const isRobotIdle = newState.includes('IDLE') || newState.includes('TRZYMA_POZYCJE');
            const wasRobotWorking = previousState.includes('RUCH') || previousState.includes('OBROT');
            if(isRobotIdle && wasRobotWorking) {
                setTimeout(() => this.finishCycle(), 250); // Opóźnienie na ustabilizowanie odczytów
            }
        }

        start() {
            addLogMessage(`[AutoTest] Rozpoczynam sesje: ${this.config.label}`, 'info');
            this.safeParams = {};
            for(const key in this.paramsToTune) {
                const inputId = this.paramsToTune[key].id;
                this.safeParams[key] = parseFloat(document.getElementById(inputId).value);
            }
            this.bestParams = { ...this.safeParams };
            this.currentCycle = 1;
            this.prepareNextCycle();
        }

        prepareNextCycle() {
            this.state = 'ready';
            this.testParams = this.generateNextParams();
            updateAutoTestUI(this);
        }

        runCycle() {
            if (this.state !== 'ready') return;
            this.state = 'testing';
            this.isCollecting = true;
            this.telemetryBuffer = [];
            updateAutoTestUI(this);

            Object.entries(this.testParams).forEach(([key, value]) => {
                sendBleMessage({ type: 'set_param', key: key, value: value });
            });
            addLogMessage(`[AutoTest] Cykl ${this.currentCycle}/${this.totalCycles}. Testuje: ${JSON.stringify(this.testParams)}`, 'info');

            setTimeout(() => { // Dajmy czas na zaaplikowanie parametrow
                if (this.testType === 'balance') {
                    setTimeout(() => this.finishCycle(), this.options.cycleDuration * 1000);
                } else if (this.testType === 'linear') {
                    sendBleMessage({ type: 'execute_move', distance_cm: this.options.distance, and_return: this.options.returnToZero });
                } else if (this.testType === 'turn') {
                    sendBleMessage({ type: 'execute_square_open', side_cm: this.options.side, speed: this.options.speed });
                } else if (this.testType === 'square_validation') {
                    sendBleMessage({ type: 'execute_square_closed', side_cm: 20 });
                }
            }, 200);
        }

        finishCycle() {
            if (!this.isCollecting) return;
            this.isCollecting = false;
            this.state = 'analyzing';
            updateAutoTestUI(this);
            
            Object.entries(this.safeParams).forEach(([key, value]) => {
                 sendBleMessage({ type: 'set_param', key: key, value: value });
            });
            
            const score = this.calculateFitness();
            addLogMessage(`[AutoTest] Wynik Fitness: ${score.toFixed(4)}`, 'success');

            if (score > this.bestScore) {
                this.bestScore = score;
                this.bestParams = { ...this.testParams };
                addLogMessage(`[AutoTest] Nowy najlepszy wynik!`, 'success');
                this.lastChange = 1;
                this.paramIndex = (this.paramIndex + 1) % this.paramKeys.length;
            } else {
                this.lastChange *= -1;
                if(this.lastChange === 1) this.paramIndex = (this.paramIndex + 1) % this.paramKeys.length;
            }

            if (this.currentCycle >= this.totalCycles) {
                this.state = 'finished';
                updateAutoTestUI(this);
            } else {
                this.currentCycle++;
                setTimeout(() => this.prepareNextCycle(), 200);
            }
        }
        
        processValidationResult(data) {
            const { pos_error_cm, yaw_error_deg } = data;
            document.getElementById('validationResultPanel').style.display = 'block';
            document.getElementById('validationPosError').textContent = pos_error_cm.toFixed(2);
            document.getElementById('validationYawError').textContent = yaw_error_deg.toFixed(2);
            let suggestion = "Test zakonczony.";
            if (Math.abs(pos_error_cm) > 2.0) {
                 suggestion = "Duzy blad pozycji. Sprawdz parametry mechaniczne lub uruchom Test Obrotu i Kursu.";
            } else if (Math.abs(yaw_error_deg) > 10.0) {
                 suggestion = "Duzy blad kursu. Uruchom Test Obrotu i Kursu, aby poprawic precyzje.";
            } else {
                suggestion = "Wynik bardzo dobry! Parametry sa dobrze zestrojone.";
            }
            document.getElementById('validationSuggestion').textContent = suggestion;
            this.state = 'finished';
            updateAutoTestUI(this);
        }

        cancel() {
            this.state = 'idle'; this.isCollecting = false;
            if(Object.keys(this.safeParams).length > 0) {
                Object.entries(this.safeParams).forEach(([key, value]) => sendBleMessage({ type: 'set_param', key, value }));
            }
            addLogMessage('[AutoTest] Sesja anulowana przez uzytkownika.', 'warn');
            updateAutoTestUI(null);
        }

        generateNextParams() {
            if (this.paramKeys.length === 0) return {};
            const stepMultiplier = 0.05;
            let nextParams = { ...this.bestParams };
            const currentParamKey = this.paramKeys[this.paramIndex];
            const baseValue = this.bestParams[currentParamKey];
            const step = Math.max(Math.abs(baseValue * stepMultiplier), this.paramsToTune[currentParamKey].step) * this.lastChange;
            nextParams[currentParamKey] += step;
            if (nextParams[currentParamKey] < 0 && !['kd_b', 'kd_p', 'kd_r', 'kd_h'].includes(currentParamKey)) nextParams[currentParamKey] = 0; // Zapobiegaj ujemnym Kp/Ki
            return nextParams;
        }

        calculateFitness() {
            if (this.telemetryBuffer.length < 10) return 0.0;
            if (this.testType === 'balance') return this.calculateBalanceFitness();
            if (this.testType === 'linear') return this.calculateLinearFitness();
            if (this.testType === 'turn') return this.calculateTurnFitness();
            return 0.0;
        }

        calculateBalanceFitness() {
            const { telemetryBuffer: buffer, options } = this;
            let sumAbsPitch = 0, maxAbsPitch = 0, sumAbsSpeed = 0, sumAbsOutputChange = 0, inZoneSamples = 0;
            buffer.forEach((d, i) => {
                const { pitch = 0, speed = 0, output = 0 } = d;
                sumAbsPitch += Math.abs(pitch);
                if (Math.abs(pitch) > maxAbsPitch) maxAbsPitch = Math.abs(pitch);
                if (Math.abs(pitch) <= options.idealZone) inZoneSamples++;
                sumAbsSpeed += Math.abs(speed);
                if (i > 0) sumAbsOutputChange += Math.abs(output - (buffer[i-1].output || 0));
            });
            const count = buffer.length;
            const avgAbsPitch = sumAbsPitch / count, avgAbsSpeed = sumAbsSpeed / count, avgAbsOutputChange = sumAbsOutputChange / (count -1);
            const scoreOvershoot = Math.max(0, 1 - (maxAbsPitch / 5.0));
            const scoreStability = Math.max(0, 1 - (avgAbsPitch / 1.5));
            const scoreJitter = Math.max(0, 1 - (avgAbsSpeed / 100));
            const scoreEffort = Math.max(0, 1 - (avgAbsOutputChange / 50));
            const scoreTimeInZone = inZoneSamples / count;
            return (scoreOvershoot + scoreStability + scoreJitter + scoreEffort + scoreTimeInZone) / 5.0;
        }
        
        calculateLinearFitness() {
            const { telemetryBuffer: buffer, options } = this;
            const startL = buffer[0].encoder_left, startR = buffer[0].encoder_right;
            const endL = buffer[buffer.length-1].encoder_left, endR = buffer[buffer.length-1].encoder_right;
            const pulsesPerCm = parseFloat(document.getElementById('encoderPprInput').value) / (Math.PI * parseFloat(document.getElementById('wheelDiameterInput').value));
            const targetPulses = options.distance * pulsesPerCm;
            
            const travelledPulses = ((endL - startL) + (endR - startR)) / 2;
            const positionError = options.returnToZero ? Math.abs(((endL-startL) + (endR-startR))/2) : Math.abs(targetPulses - travelledPulses);
            
            const scoreAccuracy = Math.max(0, 1 - (positionError / (2 * pulsesPerCm))); // Tolerancja bledu 2cm
            const balanceScore = this.calculateBalanceFitness();
            return (scoreAccuracy * 0.7) + (balanceScore * 0.3);
        }

        calculateTurnFitness() {
            const { telemetryBuffer: buffer } = this;
            let totalYawError = 0;
            let turnCount = 0;
            let lastYaw = buffer[0].yaw || 0;
            buffer.forEach(d => {
                if (d.robot_state === "OBROT" && Math.abs((d.yaw || 0) - lastYaw) > 80) { // Wykryj skok o 90 stopni
                    totalYawError += Math.abs(90 - Math.abs((d.yaw || 0) - lastYaw));
                    turnCount++;
                    lastYaw = d.yaw || 0;
                }
            });
            const avgYawError = turnCount > 0 ? totalYawError / turnCount : 90;
            const scoreAccuracy = Math.max(0, 1 - (avgYawError / 15.0)); // Tolerancja 15 stopni
            const balanceScore = this.calculateBalanceFitness();
            return (scoreAccuracy * 0.6) + (balanceScore * 0.4);
        }

        applyBestResults() {
            for(const key in this.bestParams) {
                const inputId = this.paramsToTune[key].id;
                document.getElementById(inputId).value = this.bestParams[key].toFixed(4);
                document.getElementById(inputId).dispatchEvent(new Event('change', { bubbles: true }));
            }
            addLogMessage('[AutoTest] Zastosowano najlepsze znalezione parametry.', 'success');
            this.cancel();
        }
    }

    function setupAutoTestEventListeners() {
        const optionsDiv = document.getElementById('autotestOptions');
        const actionBtn = document.getElementById('autotestActionBtn');
        const cancelBtn = document.getElementById('autotestCancelBtn');
        const radioButtons = document.querySelectorAll('input[name="autotest-type"]');

        radioButtons.forEach(radio => {
            radio.addEventListener('change', (e) => {
                const testType = e.target.value;
                optionsDiv.innerHTML = '';
                if (tuningSession) tuningSession.cancel();

                actionBtn.disabled = false;
                actionBtn.textContent = 'Rozpocznij Sesje';
                document.getElementById('validationResultPanel').style.display = 'none';

                if (testType === 'balance') {
                    optionsDiv.innerHTML = `<div class="setting-container"><label for="at_cycles">Liczba cykli:</label><input id="at_cycles" type="number" value="10" min="2" max="50" style="width:90px;"></div><div class="setting-container"><label for="at_duration">Czas trwania cyklu (s):</label><input id="at_duration" type="number" value="5" min="3" max="20" style="width:90px;"></div>`;
                } else if (testType === 'linear') {
                     optionsDiv.innerHTML = `<div class="setting-container"><label for="at_cycles">Liczba cykli:</label><input id="at_cycles" type="number" value="10" min="2" max="50" style="width:90px;"></div><div class="setting-container"><label for="at_distance">Dystans (cm):</label><input id="at_distance" type="number" value="20" min="10" max="100" style="width:90px;"></div><div class="control-row"><span class="control-label">Powrot na start</span><label class="switch"><input type="checkbox" id="at_return" class="slider-checkbox"><span class="slider round"></span></label></div>`;
                } else if (testType === 'turn') {
                     optionsDiv.innerHTML = `<div class="setting-container"><label for="at_cycles">Liczba cykli:</label><input id="at_cycles" type="number" value="20" min="2" max="50" style="width:90px;"></div><div class="setting-container"><label for="at_side">Dlugosc boku (cm):</label><input id="at_side" type="number" value="20" min="10" max="50" style="width:90px;"></div><div class="setting-container"><label for="at_speed">Predkosc (imp/s):</label><input id="at_speed" type="number" value="400" min="100" max="1500" style="width:90px;"></div>`;
                } else if (testType === 'square_validation') {
                     optionsDiv.innerHTML = `<p>Test walidacyjny uruchomi sekwencje jazdy po kwadracie o boku 20cm.</p>`;
                     actionBtn.textContent = 'Uruchom Walidacje';
                }
                updateAccordionHeight(optionsDiv.closest('.accordion-content'));
            });
        });

        actionBtn.addEventListener('click', () => {
            if (!tuningSession || tuningSession.state === 'idle') {
                const selectedRadio = document.querySelector('input[name="autotest-type"]:checked');
                if (!selectedRadio) return;
                
                const testType = selectedRadio.value;
                const config = testConfigurations[testType];
                if(!config) return;

                let options = {};
                if(document.getElementById('at_cycles')) options.totalCycles = parseInt(document.getElementById('at_cycles').value);
                if(document.getElementById('at_duration')) options.cycleDuration = parseInt(document.getElementById('at_duration').value);
                if(document.getElementById('at_distance')) options.distance = parseInt(document.getElementById('at_distance').value);
                if(document.getElementById('at_return')) options.returnToZero = document.getElementById('at_return').checked;
                if(document.getElementById('at_side')) options.side = parseInt(document.getElementById('at_side').value);
                if(document.getElementById('at_speed')) options.speed = parseInt(document.getElementById('at_speed').value);

                tuningSession = new TuningSession(testType, options);
                tuningSession.start();

            } else if (tuningSession.state === 'ready') {
                tuningSession.runCycle();
            } else if (tuningSession.state === 'finished') {
                tuningSession.applyBestResults();
            }
        });

        cancelBtn.addEventListener('click', () => {
            if (tuningSession) tuningSession.cancel();
        });
    }

    function updateAutoTestUI(session) {
        const actionBtn = document.getElementById('autotestActionBtn');
        const cancelBtn = document.getElementById('autotestCancelBtn');
        const statusParams = document.getElementById('statusTestedParams');
        const statusBestScore = document.getElementById('statusBestScore');
        const statusBar = document.getElementById('statusProgressBar');
        const statusProgressText = document.getElementById('statusProgressText');
        const statusStateText = document.getElementById('statusStateText');

        if (!session || session.state === 'idle') {
            statusParams.textContent = '---';
            statusBestScore.textContent = '---';
            statusBar.value = 0;
            statusProgressText.textContent = 'Wybierz test i rozpocznij...';
            statusStateText.textContent = 'Bezczynny';
            const selectedRadio = document.querySelector('input[name="autotest-type"]:checked');
            if(selectedRadio) {
                actionBtn.textContent = selectedRadio.value === 'square_validation' ? 'Uruchom Walidacje' : 'Rozpocznij Sesje';
                actionBtn.disabled = false;
            } else {
                 actionBtn.textContent = 'Wybierz test, aby rozpoczac';
                 actionBtn.disabled = true;
            }
            cancelBtn.style.display = 'none';
            document.getElementById('validationResultPanel').style.display = 'none';
            return;
        }

        cancelBtn.style.display = 'block';
        statusBar.max = session.totalCycles;
        statusBar.value = session.currentCycle -1;
        
        statusBestScore.textContent = session.bestScore < 0 ? '---' : session.bestScore.toFixed(4);
        
        switch (session.state) {
            case 'ready':
                let paramsText = Object.entries(session.testParams).map(([key, val]) => `${key}: ${val.toFixed(3)}`).join(', ');
                statusParams.textContent = paramsText;
                statusProgressText.textContent = `Cykl ${session.currentCycle}/${session.totalCycles}`;
                statusStateText.textContent = 'Gotowy do testu';
                actionBtn.textContent = `Uruchom Cykl ${session.currentCycle}/${session.totalCycles}`;
                actionBtn.disabled = false;
                break;
            case 'testing':
                statusStateText.textContent = 'Testowanie...';
                actionBtn.textContent = 'Testowanie...';
                actionBtn.disabled = true;
                break;
            case 'analyzing':
                statusStateText.textContent = 'Analiza danych...';
                actionBtn.textContent = 'Analiza danych...';
                actionBtn.disabled = true;
                break;
            case 'finished':
                statusBar.value = session.totalCycles;
                if(session.testType !== 'square_validation') {
                    let bestParamsText = Object.entries(session.bestParams).map(([key, val]) => `${key}: ${val.toFixed(3)}`).join(', ');
                    statusParams.textContent = bestParamsText;
                    statusProgressText.textContent = `Zakonczono (${session.totalCycles}/${session.totalCycles})`;
                    statusStateText.textContent = 'Sesja zakonczona!';
                    actionBtn.textContent = 'Zastosuj najlepsze parametry';
                    actionBtn.disabled = false;
                } else {
                    statusStateText.textContent = 'Walidacja zakonczona.';
                    actionBtn.textContent = 'Uruchom ponownie';
                    actionBtn.disabled = false;
                }
                break;
        }
    }
</script>

</body>
</html>